:chapterNumber: 3
:chapterId: chapter-03
:sourceDir: ./examples
:sourceSample: TODO.js
:nodeCurrentVersion: v8
:npmCurrentVersion: v5
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Jouer avec JavaScript

Programmer une application Node c'est aussi
l'occasion d'apprendre JavaScript.
Ou de se mettre à jour ou de redécouvrir le langage.

Ce chapitre explique ce qu'il faut pour
comprendre comment fonctionne JavaScript.
Nous utiliserons une approche par l'exemple.

====
.Sommaire
- Qu'est-ce que JavaScript, pour de vrai ?
- Comprendre l'évolution de la spécification ECMAScript
- Manipuler les différentes structures du langage
- En savoir plus sur des éléments avancés du langage
====

[abstract]
--
JavaScript est souvent raillé.
Parce que ce n'est pas un vrai langage.
Parce qu'il a été créé en 6 jours.
Parce qu'il n'est pas orienté objet.

JavaScript est un langage expressif qui a énormément gagné en maturité
depuis les années 2010.
Il se révèle parfaitement opérationnel dès lors que l'on s'intéresse
à ses fonctionnalités, sans faire de hors-piste.

Les types de données et les méthodes de manipulations qu'elles nous offrent
permettent d'écrire un code plus simple, à lire et à produire.
Certaines structures de données nous aident à mieux organiser nos données
ainsi qu'à mieux les traiter.
--

toc::[]

[[definition]]
== Qu'est-ce que JavaScript ?

Au lieu d'écrire plusieurs paragraphes expliquant ce qu'est et
ce que n'est pas _pas_ JavaScript, regardons ensemble
un bloc de code contenant plusieurs _expressions_ écrites
en JavaScript :

[source,javascript]
.definition.js
----
include::{sourceDir}/definition.js[]
----
<1> Code JavaScript standard ;
<2> Code JavaScript pour manipuler la DOM API (documents web) ;
<3> Code JavaScript pour manipuler des Web API (fonctionnalités des navigateurs web) ;
<4> Code JavaScript pour manipuler Node.js.

Ce que l'on peut comprendre de l'exemple de code ci-dessus,
c'est que JavaScript permet de s'interfacer avec plusieurs choses :

. des documents web représentés par le Document Object Model (DOM) ;
. des navigateurs web au travers des Web API ;
. des systèmes informatiques avec Node.

_ECMAScript_ correspond à l'ensemble des expressions du langage.
Ces expressions sont étendues par des interfaces de programmation (_API_).
Ces interfaces nous permettent de communiquer avec les documents web, les navigateurs web ou les systèmes informatiques.

[NOTE]
.[RemarquePreTitre]#Histoire# À propos de JavaScript
====
JavaScript a été inventé en 1995 par Brendan Eich alors qu'il était employé de la société _Netscape Communications_.
Microsoft lui emboîte le pas en incluant JavaScript dans son logiciel Internet Explorer, alors en version 3.
Pour des raisons de droits de marque, il y est dénommé _JScript_.

La spécification est ensuite validée par l'organisme _Ecma International_ en juin 1997 sous le nom d'_ECMAScript_, standard ECMA-262.

L'utilisation du terme _JavaScript_ est resté dans le vocabulaire courant. Mais c'est bien d'_ECMAScript_ dont on parle, vraiment.

Adobe Flash utilise un dérivé d'ECMAScript : ActionScript.
Bien des machines virtuelles sont capables d'interpréter partiellement ou intégralement ECMAScript : Rhino, Konq, BESEN en Object Pascal ou encore Esprima qui est elle-même écrite en… ECMAScript.
====

Si d'autres langages de programmation se cantonnent
soit au _côté client_ (VBScript, ActionScript, Elm)
soit au _côté serveur_ (Ruby, Python, Haskell),
JavaScript a débuté _côté client_ pour s'étendre au _côté serveur_.
Ce à quoi se réfère l'expression anglophone _full stack_.

.Écosystème des technologies JavaScript.
image::images/javascript.svg[]

Le langage _ECMAScript_ — appelons-le ainsi à partir de maintenant —
a évolué au fil du temps.
Il s'est enrichi au fil du temps de nouvelles fonctionnalités,
de sucres syntaxiques (raccourcis d'écriture)
et de rigueur aussi, pour corriger des défauts de _design_.

Le comité de travail _TC39_ (_Technical Committee_,
[URL]#https://github.com/tc39#) est en charge de l'évolution
du langage, standardisé sous le doux sobriquet de _standard ECMA-262_.
À charge ensuite aux différents implémenteurs de suivre les changements
et de les incorporer dans leurs machines virtuelles.

Node se base sur la machine virtuelle <<../chapter-01/index.adoc#v8,V8 de Google>> pour interpréter les expressions ECMAScript.
De fait, Node comprend les mêmes expressions ECMAScript que _V8_.

Nous verrons un peu plus tard dans ce chapitre comment suivre la
compatibilité de Node avec ECMAScript.
Intéressons-nous à l'évolution du langage, et ce que ça nous apporte.

=== ECMAScript 5 (aka _ES5_)

ECMAScript a été standardisé dans sa version 5 en décembre 2009.
La révision 5.1 de juin 2011 est une correction mineure de la spécification.

Il s'agit d'une évolution majeure dans l'histoire du langage.
La précédente version — ECMAScript 3 — était agée de… *dix ans*…

ECMAScript 5 limite drastiquement certains effets indésirables du langage
grâce au _mode strict_.
De nouvelles méthodes de manipulation de tableaux et d'objets voient le jour
ainsi qu'un support natif du format de données _JSON_.

La standardisation de cette version d'ECMAScript a contribué à redorer
l'image du langage mais aussi à faire émerger de nouvelles pratiques
de programmation.

[horizontal]
Table de compatibilité::
  [URL]#https://kangax.github.io/compat-table/es5/#
Spécification::
  [URL]#https://www.ecma-international.org/ecma-262/5.1/#

image::images/compat-table.png[align="center",width="85%"]

=== ECMAScript 2015 (aka _ES6_ puis _ES2015_)

La spécification *ECMAScript 2015* (_ES2015_) a été publiée en juin 2015.
Elle succède à *ECMAScript 5* après 6 années de gestation. +
Cette version a successivement été appelée _ECMAScript Harmony_, _ECMAScript 6_, puis _ECMAScript 2015_.

Le processus de standardisation a mis 6 années pour aboutir
mais cette fois-ci, les choses se sont déroulées différemment. +
De nombreuses idées ont été piochées dans le langage
_CoffeeScript_ ([URL]#http://coffeescript.org#).
Et surtout, un nouveau type d'outillage s'est formé pour commencer
à utiliser ce JavaScript du futur avec les compilateurs
_traceur_ de Google dès 2011 ([URL]#https://github.com/google/traceur-compiler#)
puis le projet indépendant _6to5_ dès 2014.
_6to5_ a été renommé en _babel_ ([URL]#https://babeljs.io#)
et son instigateur a par la suite été embauché par Facebook.

La pratique de compiler du JavaScript en JavaScript était en rupture
avec ce qui se faisait précédemment :
attendre qu'une fonctionnalité soit adoptée par un dénominateur commun
de navigateurs web pour s'en servir.
Cette fois-ci, on pouvait se servir du futur, dès aujourd'hui.

De fait, il n'y a pas eu à attendre 6 ans et l'implémentation
par les différents implémenteurs pour profiter de ce
qu'il y avait de meilleur.

Le prix à payer ? Un ticket d'entrée plus élevé lié à la maitrise
de l'outillage associé.

[horizontal]
Table de compatibilité (navigateurs web)::
  [URL]#https://kangax.github.io/compat-table/es6/#
Table de compatibilité (Node.js)::
  [URL]#http://node.green/#
Spécification::
  [URL]#https://www.ecma-international.org/ecma-262/6.0/#

.Illustration de l'évolution de la compatibilité ECMAScript au fil des versions de Node.
image::images/node-green.png[align="center",width="85%"]


=== ECMAScript 2016 etc. (aka _ES2016_, …)

Depuis la sortie d'_ECMAScript 2015_, l'intention est de publier une
nouvelle spécification par an.
L'envie était de travailler fonctionnalité par fonctionnalité
et de ne pas attendre trop longtemps avant de les ratifier.
En conséquent, les nouvelles versions annuelles sont beaucoup plus
incrémentales.
Elles se font moins attendre et contiennent moins de grands bouleversements.

Les fonctionnalités en cours de préparation sont listées
dans ce dépôt GitHub : [URL]#https://github.com/tc39/proposals#.
Le dernier stade avant la validation d'une fonctionnalité est le _stage 3_.
Dès qu'une fonctionnalité passe en _stage 4_, elle est incluse
dans la prochaine version version d'ECMAScript
— _ECMAScript {docyear}_ une fois l'année {docyear} terminée.

Les fonctionnalités approuvées sont consignées dans ce document :
[URL]#https://github.com/tc39/proposals/blob/master/finished-proposals.md#.

[[primitives]]
== Les éléments de base du langage

ECMAScript permet de manipuler différents _types_ de données.
Cette section s'intéresse à décrire les notions nécessaires
pour s'approprier le reste des exemples de l'ouvrage.
On apprendra notamment à manipuler des variables, à faire
des boucles sur des collections et à faire la différence
entre un objet et une fonction.

Mais qu'entend-t'on par _type de données_ ?
Faisons nous notre propre idée avec une suite d'exemples.
Ces notions seront dévelopées dans le reste du chapitre,
pour mieux comprendre ce que l'on peut en faire.

[source%interactive,javascript]
.base/string.js
----
include::{sourceDir}/base/string.js[]
----

Une valeur entourée de guillemets est considérée
par l'interpréteur ECMAScript comme une *chaîne de caractères*, du texte.

Ces guillemets peuvent être des guillemets simples (`'`),
des guillemets doubles (`"`) ou des guillemets obliques (```).

On peut effectuer des opérations d'identification ou d'assemblage avec une
valeur de _type chaîne de caractères_.


[source%interactive,javascript]
.base/number.js
----
include::{sourceDir}/base/number.js[]
----

ECMAScript considère les entiers (`3` dans cet exemple)
et les nombres flottants (`12.3` dans cet exemple) comme des nombres.
Il ne fait _pas_ de distinction entre les deux.

On peut effectuer des *opérations mathématiques* entre plusieurs
valeurs de _type nombre_.

[source%interactive,javascript]
.base/boolean.js
----
include::{sourceDir}/base/boolean.js[]
----

ECMAScript considère deux valeurs pour signifier _vrai_ ou _faux_,
respectivement `true` et `false`.

On peut effectuer des *opérations logiques* avec une
valeur de _type booléen_.


[source%interactive,javascript]
.base/null.js
----
include::{sourceDir}/base/null.js[]
----

On utilise `null` pour signifier l'*absence de valeur*.


[source%interactive,javascript]
.base/undefined.js
----
include::{sourceDir}/base/undefined.js[]
----

La valeur `undefined` est utilisée pour signifier
qu'une *valeur est inconnue*.
Rares sont les cas où on choisira ce type de données par nous-même.

[NOTE]
.[RemarquePreTitre]#Documentation# MDN web docs
====
Pour en savoir plus sur les primitives, rendez-vous sur
la documentation en ligne et gratuite _MDN web docs_.

[URL]#https://developer.mozilla.org/fr/docs/Glossaire/Primitive#
====

Il existe trois autres types de données qui se basent sur ces types
dits _primitifs_.
Ces autres types sont destinés à ranger, classer et
à exprimer de nouvelles valeurs en fonction d'autres.


[source%interactive,javascript]
.base/array.js
----
include::{sourceDir}/base/array.js[]
----

Un tableau se déclare en encadrant une suite de valeurs entre crochets
(`[` et `]`).
Un tableau peut contenir n'importe quel type de valeurs,
et autant que nécessaire.
L'ordre des valeurs a généralement une importance.

On peut effectuer des **opérations de tri et de sélection** avec un
_tableau de valeurs_.

[source%interactive,javascript]
.base/object.js
----
include::{sourceDir}/base/object.js[lines=2..-1]
----

Un tableau se déclare en encadrant une suite de _paires de valeurs_
entre accolade (`{` et `}`).
Une _clé_ désigne une _valeur_, qui peut être de n'importe quel type.
Un objet a principe proche d'un _dictionnaire_ : on associe une valeur
à un intitulé, un label.
L'ordre des valeurs n'a généralement pas d'importance.

On peut effectuer des **opérations de sélection** avec un
_objet de valeurs_.


[source%interactive,javascript]
.base/function.js
----
include::{sourceDir}/base/function.js[lines=3..-1]
----

Une fonction accepte des _arguments_, de n'importe quel type et
autant que nécessaire.
Une déclaration peut être _déclarée_ et être _exécutée_ (dernière ligne de l'exemple précédent).

Une fonction _retourne_ un résultat explicite avec le
mot-clé `return`.
Dans le cas contraire, ECMAScript considère
que la valeur retournée équivaut implicitement à `undefined`.

On peut effectuer des **opérations de transformation** avec une fonction.

Les fonctions sont destinées à être _appelées_, pour effectuer
des traitements répétitifs.
Dès que l'on sent que l'on doit écrire deux fois la même chose,
on l'écrit dans une fonction et on l'appelle deux fois.

=== Les variables

Les *variables* servent à ranger des valeurs.
On peut ainsi les réutiliser plus tard, les transmettre et prendre
des décisions en fonction de ce qu'elles contiennent.

Les variables nous aident à _donner du sens_ à notre code,
à le rendre intelligible par d'autres personnes
ainsi qu'à nommer des choses comme on le ferait dans notre quotidien.

[source%interactive,javascript]
.base/variables.js
----
include::{sourceDir}/base/variables.js[lines=3..-1]
----

À votre avis, combien vaut le prix du livre calculé dans
l'exemple précédent ?
Il suffirait de suivre le chemin que prend la nouvelle valeur
rangée dans la clé `price` de l'objet `book`, calculée par la fonction
`double` à qui on passe la valeur contenue dans la variable `base_price`.

Le mot-clé `const` nous a servi à _déclarer_ des variables.
On ne peut étiqueter une variable avec le même nom qu'une seule fois.
L'exemple suivant générera une erreur si on déclare deux fois la même variable avec `const` :

[source%interactive,javascript]
.variables/const.js
----
include::{sourceDir}/variables/const.js[lines=3..-1]
----

=== Instructions

Des _instructions_ nous servent à suivre, éviter ou répéter
des chemins dans notre code.

L'instruction `if` nous aide à exécuter du code qui remplit une condition.
Cette condition peut être une _valeur_ ou une _expression_.
Cette expression est interprétée pour savoir à quel _booléen_
elle correspond.

[source%interactive,javascript]
.instructions/if.js
----
include::{sourceDir}/instructions/if.js[lines=3..-1]
----

L'exemple précédent vérifie que les deux conditions sont remplies
(opérateur `&&`) pour afficher un message en conséquent.

On notera au passage que `book.title` n'est pas un booléen.
ECMAScript regarde dans ce cas que la chaîne de caractères
contient _au moins 1 caractère_.
On expliquera ce comportement plus en détail dans la section <<#boolean,manipuler des booléens>>.

L'instruction `if` peut être complétée avec l'instruction `else`
pour éxécuter du code qui répondrait au cas contraire.
On peut imbriquer plusieurs `else if` à la suite.

[source%interactive,javascript]
.instructions/else-if.js
----
include::{sourceDir}/instructions/else-if.js[lines=3..-1]
----

Notre exemple n'empruntera qu'un seul des chemins mais on peut
constater qu'on pourrait en emprunter un autre
en modifiant la valeur des clés `title` et `published`.

[[scope]]
=== Portée (_scope_)

La _portée_ est un concept très présent dans ECMAScript.
On y fait souvent référence en parlant de _variable globale_ et
de _variable locale_.
On peut y sentir une notion de frontière d'accès à la valeur
d'une variable.


[source%interactive,javascript]
.scopes/local.js
----
include::{sourceDir}/scopes/local.js[lines=3..-1]
----

Ce que nous dit l'exemple précédent,
c'est que la variable `secret` de type fonction a une portée globale
au script en question.
Qu'en-est-il de la variable `mot` encapsulée dans cette fonction ?

On pourrait le résumer ainsi :
la variable `mot` est définie dans la fonction `secret`
et n'est donc pas accessible en dehors de la portée de la fonction.
À l'inverse, ce qui est défini _en dehors_ d'une fonction
est accessible _à l'intérieur_ d'une fonction.

La portée de la variable `mot` est locale à la fonction `secret`.

[source%interactive,javascript]
.scopes/global.js
----
include::{sourceDir}/scopes/global.js[lines=3..-1]
----

Dans le précédent exemple, nous illustrons la portée globale de la variable
`year`.
Elle est définie un cran au-dessus des fonctions `next` et `nextYear`.
On peut y accéder, comme en atteste le code de la fonction `nextYear`.

À l'inverse, la variable `value` a une portée locale
— elle est passée en paramètre de la fonction `next`.
ECMAScript génèrera une erreur si on tente
d'y accéder en dehors de sa portée.

*La portée est délimitée par les fonctions*.
En l'absence de fonction, la portée maximale est celle du module (script) dans lequel la variable est déclarée.

Il existe un deuxième type de portée : la _portée lexicale_.
L'exemple suivant servira à illustrer la nature de sa délimitation.

[source%interactive,javascript]
.scopes/lexical.js
----
include::{sourceDir}/scopes/lexical.js[lines=3..-1]
----

Le mot-clé `const` crée une variable certes,
mais une variable dont la portée est _lexicale_.
*La portée lexicale est délimitée par le bloc d'instructions*
dans lequel la variable est déclarée.

Ainsi la variable `price` n'existe que dans le cadre du bloc `if`.


L'utilisation de la portée lexicale sert déclarer
des variables sans _polluer_ le reste du script,
pour que son existence soit oubliée aussitôt le bloc exécuté.

[[string]]
== Manipuler du texte

Il est commun d'avoir à manipuler des chaînes de caractères.
Pour stocker des URLs, des titres, des identifiants,
des tweets voire même des textes longs.

[source%interactive,javascript]
.string/base.js
----
include::{sourceDir}/string/base.js[]
----
<1> Utilisation de guillemets simples (`\n` permet de revenir à la ligne) ;
<2> Utilisation de guillemets doubles — évite d'échaper le guillemet simple ;
<3> Utilisation de guillemets obliques — autorise le multi-ligne.

On peut utiliser n'importe quel caractère : lettres, chiffres,
caractères accentués, émojis et même des sinogrammes ou des kanjis.
Autrement dit, il n'y a pas de limite.
Les environnements d'exécution se représente les caractères au format
UTF-16 (tables de stockage Unicode sur 16 bits de données).

Il est fréquent d'avoir à _concaténer_ des chaînes de caractères,
ou à les composer à partir d'une autre variable.

[source%interactive,javascript]
.string/concat.js
----
include::{sourceDir}/string/concat.js[]
----

Toute chaîne de caractères offre un ensemble
d'_attributs_ (`.quelque-chose`)
et de _méthodes_ (`.autre-chose()`) pour en savoir plus
sur la chaine mais aussi pour la manipuler.

Par exemple, on peut connaître la longueur d'une chaîne via son attribut `length`.

[source%interactive,javascript]
.string/length.js
----
include::{sourceDir}/string/length.js[]
----
<1> Affiche `14` ;
<2> Affiche `0`.

On peut aussi accéder à un caractère spécifique en utilisant
la chaîne comme un tableau, ou en utilisant une méthode dédiée :

[source%interactive,javascript]
.string/char-at.js
----
include::{sourceDir}/string/char-at.js[]
----
<1> Affiche `N` ;
<2> Affiche `o`.

Deux autres fonctions transforment
un texte en lettres minuscules et majuscules :

[source%interactive,javascript]
.string/lower-upper-case.js
----
include::{sourceDir}/string/lower-upper-case.js[]
----
<1> Affiche `node.js` ;
<2> Affiche `NODE.JS`.

D'autres fonctions nettoient ou complètent les espaces autour,
au début ou à la fin d'une chaîne de caractères :

[source%interactive,javascript]
.string/trim-pad.js
----
include::{sourceDir}/string/trim-pad.js[]
----
<1> Affiche `Node.js` ;
<2> Affiche `Node.js{nbsp}{nbsp}` ;
<3> Affiche `{nbsp}{nbsp}Node.js` ;
<4> Affiche `BARCGB22XXX` ;

Dans cet exemple, la méthode `padEnd` complète jusqu'à `11` caractères,
avec le caractère `X`.
La méthode `padStart` fait la même chose mais avec le début de la chaîne.

`indexOf` retourne la position de la _première occurence_
dans une chaîne.
Si la valeur n'est pas trouvée, elle renvoie la valeur `-1`.
À l'inverse, `lastIndexOf` retournera la dernière occurence trouvée :

[source%interactive,javascript]
.string/index-of.js
----
include::{sourceDir}/string/index-of.js[]
----
<1> Retourne `4` ;
<2> Retourne `-1` — aucune occurrence n'ayant été trouvée ;
<3> Retourne `5` — première occurence de la lettre `a` ;
<4> Retourne `7` — dernière occurence de la lettre `a`.

[[regexp]]
=== Expressions régulières (_RegExp_)

Si `indexOf` et `lastIndexOf` identifient des caractères exacts,
comment faire lorsque l'on souhaite chercher de manière approximative,
plusieurs fois et selon certaines conditions ?

Les _expressions régulières_ (_RegExp_, pour _Regular Expressions_)
entrent en jeu dans ces cas plus avancés.
Leur mécanisme décrit des _motifs_ à identifier.
Plusieurs _méthodes_ servent ensuite à tester, identifier et remplacer
ces motifs au sein d'une chaîne de caractères.

[TIP]
.[RemarquePreTitre]#Anecdote# RegExp et Perl
====
La syntaxe d'expressions régulières est inspirée de celle du langage
de programmation _Perl_ ([URL]#https://www.perl.org#) dans sa version 5.
====

Une expression régulière est décrite le plus souvent en tant que motif
encadré par les caractères `/` (_slash_), suffixé d'_options_ exprimées sous forme de lettres :

[source%interactive,javascript]
.regexp/base.js
----
include::{sourceDir}/regexp/base.js[]
----

Cet exemple utilise l'option `i` mais il en existe plusieurs :

[horizontal]
insensible à la casse (`i`)::
  On souhaite identifier du contenu, peu importe s'il est en majuscules ou non ;
multi-ligne (`m`)::
  La recherche s'effectue sur _toutes_ les lignes ;
global (`g`)::
  La recherche identifie _tous_ les résultats
  — au lieu d'un seul et le premier ;
unicode (`u`)::
  À utiliser si le motif de recherche exprime des séquences de caractères
  Unicode sous la forme `\u{....}` (voir les _classes de caractères_ ci-après).

Illustrons leur utilisation en _identifiant du texte_ répondant (`match`)
à une _expression régulière_ (`/.../`) :

[source%interactive,javascript]
.regexp/flags.js
----
include::{sourceDir}/regexp/flags.js[]
----
<1> identifie et affiche `Node`, l'occurence contenue dans le mot `Node.js` ;
<2> affiche 2 fois `ode` — les occurences contenues dans le mot `Node.js` et `Anode` ;
<3> affiche `Node` et `node` en combinant les deux options `i` et `g` — , les occurences contenues dans le mot `Node.js` et `Anode`.

Des éléments de syntaxe complètent les options pour
*identifier des motifs* au sein de chaînes de caractères :

ensemble de caractères (entre `[` et `]`)::
  Liste l'ensemble des caractères recherchés.
  Le caractère `-` correspond à une plage de caractère. +
  Exemple `[a-d]` correspond à `[abcd]`, donc _a_ ou _b_ ou _c_ ou _d_) ;
nombre de caractères (entre `{` et `}`)::
  Répète un caractère ou ensemble de caractères,
  _exactement_ (`{2}` — exactement 2)
  _au moins_ (`{2,}` — au moins 2)
  ou _entre_ (`{1,2}` — entre 1 et 2 fois) ;
nombre de caractères (`?`, `+` et `*`)::
  Version raccourcie du nombre de caractères pour des besoins usuels :
  _0 ou 1 caractères_ avec `?`,
  _1 caractère et plus_ avec `+` et
  _0 caractères et plus_ avec `*`.

[source%interactive,javascript]
.regexp/syntax.js
----
include::{sourceDir}/regexp/syntax.js[]
----
<1> Affiche `["75"]` — les 2 premiers caractères numériques de la chaîne ;
<2> Affiche `["75015"]` – les 5 premiers caractères numériques (satisfait la condition `5` de _entre 2 et 5_ de `{2,5}`) ;
<3> Affiche `["75015 Paris"]` ;
<4> Affiche `["75015 Paris"]` — l'option `i` nous permet de nous passer de l'ensemble `A-Z` ;
<5> Affiche `["92410 Ville"]` — capture les caractères jusqu'à ce que la condition ne soit plus remplie en rencontrant le _trait d'union_ (`-`) ;
<6> Affiche `["92410 Ville-d'Avray"]` ;

D'autres opérateurs *délimitent notre recherche* :

début et fin de chaîne (`^` et `$`)::
  Symbolise le début (`^`) ou la fin (`$`) d'une chaîne de caractères. +
  Quand l'option multi-ligne (`m`) est utilisée, les notions de _début_
  et de _fin_ s'appliquent au niveau de la _ligne_ ;
limite de mot (`\b`)::
  Symbolise tout caractère ne faisant pas partie d'un mot, y compris le début ou la fin d'une chaîne ;
ou (`|`)::
  Sépare deux choix l'un de l'autre.
  Exemple : `/noir|blanc/` ;
groupe de capture (entre `(` et `)`)::
  Délimite un groupe de caractères.
  Les groupes peuvent par la suite être _identifiés_ et _remplacés_. +
  On notera également que l'emploi des _groupes_ change
  la structure des résultats en un tableau de plusieurs éléments.
  Ce tableau a la forme `["chaine identifiée", "groupe 1", "groupe 2", ...]`.


[source%interactive,javascript]
.regexp/limits.js
----
include::{sourceDir}/regexp/limits.js[]
----
<1> Affiche `["75015 Paris"]` ;
<2> Affiche `["75015 Paris", "75015"]`
— le premier élément correspond à la chaîne identifiée tandis que
le second élément correspond au _premier_ groupe de capture ;
<3> Affiche `["33900", "33900"]`
– l'option multi-ligne itère de ligne en ligne jusqu'à trouver un motif ;
<4> Affiche `["33900", "33074", "33700"]`
— l'option multi-ligne globale retourne tous les groupes de capture.

On notera qu'il faut faire attention à ce que l'on regarde dans les résultats :
le format de résultat varie selon qu'on utilise ou non des groupes de capture,
selon qu'on utilise l'option globale ou non,
selon qu'on utilise l'option multi-ligne ou non…

Des classes de caractère servent de raccourcis pour désigner
plusieurs caractères à la fois :

tout caractère (`.`)::
  Équivalent à _tout caractère_… sauf le saut de ligne ;
caractère de mot (`\w`)::
  Équivalent à tout caractère pouvant composer un mot… anglais.
  Les caractères accentués ne comptent pas malheureusement icon:wink[].
  Identique à `[A-Za-z0-9_]`
caractère numérique (`\d`)::
  Équivalent à tout caractère numérique.
  Identique à `[0-9]`.
caractère d'espacement (`\s`)::
  Équivalent à tout caractère d'espacement
  (espace, tabulation, retour chariot etc.) ;
caractère unicode (`\u{....}`)::
  Doit être combiné avec l'option `u` (`/.../u`).
  Exemple : ♥︎ -> `\u{2665}`

Les alternatives de classes en majuscules sont des _négations_.
`\W` pour "tout sauf un caractère de mot", `\S` pour "tout sauf un caractère d'espacement", etc.

[source%interactive,javascript,subs="attributes"]
.regexp/classes.js
----
include::{sourceDir}/regexp/classes.js[]
----
<1> Affiche `["♥ RegExp", "RegExp"]`
— et s'arrête là car l'espace suivant n'est pas un caractère de mot ;
<2> Affiche `"I ♥ {docyear}"`
— on a extrait le début de la phrase et l'année placée en fin de chaîne.

mdn::Web/JavaScript/Reference/Objets_globaux/RegExp[expressions régulières]


La méthode `test` est pratique si la seule qui vous intéresse
est de tester si une chaîne correspond à un motif :

[source%interactive,javascript]
.regexp/test.js
----
include::{sourceDir}/regexp/test.js[]
----

Enfin, la méthode `replace` est très utile pour transformer des chaînes de
caractères, surtout en combinaison avec les groupes de capture :

[source%interactive,javascript]
.regexp/replace.js
----
include::{sourceDir}/regexp/replace.js[]
----
<1> Affiche `"I love JavaScript"`
— si le premier argument de `replace` est une chaîne,
elle est convertie automatiquement en expression régulière ;
<2> Affiche `"I ♥ PHP"` ;
<3> Affiche `JavaScript ♥ me"`
— les symboles `$<numéro>` représentent les groupes de capture ;
on peut les placer dans l'ordre de notre choix .

D'ailleurs le second argument accepte une <<functions,fonction>>
pour procéder à des remplacements dynamiques :

[source%interactive,javascript]
.regexp/replace-function.js
----
include::{sourceDir}/regexp/replace-function.js[]
----
<1> Affiche `"I ♥ JAVASCRIPT"` — le dernier mot est transformé en majuscules.


[[boolean]]
== Manipuler des booléens

Un booléen est une donnée de type logique qui peut être _vraie_ ou _fausse_ en prenant respectivement la valeur `true` ou `false`.
C'est un type de choix pour effectuer des _assertions_ et vérifier des _conditions_.

[source%interactive,javascript]
.boolean/base.js
----
include::{sourceDir}/boolean/base.js[]
----
<1> Affiche `3` ;
<2> Affiche `true` — la condition est vérifiée (3 équivaut strictement à 3) ;
<3> Affiche `true` — c'est la valeur de la variable `check` suite à son assignation lors de la ligne précédente ;
<4> Affiche `true` — la variable `check` équivaut strictement à `true`.

Une donnée d'un autre type peut être convertie en booléen.
La logique qui déterminera si la conversion retournera `true` ou `false`
est la suivante :

[horizontal]
`true`::
  Toute valeur non-nulle.
`false`::
  Toute valeur nulle (`null`, `0`, `NaN`), vide (`''`)
  ou indéfinie (`undefined`).

[source%interactive,javascript]
.boolean/convert.js
----
include::{sourceDir}/boolean/convert.js[]
----
<1> Affiche `false` — il s'agit d'une _chaîne vide_ ;
<2> Affiche `true` - il s'agit d'une valeur _non-nulle_ ;
<3> Affiche `true` — le tableau est vide mais l'objet en lui-même _vaut_ quelque chose : un tableau.

[[number]]
== Manipuler des nombres (_Number_, _Math_)

ECMAScript ne fait pas de distinction entre des nombres entiers et des
nombres contenant des décimales : ce sont des _nombres_ un point c'est tout.

[source%interactive,javascript]
.number/base.js
----
include::{sourceDir}/number/base.js[]
----
<1> Affiche `true` — les deux valeurs sont strictement équivalentes ;
<2> Affiche `false` — un élément entre guillemets est une chaîne de caractère.

Les nombres sont représentés par défaut en _base 10_.
La plage de nombre utilisable démarre à _moins l'infini_ et va jusqu'à _plus l'infini_.
Des constantes définies par ECMAScript contiennent les valeurs minimales et
maximales que l'on peut représenter dans un programme :

[source%interactive,javascript]
.number/constants.js
----
include::{sourceDir}/number/constants.js[]
----

Il est aussi possible de compter dans d'autres bases comme la _base 16_.
C'est à dire une représentation hexadécimale de 0 à 16 exprimée de 0 à F
— A vaut 10 (car juste après 9), B vaut 11 etc.
Leur notation se fait en préfixant la valeur par `0x` :

[source%interactive,javascript]
.number/hexa.js
----
include::{sourceDir}/number/hexa.js[]
----
<1> Affiche `0` ;
<2> Affiche `10` — car `A` en hexadécimal vaut 10 en décimal ;
<3> Affiche `160` — pour `10 x 16` (une dizaine vaut 16) ;
<4> Affiche `2560` — pour `10 x 16 x 16` (une centaine vaut 16x16).


[NOTE]
.[RemarquePreTitre]#Rumeur# JavaScript est nul en virgule flottante !
====
ECMAScript est souvent décrié par son incapacité à gérer les opérations
mathématiques avec précision.

[source%interactive,javascript]
----
0.2 + 0.6
----

ECMAScript respecte le standard _IEEE 754_ de gestion de nombres à virgule flottante sur 64 bits de données.
Qui d'autre l'utilise ?
D'autres langages "inconnus" comme Python, PHP et Ruby, entre autres.

Pour en savoir plus : [URL]#https://fr.wikipedia.org/wiki/IEEE_754#.
====

=== Opérations mathématiques

Les nombres s'utilisent pour effectuer des opérations mathématiques.
Chaque opération est dotée d'un symbole :

[horizontal]
addition::
  `+`
soustraction::
  `-`
multiplication::
  `*`
division::
  `/`
modulo (reste de division)::
  `%`
exposant (puissance)::
  `**`

[source%interactive,javascript]
.number/operations.js
----
include::{sourceDir}/number/operations.js[]
----
<1> Affiche `6` ;
<1> Affiche `-2` ;
<1> Affiche `8` ;
<1> Affiche `0.5` ;
<1> Affiche `2` ;
<1> Affiche `16`.

[CAUTION]
.[RemarquePreTitre]#Attention# Opérations exotiques
====
Est-ce que vous avez déjà tenté d'additionner un nombre avec un tableau ?
Pas forcément… mais ECMAScript ne vous en empêchera pas.

[source%interactive,javascript]
.number/operations-types.js
----
include::{sourceDir}/number/operations-types.js[]
----
<1> La chaîne `'1'` sera convertie en nombre (voir section ci-après)…
donc _ça marche_ !
<2> On nous a toujours interdit la division par zéro ?
En vrai on crée l'_infini_ ;
<3> Seule cette opération retournera… autre chose qu'un nombre.
Rendez-vous à la section suivante pour se prémunir
des nombres qui n'en sont pas.

Moralité : *s'assurer de ne manipuler que des nombres*.
====

=== Les nombres qui n'en sont pas (_NaN_)

Certaines opérations n'aboutiront pas… sans afficher d'erreur pour autant.
Dans ce cas, le résultat de l'opération vaudra… `NaN`.
Pour _not a number_ (littéralement : "n'est pas un nombre").

[source%interactive,javascript]
.number/nan.js
----
include::{sourceDir}/number/nan.js[]
----

La fonction `Number.isNaN` nous aidera à vérifier si la valeur d'une variable
ou le résultat d'une opération est un `NaN` ou non.
Cette fonction retourne un <<boolean,booléen>>.

[source%interactive,javascript]
.number/is-nan.js
----
include::{sourceDir}/number/is-nan.js[]
----

[WARNING]
.[RemarquePreTitre]#Assertion# NaN n'est pas un nombre… vraiment ?
====
Il faut se méfier de `NaN` comme de la peste.
Si on vérifie seulement le type de valeur pour s'assurer que tout va bien,
on ne se rendra pas compte que `NaN` est considéré… comme un nombre :

[source%interactive,javascript]
.number/nan-number.js
----
include::{sourceDir}/number/nan-number.js[]
----

Il vaudra mieux s'assurer qu'une variable est
un nombre _et_ n'est pas un `NaN` :

[source%interactive,javascript]
.number/is-not-a-nan.js
----
include::{sourceDir}/number/is-not-a-nan.js[]
----
====

=== Convertir en nombre

Les lignes qui précédent l'évoquent un peu : on peut passer d'autres types
de données à des nombres.
Idéalement, on voudra transformer explicitement quelque chose en un nombre.

Pour cela nous avons deux fonctions à disposition :

[horizontal]
`parseInt`::
  Essaie d'interprêter un nombre entier ;
`parseFloat`::
  Essaie d'interprêter un nombre à virgule.
  La fonction s'arrête dès qu'elle n'a plus affaire à un chiffre.

[source%interactive,javascript]
.number/parse.js
----
include::{sourceDir}/number/parse.js[]
----
<1> Affiche `3` ;
<2> Affiche `3.141592653589793` ;
<3> Affiche `14` — ça ne change rien pour `parseInt` ;
<4> Affiche `14.1` — la fonction s'arrête à la décimale précédant une lettre.

`parseInt` a cette particularité que l'on peut choisir la base
de la conversion avec le second argument de la fonction :

[source%interactive,javascript]
.number/parse-int.js
----
include::{sourceDir}/number/parse-int.js[]
----
<1> Affiche `16` ;
<2> Affiche `10` — `A` étant juste après `10` en hexadécimal ;
<3> Affiche `2560` — aurait pu s'écrire `0xF00`
(cf. le <<number,début de cette même section>>, à propos des bases).

=== Formatter et arrondir des nombres

Si l'envie vous prenait de vouloir arrondir des nombres, il existe
quelques fonctions pour nous aider.

[horizontal]
`Math.round`::
  Arrondit à l'entier le plus proche ;
`Math.ceil`::
  Arrondit à l'entier supérieur du nombre donné ;
`Math.floor`::
  Arrondit à l'entier inférieur du nombre donné.

Math.ceil, Math.floor
[source%interactive,javascript]
.number/round.js
----
include::{sourceDir}/number/round.js[]
----
<1> Affiche `3` — l'entier le plus proche est 3 ;
<1> Affiche `4` — l'entier le plus est 4 ;
<1> Affiche `4` — idem ;
<2> Affiche `4` ;
<3> Affiche `3`.

Enfin, on peut préserver le formattage du nombre de décimales
après la virgules… en transformant le nombre _en chaîne de caractères_
grâce à la méthode `toFixed` :

[source%interactive,javascript]
.number/to-fixed.js
----
include::{sourceDir}/number/to-fixed.js[]
----
<1> Affiche `'10.01'` ;
<2> Affiche `'10'`.

[[functions]]
== Manipuler des fonctions

Une fonction est un mécanisme pour *rendre du code réutilisable*.
Une fonction _retourne_ un résultat.
À l'aide de _paramètres_, on peut faire varier ce résultat.

Cela se passe en deux temps :

. la _création_ de la fonction ;
. l'_exécution_ de la fonction.

ECMAScript fournit tout un ensemble de fonctions (`console.log`, etc).
Node ajoute ses propres fonctions (comme `require`).
Nous pouvons également créer nos propres fonctions, spécifiques à nos besoins.

[source%interactive,javascript]
.functions/base.js
----
include::{sourceDir}/functions/base.js[]
----
<1> Affiche `[Function: hello]` — il s'agit de la fonction en tant que telle ;
<2> Affiche `"Hello World"`
— il s'agit de l'exécution de la fonction, de l'obtention de son résultat ;
<3> Affiche un nombre aléatoire entre 0 et 100
— cette fonction est invoquée sans paramètre.

L'exemple précédent nous indique qu'une fonction se découpe en 3 parties :

les *arguments*::
  C'est la partie à gauche de la flèche (`=>`).
  Les arguments sont séparés par des virgules (`(argument1, argument2, etc.)`) ;
le *corps*::
  C'est la partie entre accolades (`{ ... }`).
  Quand la fonction est sur une ligne,
  le résultat de l'opération est _implicitement retourné_.
  On peut dans ce cas se passer du mot-clé `return` ;
la *valeur de retour*::
  C'est la valeur renvoyée en dehors de la fonction.
  La valeur de retour est définie à l'aide du mot-clé `return`.
  La valeur `undefined` est retournée de manière implicite
  lorsque le mot-clé `return` est absent.

[TIP]
.[RemarquePreTitre]#Rappelle-toi# Variables et portée
====
Le corps d'une fonction constitute une _portée_ : toute variable définie
dans le corps d'une fonction est invisible en dehors.

On en parle plus en détails dans la <<scope,section portée>>
en début de section.
====

[[anonymous-function]]
=== Les fonctions anonymes

Les fonctions anonymes sont employées en *arguments d'autres fonctions*.
On les dit _anonymes_ car elles ne sont pas consignées dans des _variables_.
Il est fréquent de les utiliser pour _itérer_ sur des tableaux,
lors d'événements ou dans des <<promise,promesses>>.

C'est une manière élégante d'encapsuler du code à exécuter plus tard.

[source%interactive,javascript]
.functions/anonymous.js
----
include::{sourceDir}/functions/anonymous.js[]
----
<1> Affiche `"Deux secondes plus tard"` deux secondes après le début du script ;
<2> Affiche `"Le processus se termine"` quand… le processus se termine
— une fois que toutes les actions en attente ont été exécutées.

[[rest-parameters]]
=== Paramètres du reste (_rest parameters_)

Les _paramètres du reste_ collecte un nombre indéfini de paramètres.
Les paramètres sont *regroupés dans un même <<array,tableau>>* (voir ci-après).

[source%interactive,javascript]
.functions/rest.js
----
include::{sourceDir}/functions/rest.js[]
----
<1> Affiche `"On a compté 3 patates."`.

[[callback]]
=== Les fonctions de _callback_

Quand une fonction est passée en argument d'une autre fonction,
on appelle cela un _callback_.
On l'appelle plus tard (_to call back_) que le moment où elle est définie.
La fonction peut recevoir des paramètres qui aident à reconstruire un contexte
_au moment_ de son exécution.

[source%interactive,javascript]
.functions/callback.js
----
include::{sourceDir}/functions/callback.js[]
----
<1> Le troisième argument (et les suivants) de `setTimeout`
sont transmis en paramètre de la fonction de _callback_ ;
<2> Cette fonction sera invoquée une seconde après le début du script,
et recevra la date du moment en paramètre ;
<3> Affiche l'année de la date passée en argument
— l'année en cours dans cet exemple.

[[array]]
== Manipuler des collections

L'opérateur `typeof` ne permet pas d'identifier un tableau. Il faut pour cela privilégier la méthode `isArray` :

[source%interactive,javascript]
----
typeof [];        // <1>
Array.isArray([]);// <2>
----
<1> Retourne `'object'` ;
<2> Retourne `true`.

Il est possible de connaître la longueur d'un tableau en utilisant la propriété `length` :

[source%interactive,javascript]
----
[1, 2, 3].length; // <1>
----
<1> Retourne `3`.

La méthode `join` permet de concaténer tous les éléments d'un tableau avec le séparateur de votre choix :

[source%interactive,javascript]
----
[1, 2, 3].join(', ') + '… soleil';  // <1>
----
<1> Retourne `'1, 2, 3… soleil'`.

À l'inverse, la méthode `from` prend en charge la création de tableau à partir d'_itérables_ ou de structures similaires à des tableaux, comme `arguments` ou `NodeList` (dans un navigateur).

[source%interactive,javascript]
.array/from.js
----
include::{sourceDir}/array/from.js[]
----
<1> Retourne `[ 'c', 'a', 'm', 'e', 'm', 'b', 'e', 'r', 't' ]` ;
<2> Retourne `[ 1, 'b', 3, 'd' ]` ;
<3> Retourne `[ 1, 'b', 3, 'd' ]`.

En complément, la méthode `concat` permet de concaténer d'autres éléments :

[source%interactive,javascript]
----
include::{sourceDir}/array/concat.js[]
----
<1> Retourne `[ 1, 2, 3 ]` ;
<2> Retourne `[ 1, 2, 3, 4 ]` ;
<3> Retourne `[ 1, 2, 3, 4, 4, 5 ]` — cf. <<map-set,Map et Set>>.

La fonction de tri via la méthode `sort` se base sur des comparaisons positives, négatives ou neutres pour retourner un nouveau tableau, réindexé :

[source%interactive,javascript]
----
[1, 3, 2].sort((a, b) => a - b);  // <1>
[1, 3, 2].sort((a, b) => b - a);  // <2>

['A', 'b', 'c', 'a'].sort((a, b) => a.localeCompare(b))); // <3>
----
<1> Retourne `[1, 2, 3]` ;
<2> Retourne `[3, 2, 1]` ;
<3> Retourne `['a', 'A', 'b', 'c']`.

Les méthodes suivantes sont des nouveautés d'ECMAScript 5.
Elles facilitent énormément les itérations sur les tableaux tout en ajoutant une orientation fonctionnelle, utile pour la lisibilité du code.

La méthode `map` permet de retourner un nouveau tableau avec des valeurs modifiées :

[source%interactive,javascript]
.array/map.js
----
include::{sourceDir}/array/map.js[]
----
<1> Retourne `['A', 'B', 'C']`.

La méthode `filter` quant à elle retourne un nouveau tableau ne contenant que les éléments retournant un <<boolean,booléen _truthy_>> :

[source%interactive,javascript]
.array/filter.js
----
include::{sourceDir}/array/filter.js[]
----
<1> Retourne `[1, 0]` ;
<1> Retourne `[1, 'a', 120]`.

De manière similaire, les méthodes `some` et `every` retournent un booléen si _au moins une itération_ et _toutes les itérations_ ont renvoyé une _valeur positive_ :

[source%interactive,javascript]
.array/some.js
----
include::{sourceDir}/array/some.js[]
----
<1> Renvoie `true` puisqu'au moins une valeur équivaut à `undefined` ;
<2> Renvoie `false` puisque toutes les valeurs n'équivalent pas à `undefined` ;
<3> Renvoie `true` puisque toutes les valeurs sont égales à `undefined`.

ECMAScript 2015 introduit les méthodes `find` et `findIndex`, respectivement pour retourner une valeur et son index selon une fonction prédicat :

[source%interactive,javascript]
.array/find.js
----
include::{sourceDir}/array/find.js[]
----
<1> Valeur que l'on recherche ;
<2> Affiche `stram` (valeur recherchée) ;
<3> Affiche `1` (index de la valeur recherchée).

La méthode `reduce` a un comportement similaire à `sort` mais fonctionne de manière accumulative :

[source%interactive,javascript]
.array/reduce.js
----
include::{sourceDir}/array/reduce.js[]
----
<1> Affiche `21` ;
<2> Affiche `[9, 12]`.

[TIP]
.[RemarquePreTitre]#FAQ# Tableau non contigu.
====
Il se peut que des valeurs soient manquantes dans un tableau.
On dit alors que les valeurs ne sont pas contiguës.

Cela affecte les fonctions itératives et peut se révéler problématique si vous cherchez à conserver cette absence de valeurs :

----
const a = [1,, 3, undefined, null];
const print = (value) => console.log(value);

a.length;         // <1>
a.forEach(print); // <2>
----
<1> Retourne `5` ;
<2> Affiche 4 valeurs : `1`, `3`, `undefined` puis `null`.
====

[[destructuring-arrays]]
=== Décomposition de collection

L'affectation par _décomposition_ (_destructuring_) est une manière élégante et intuitive de piocher dans un <<array,tableau>> ou dans un <<object,objet>>.
La décomposition n'altère pas le contenu des variables décomposées.

Les valeurs d'un tableau sont décomposées dans l'ordre tandis que l'opérateur _spread_ (`...`) permet d'assigner le _reste_ des valeurs dans une seule et même variable ou constante :

[source%interactive,javascript]
.destructuring-array.js
----
include::{sourceDir}/destructuring-array.js[]
----
<1> Décompose la première valeur du tableau et assigne _le reste_ dans une autre constante ;
<2> Affiche `Bordeaux` ;
<3> Affiche `[ 'Toulouse', 'Montpellier', 'Aix-en-Provence' ]` ;
<4> Affiche `[ 'Bordeaux', 'Toulouse', 'Montpellier', 'Aix-en-Provence' ]`.

Il est également possible de _sauter_ des valeurs en ne nommant pas _autant_ de variables ou de constantes lors de la décomposition :

[source%interactive,javascript]
.destructuring-spread.js
----
include::{sourceDir}/destructuring-spread.js[]
----
<1> Assigne la première valeur dans la constante `first`, saute la seconde et assigne le reste des valeurs dans `end` ;
<2> Affiche `un` ;
<3> Affiche `[ 'deux', 'trois', 'quatre' ]`.

[[object]]
== Manipuler des dictionnaires (_Object_)

Dans ECMAScript, tout est objet. C'est le _prototype_ qui détermine le comportement dudit objet.
Les objets peuvent être créés de manière littérale, avec la fonction `Object.create` ou via un constructeur. +
À la différence d'un `Array`, il est possible de nommer une clé par une chaîne de caractères – statique ou dynamique – ou avec un <<symbol,symbole>>.

[source%interactive,javascript]
.object.js
----
include::{sourceDir}/object.js[]
----
<1> Retourne `'lateral'` ;
<2> Retourne également `'lateral'` ;
<3> Retourne `true`, les deux objets étant la même instance ;
<4> Retourne `false`, les deux objets étant deux instances différentes.

L'opérateur `typeof` permet d'identifier la primitive d'une variable — au sens d'ECMAScript, pas au sens logique de votre application, c'est à dire le prototype d'un objet.

L'opérateur `instanceof` ou la méthode `getPrototypeOf` permettent justement de comparer les appartenances logiques.

[source%interactive,javascript]
.object-typeof-instanceof.js
----
include::{sourceDir}/object-typeof-instanceof.js[]
----
<1> Affiche `function` ;
<2> Affiche `object` ;
<3> Affiche `true` ;
<4> Affiche `[object Object]` ;
<5> Affiche `PseudoBookClass`.

`Object.keys` extrait les propriétés énumérables d'un objet, à la différence de `Object.getOwnPropertyNames()` :

[source%interactive,javascript]
.object-keys.js
----
include::{sourceDir}/object-keys.js[]
----
<1> Affiche `[ 'name', 'services' ]` ;
<2> Affiche `[ 'name', 'services', 'internal_code' ]`.

[[destructuring-objects]]
=== Décomposition d'objet


Le même mécanisme existe pour les <<object,objets>>, y compris dans des arguments de fonction :

[source%interactive,javascript]
.destructuring-object.js
----
include::{sourceDir}/destructuring-object.js[]
----
<1> Destructure la fonction `join` directement depuis le `require` de module ;
<2> Destructure la valeur `debug` du premier argument;
<3> Affiche `folder/filename.txt` – `folder\filename.txt` sous Windows ;
<4> Affiche `true` car la clé `debug` a été décomposée en `configDebug` ;
<5> Affiche `undefined` – cette valeur n'existe pas dans l'objet `config` ;
<6> Affiche `Demo` – cette valeur est complétée par défaut dans l'assignation ;
<7> Affiche `true`.

Comme indiqué en début de section, il est possible de nommer les clés de manière dynamique mais aussi d'utiliser une syntaxe raccourcie d'assignation de valeur :

[source%interactive,javascript]
.object-advanced.js
----
include::{sourceDir}/object-advanced.js[]
----
<1> Utilise la valeur d'une variable comme nom de clé ;
<2> Syntaxe alternative possible, utile lorsqu'un objet existe déjà ;
<3> Affiche `{ SNCF: { country: 'France' }, Reinfe: { country: 'Spain' } }` ;
<4> Utilise la syntaxe d'assignation raccourcie, donc assigne la valeur de `sncf` à la clé `sncf` — affiche `{ sncf: 'SNCF', foo: 'bar' }` ;
<5> _Idem_ mais sans la syntaxe d'assignation raccourcie.

[[object-assign]]
=== Étendre des objets

`Object.assign` étend des structures existantes et la définition de valeurs par défaut.
Les clés et valeurs sont copiées de gauche à droite avant d'être assignées dans le premier paramètre :

[source%interactive,javascript]
.object-assign.js
----
include::{sourceDir}/object-assign.js[]
----
<1> Les clés et valeurs de `DEFAULT` et celles de `userOptions` sont copiées dans un objet vide puis retournées dans `mergedOptions` ;
<2> Affiche `{ concurrency: 10, timeout: 'https', tags: [] }` ;
<3> Affiche `[ 'img', 'h1' ]` ;
<4> Affiche `[ 'url', 'env', 'tags' ]` — l'objet `testOptions` est donc modifié.

== Manipuler des dates

L'opérateur `typeof` ne permet pas d'identifier une date. Il convient d'utiliser `instanceof` :

[source%interactive,javascript]
----
typeof (new Date('2014-03-24'));  // <1>
(new Date('2014-03-24 13:37')) instanceof Date; // <2>
typeof Date.parse('2014-03-24 13:37');          // <3>
----
<1> Retourne `'object'` ;
<2> Retourne `true` ;
<3> Retourne `'number'`, car il s'agit d'une date exprimée en millisecondes depuis le 1er janvier 1970 (temps _EPOCH_).

Il également possible d'obtenir la date actuelle exprimée en millisecondes avec `Date.now` :

[source%interactive,javascript]
----
Date.parse(new Date()); // <1>
Date.now();             // <2>
----
<1> Retourne `1397381941000` ;
<2> Retourne `1397381941031`, équivalent à la syntaxe précédente donc, la précision à la milliseconde près en plus.


[[class]]
== Manipuler des classes d'objet (_Class_)

ECMAScript 2015 ajoute au langage des sucres syntaxiques facilitant la création et maintenance d'objets métier.
Nous bénéficions d'une véritable notion de constructeur, de méthodes statiques et même d'extension de prototype — on pourrait parler d'héritage mais nous n'avons pas envie d'aller dans cette direction, pas vrai ?

Tout ce que nous attachions auparavant à une _fonction_, nous nous référons désormais à une _classe_ à proprement parler. +
En voici un exemple de définition :


[source%interactive,javascript]
.class-view.js
----
include::{sourceDir}/class-view.js[]
----

La définition de la classe `View` comporte trois fonctions :

- `constructor` : le constructeur invoqué à chaque nouvelle instantiation via l'opérateur `new` ;
- `render` : une méthode partagée par toutes les instances de `View` — équivalent à `View.prototype.render = function () { ... }` ;
- `removeDuplicates` : une méthode statique, utilisable indépendamment des instances de `View` — équivalent à `View.removeDuplicates = () => ({ ... })`.

L'exemple suivant illustre le comportement de la classe `View` :

[source%interactive,javascript]
.class-constructor.js
----
include::{sourceDir}/class-constructor.js[]
----
<1> Affiche `object` ;
<2> Affiche `true` ;
<3> Affiche `{ blacklist: [ 'object', 'iframe' ] }` — l'objet de configuration initial ;
<4> Affiche `Node.js` ;
<5> Affiche une exception personnalisée.



[[object-getset]]
=== Accesseurs et mutateurs

`Object.defineProperty` permet de régler finement d'autres spécificités d'un objet, dont des *accesseurs* (_getters_) et des *mutateurs* (_setters_).
Ces attributs spéciaux nous autorisent la création de _propriétés calculées_, de _propriétés en lecture seule_ ou de _maitriser l'écriture d'une propriété_ :

[source%interactive,javascript]
.object-getters.js
----
include::{sourceDir}/object-getters.js[]
----
<1> Nous définissons de nouvelles propriétés pour l'objet `book` ;
<2> Définition d'un _mutateur_ pour la propriété `date_published` ;
<3> La valeur `date` est convertie en objet et stockée dans la propriété `_published_at` ;
<4> Définition d'un _accesseur_ pour la propriété `date_published` ;
<5> Appel du _mutateur_ qui, en interne, convertit la chaîne de caractères en objet `Date` ;
<6> Appel de l'_accesseur_ et affiche `true` car il s'agit bien d'une instance de `Date` ;
<7> Lance une exception car la chaîne assignée n'est pas une date valide.

Trois choses sont à souligner dans cet exemple.

Tout d'abord, notre définition de _mutateur_ ajoute de la sécurité.
Sa valeur est _garantie_ et nous savons que `book.date_published` sera systématiquement une date.

Inconvénient, nous n'avons d'autre choix que de stocker la date dans une autre propriété, ici `book.\_published_at`.
Et rien ne nous empêche de la modifier directement et d'invalider une partie de notre raisonnement… +
Il nous faudrait trouver un moyen de stocker la valeur du _mutateur_ et de l'_accesseur_ de manière _privée_.

Enfin, les propriétés sont assignées _uniquement_ à l'objet `book`. Si nous voulions les généraliser à plusieurs instances d'objets se ressemblant, nous les définirions alors dans une <<class,classe>>.

Nous pouvons définir des _accesseurs_ et des _mutateurs_ avec une notation raccourcie, ayant exactement le même effet.
Reprenons l'exemple précédent :

[source%interactive,javascript]
.object-getters-shorthand.js
----
include::{sourceDir}/object-getters-shorthand.js[]
----
<1> Définition _raccourcie_ du _mutateur_ pour la propriété `date_published` ;
<2> Définition _raccourcie_ de l'_accesseur_ pour la propriété `year_published` – notez qu'on ne définit pas de _mutateur_ pour cette même propriété ;
<3> Lance une _exception_ car la propriété `year_published` est définie en tant qu'_accesseur_ uniquement ; on ne peut donc pas lui _assigner_ de valeur.

L'exemple suivant illustre leur définition au sein d'une classe :

[source%interactive,javascript]
.class-accessors.js
----
include::{sourceDir}/class-accessors.js[]
----
<1> Retourne `'978'`;
<2> Retourne `'2212136401'` ;
<3> Retourne `'978-2212136401'`.

La logique des accesseurs est ainsi partagée entre _tous les objets_ étant des instances de `Book`.

[[class-inheritance]]
=== Héritage

L'exemple suivant illustre deux classes héritant de notre classe `View` :

[source%interactive,javascript]
.class-extends.js
----
include::{sourceDir}/class-extends.js[]
----
<1> Retourne une chaîne de HTML après avoir interpolé les variables avec leur valeur respective ;
<2> Retourne la chaîne de texte `# Node.js\n#{empty}#\#{empty}#\#{empty}#\#{empty}#{empty}#\n\nHello World!`.

`HTMLView` surcharge le constructeur tandis que `TextView` se contente du comportement par défaut défini par le constructeur de `View`.

L'appel à la fonction `super` revient à _appeler le constructeur de la classe que l'on étend_.
Ne pas l'appeler revient à ne pas exécuter le constructeur de la classe parent.

S'il est désormais plus sûr d'utiliser l'extension de chaîne prototypale, *il ne faut pas abandonner la composition* pour autant.

Il est en effet bien plus simple de réutiliser (et de tester) des fonctions agnostiques de contexte — agnostiques du `this` — que de maintenir de grosses classes héritant sur plusieurs niveaux.

[[error]]
=== Les objets d'erreur (_Error_)


[[promise]]
== Manipuler des promesses (_Promise_)

L'organisation du code autour des _callbacks_ est difficile et ce, que ce soit en terme de maintenance, de gestion des erreurs ou de propagation d'information.

Un motif a émergé en réponse à cette complexité grandissante : les *promesses*.
*Il s'agit d'une primitive à maitriser* et disponible _nativement_ à la fois dans Node et les navigateurs modernes.

Historiquement, de nombreuses librairies ont proposé leur propre implémentation de promesses mais avec le défaut de ne pas être interopérables entre elles.
La spécification _Promise/A+_ a émergé pour établir un standard de compatibilité.
ECMAScript 2015 introduit nativement cette API, la rendant alors disponible pour le web et pour Node, avec ou sans _polyfill_.

Les cas d'utilisation des promesses sont multiples :

- exécuter une continuité d'actions asynchrones ;
- paralléliser des actions asynchrones et exécuter des instructions lorsqu'une ou plusieurs de ces actions sont terminées ;
- simplifier la gestion des erreurs à n'importe quelle étape du processus asynchrone.

[TIP]
.[RemarquePreTitre]#Définition# Promesse
====
Une promesse est *un objet retourné immédiatement* et qui exécute une fonction de résolution *une seule et _unique_ fois dans le futur*.
Cette résolution peut être soit _positive_ soit _négative_.

C'est un peu comme envoyer un _courrier suivi_ :

- le bureau de poste vous remet une preuve de dépôt (la promesse) ;
- les services postaux acheminent l'accusé de réception lorsque le destinataire a reçu le courrier et signé l'avis de délivrance (_résolution positive_) ;
- les services postaux émettent un accusé de non-délivrance si le destinataire n'a pas signé ni récupéré son courrier dans un délai imparti (_résolution négative_).
====

Une `Promise` consiste à appeler un _constructeur_ implémentant le _pattern_ _Executor_.
Le constructeur transmet les fonctions d'exécution permettant de _résoudre_ la promesse, _positivement_ en appelant `resolve` ou _négativement_, en appelant `reject`. +
`resolve` et `reject` transmettent les valeurs passées en argument à vos _callbacks_ souscrivant respectivement à `then` et `catch`.

[source%interactive,javascript]
.promise.js
----
include::{sourceDir}/promise.js[]
----
<1> Affiche `un` car la promesse est résolue de manière asynchrone, donc après l'exécution de cette ligne synchrone ;
<2> Affiche `deux` ;
<3> Affiche `DEUX` car la promesse précédente résoud la valeur _DEUX_ ;
<4> Affiche `undefined` car la promesse précédent ne résoud _rien_.

L'exemple suivant illustre une encapsulation de la fonction `fs.readFile` de Node en tant que promesse :

[source%interactive,javascript]
.readfile.js
----
include::{sourceDir}/readfile.js[]
----
<1> La promesse englobe l'exécution asynchrone — toute exception levée revient à implicitement appeler `reject` ;
<2> Résout négativement la promesse en passant le contenu de la dite erreur ;
<3> Résout positivement la promesse — si le _parsing_ échoue, la promesse sera rejetée.

Une instance de `Promise` expose plusieurs méthodes pour propager le statut de son exécution.
Les plus couramment employées sont `then` et `catch`:

- `then(onSuccess[, onError])` : fonction acceptant un _callback_ de résolution et un _callback_ de rejet facultatif ;
- `catch(onError)` : fonction acceptant un _callback_ de rejet.

Illustrons désormais la consommation d'une promesse en se basant sur le code précédent :

[source%interactive,javascript]
.promise-readfile.js
----
include::{sourceDir}/promise-readfile.js[]
----
<1> Création d'une `Promise` ;
<2> Consommation du résultat et propagation d'une nouvelle promesse retournant le nombre de dépendances contenu dans le `package.json` de ce chapitre ;
<3> Consommation du nouveau résultat ;
<4> Cette fonction sera appelée si une erreur se déclenche en amont de la chaîne de promesses.

[[promise-all]]
=== Collection de promesses

`Promise.all` est une méthode statique de l'API _Promise_ qui retourne elle-même une promesse.
Elle sera résolue positivement lorsque toutes les promesses passées en argument seront résolues ou négativement dès que l'une d'entre elles échouera.

Reprenons le précédent exemple pour compter _en parallèle_ les dépendances de trois fichiers `package.json` :

[source%interactive,javascript]
.promise-all.js
----
include::{sourceDir}/promise-all.js[]
----
<1> On passe un tableau de promesses non-résolues à `Promise.all` ;
<2> Cette fonction est exécutée dès que le tableau est résolu, avec le contenu de chaque fichier – dont nous comptons un par un le nombre de dépendances ;
<3> Cette ligne ne change pas par rapport au précédent exemple — un bénéfice d'une bonne découpe de code.

Usez et abusez des promesses : elles sont un des meilleurs moyens à notre disposition pour *modulariser*, *linéariser* et *clarifier le sens* du flot de notre code.

Nous aborderons à nouveau les <<../appendix-b/index.adoc#promise,promesses en tant que _design pattern_>> dans l'annexe du même nom.

[TIP]
.[RemarquePreTitre]#Lien# Guide des promesses
====
Un guide _très_ complet — en anglais — est publié en libre consultation sur le site du W3C.
Un dépôt sur GitHub permet d'y contribuer.

- [URL]#https://www.w3.org/2001/tag/doc/promises-guide#
- [URL]#https://github.com/w3ctag/promises-guide#
====

[TIP]
.[RemarquePreTitre]#Documentation# Pour en savoir plus
====
La documentation complète de `Promise` est disponible en français sur la ressource communautaire MDN :

- [URL]#https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Promise#
====


[[json]]
== Manipuler des structures de données JSON

L'introduction du support natif du parsing JSON dans ECMAScript 5 a apporté un grand confort dans la consommation de données issues d'API.
La sécurité de cette consommation a été améliorée de par sa prise en charge par les développeurs de VM ECMAScript.

La fonction `JSON.parse` tente de convertir une chaîne de texte supposée au format JSON en un objet natif :

[source%interactive,javascript]
----
const jsonContent = '{ "ECMAScript": 5.1 }';

typeof jsonContent; <1>

const content = JSON.parse(jsonContent);
content.ECMAScript; <2>

try {
  JSON.parse('{ "ECMAScript": 5.1');
}
catch (err) {
  console.log(err.message); <3>
}
----
<1> Retourne `'string'` ;
<2> Retourne `5.1` ;
<3> Affiche `Unexpected end of input` car `JSON.parse` a lancé une exception `SyntaxError`.

À l'inverse, la fonction `JSON.stringify` convertit un objet natif en chaîne de caractères au format JSON :

[source%interactive,javascript]
----
JSON.stringify({ ECMAScript: 5.1 }); <1>
JSON.stringify({ ECMAScript: 5.1 }, null, 2); <2>
----
<1> Retourne `'{"ECMAScript":5.1}'` ;
<2> Retourne `'{\n{nbsp}{nbsp}"ECMAScript": 5.1\n}'`, le troisième argument formate proprement avec la taille d'indentation spécifiée, exprimée en nombre d'espaces par niveau de profondeur.

[TIP]
.[RemarquePreTitre]#URL# Spécification ECMAScript
====
L'ensemble de la spécification ECMAScript est disponible aux formats PDF et HTML.
Il s'agit d'une mine d'or pour comprendre les mécanismes internes du langage, les types et primitives à disposition.

- [URL]#https://www.ecma-international.org/ecma-262/5.1/#
====

== Usages avancés


=== Manipuler des dictionnaires avec garanties (_Map_, _WeakMap_, _Set_ et _WeakSet_)

Deux nouvelles interfaces d'itération sont disponibles depuis _ECMAScript 2015_ : _Map_ et _Set_.
Elles font penser respectivement à `Object` et `Array` mais diffèrent de ces primitives sur les points suivants :

- elles garantissent l'*unicité par référence* des valeurs ;
- elles garantissent l'*ordre* des valeurs ;
- elles exposent la *même interface* de navigation et de manipulation ;
- elles peuvent être créées à partir d'un __itérable__ ou d'un tableau (de valeurs ou de clés+valeurs).

[source%interactive,javascript]
.set.js
----
include::{sourceDir}/set.js[]
----
<1> Construit un `Set` depuis un `Array` ;
<2> Reconstruit un `Array` à partir des valeurs du `Set` et affiche `[ 11, 13 ]`;
<3> Ce tableau sera ajouté car s'il est identique au précédent, il s'agit d'un objet différent, donc d'une référence d'objet différente ;
<4> On peut ajouter un `Set` en tant que valeur de `Set` si on le souhaite ;
<5> À l'inverse du point 3, l'ajout multiple d'une référence à un même objet (ici, `primesArray`) ne fonctionnera pas ;
<6> Affiche `Set { 2, 3, [ 5, 7 ], [ 5, 7 ], Set { 11, 13 }, [ 11, 13 ] }` ;
<7> Utilise la <<destructuring,décomposition>> pour extraire les valeurs du `Set` et affiche `[ 2, 3, [ 5, 7 ], [ 5, 7 ], Set { 11, 13 }, [ 11, 13 ] ]`.

`Map` offre quelques avantages à l'utilisation d'un `Object` :

- les clés peuvent être de n'importe quel type (y compris une référence à un autre objet ou tableau ECMAScript) ;
- `.size` retourne le nombre de clés de la _Map_ ;
- l'itération est très simple avec `for..of`, `forEach` ou même en utilisant la <<destructuring,décomposition>>.


[source%interactive,javascript]
.map.js
----
include::{sourceDir}/map.js[]
----
<1> Assigne un objet en référence de `Map` vers un objet de type `Set` ;
<2> Parcourt chaque enregistrement de `Map` et en affiche sa clé et sa valeur ;
<3> _Ditto_ mais avec l'expression `for..of` ;
<4> Affiche `2` car notre `Map` comporte 2 enregistrements ;
<5> Affiche les enregistrements de la `Map` sous forme de paires `[clé, valeur]`;
<6> Affiche `{nbsp}` (_rien_) car la `Map` a été vidée à la ligne précédente.

Toutefois _Map_ et _Set_ ont quelques inconvénients :

- absence des méthodes de compréhension de tableau (`map`, `reduce` etc.) ;
- pas de conversion native en JSON.

À vous de choisir entre `Object` et `Map` ou entre `Array` et `Set` en fonction de la rigueur de vos besoins.

[TIP]
.[RemarquePreTitre]#Documentation# Pour en savoir plus
====
La documentation complète de `Map` et de `Set` est disponible en français sur la ressource communautaire MDN :

- [URL]#https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Map#
- [URL]#https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Set#
====

=== Littéraux de modèle avec étiquette (_tagged template literals_)

Les _template literals_ peuvent se préfixer d'un nom de fonction.
Ce mécanisme nommé _tagged template literals_ sert de filtre pour interpréter et interpoler le contenu de chaque _template_ (élément contenu dans `${}`). Vous pouvez écrire vos propres fonctions mais aussi utiliser des modules _npm_. +
L'exemple suivant illustre une sécurisation de contenu tiers à l'aide de la fonction `safeHtml` fournie par le module `common-tags` ([URL]#https://npmjs.com/common-tags#) :

[source%interactive,javascript]
.template/literal-tags.js
----
include::{sourceDir}/template/tagged-literals.js[]
----
<1> Affiche `<div class="user-content">\n<script>alert(document.cookie)</script>\n</div>` ;
<2> Affiche `<div class="user-content">\n\&lt;script\&gt;alert(document.cookie)\&lt;/script\&gt;\n</div>`.

[URL]#https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Litt%C3%A9raux_gabarits#


[[async-await]]
=== async/await

Nous avons beaucoup appris sur les différents moyens d'organiser notre code de manière asynchrone.
Peut-être avec une indigestion de `then()`. +
Les opérateurs `async` et `await` sont là pour respectivement :

. déclarer une fonction comme pouvant _être mise en pause_ ;
. mise en pause effectuée avec l'opérateur `await`, pause suivie jusqu'à ce qu'une… promesse retourne un résultat.

Une promesse placée derrière un `await` jettera une exception.
Cette exception est interceptable avec un bloc `try/catch`, comme du code synchrone.

Reprenons une nouvelle fois notre exemple précédent, en combinant la transformation en promesses et les opérateurs `async` et `await` :

[source%interactive,javascript]
.async-await.js
----
include::{sourceDir}/async-await.js[]
----
<1> Déclaration de la fonction `getAllDeps` en tant que fonction asynchrone ;
<2> On itère comme de manière synchrone, en demandant à l'interpréteur d'attendre que la promesse `readFilePromise` soit résolue ;
<3> Le contenu de `fileBuffer` est disponible à la ligne d'après, sans utiliser `readFilePromise.then()` ;
<4> La fonction `getAllDeps` retourne une promesse ;
<5> Résultat identique à celui calculé dans `promise-all.js`.

À travers cet exemple on comprend qu'une fonction `async` retourne en réalité une promesse.
Promesse résolue lorsque toutes ses conditions `await` sont elles aussi résolues séquentiellement.

L'inconvénient de notre exemple est que la lecture des fichiers ne se fait plus en _parallèle_ mais bel et bien de manière _séquentielle_.
En effet, notre code est mis en pause à chaque itération de boucle, lors de l'appel de `readFilePromise`.

== Conclusion

TBD.
