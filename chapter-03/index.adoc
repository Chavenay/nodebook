:chapterNumber: 3
:sourceDir: ./examples
:sourceSample: TODO.js
:nodeCurrentVersion: v8
:npmCurrentVersion: v5
:toc-title: Table des matières
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Jouer avec JavaScript

TBD.

====
.Sommaire
- TBD.
====

[abstract]
--
--

include::../resources/tip-versions.adoc[]
include::../resources/tip-examples.adoc[]

toc::[]

== Node, JavaScript et ECMAScript

Nous l'avons vu dans le premier chapitre, Node utilise JavaScript comme principal langage de développement.
Mais contrairement à Ruby, Python ou PHP dont le numéro de version annonce les fonctionnalités exploitables, qu'en est-il de Node et de JavaScript ?

Il faut se tourner du côté de _V8_ pour savoir ce que la machine virtuelle est capable de comprendre.
Et comme chaque version de Node est associée à une version spécifique de _V8_, il suffit d'aller regarder les notes de version de V8 pour l'apprendre.

De manière générale, _V8_ implémente les spécifications approuvées ou en passe d'être approuvées par le comité gérant l'évolution du langage JavaScript : le *TC39*.

Enfin si vous n'avez pas envie de retourner la moitié du web pour savoir si _V8_, donc Node, supporte telle ou telle fonctionnalité, partez du principe que *le JavaScript supporté par Chrome ou Opera correspond au JavaScript supporté par Node*.

[TIP]
.[RemarquePreTitre]#FAQ# JavaScript ou ECMAScript ?
====
On peut lire régulièrement les termes _JavaScript_ et _ECMAScript_ comme s'il s'agissait de la même chose, y compris dans cet ouvrage.
*JavaScript et ECMAScript sont la même chose*.

JavaScript a été inventé en 1995 par Brendan Eich alors qu'il était employé de la société _Netscape Communications_.
Microsoft lui emboîte le pas en incluant JavaScript dans son logiciel Internet Explorer, alors en version 3.
Pour des raisons de droits de marque, il y est dénommé _JScript_.

La spécification est ensuite validée par l'organisme _Ecma International_ en juin 1997 sous le nom d'_ECMAScript_, standard ECMA-262.

L'utilisation du terme _JavaScript_ est resté dans le vocabulaire courant. Mais c'est bien d'_ECMAScript_ dont on parle, vraiment.

Adobe Flash utilise un dérivé d'ECMAScript, ActionScript et bien des machines virtuelles sont capables d'interpréter partiellement ou intégralement ECMAScript : Rhino en Java, Konq, BESEN en Object Pascal ou encore Esprima en… ECMAScript.
====

La suite de l'ouvrage emploie principalement le terme _ECMAScript_.

=== Standard ECMA-262 Edition 5

ECMAScript a été standardisé dans sa version 5 en décembre 2009.
Il s'agit de la version d'ECMAScript supportée depuis les débuts de Node.
La révision 5.1 de juin 2011 est une correction mineure de la spécification.

Il s'agit d'une évolution majeure, dix ans après sa précédente édition, ECMAScript 3.

ECMAScript 5 introduit le mode strict limitant fortement les effets de bord indésirables, de nouvelles fonctionnalités pour `Object` et `Array`, le support natif de _JSON_ et `Function.prototype.bind`.

- [URL]#https://kangax.github.io/compat-table/es5/#
- [URL]#https://www.ecma-international.org/ecma-262/5.1/#

image::images/compat-table.png[align="center",width="85%"]

=== Standard ECMA-262 Edition 2015, 2016 etc.

La spécification *ECMAScript 2015* (_ES2015_) a été publiée en juin 2015 et succède à *ECMAScript 5*. +
La spécification _ES2015_ a successivement été appelée _ECMAScript Harmony_, _ECMAScript 6_, puis _ECMAScript 2015_.

La page Web suivante référence l'état de l'implémentation d'ECMAScript 2015 ainsi que des versions ultérieures sur différentes plates-formes, dont Node :

- [URL]#https://kangax.github.io/compat-table/es6/#
- [URL]#https://www.ecma-international.org/ecma-262/6.0/#

Un autre site web se focalise uniquement sur les avancées de l'implémentation des versions *ECMAScript* pour Node : [URL]#http://node.green/#.

image::images/compat-table-node.png[align="center",width="85%"]

Certaines fonctionnalités sont disponibles uniquement en utilisant une option de démarrage spécifique, par exemple :

----
$ node --harmony script.js                # <1>
----
<1> Active toutes les fonctionnalités préliminaires.

Une page explicative (en anglais) sur le site `nodejs.org` contient des indications à jour sur la compatibilité générale avec __ECMAScript 2015_ : [URL]#https://nodejs.org/en/docs/es6/#

[[primitives]]
=== Rappel des primitives ECMAScript

Un des conforts apporté par l'utilisation d'ECMAScript dans Node est qu'il n'y a pas à se soucier de la compatibilité navigateur : vous pouvez utiliser le meilleur de JavaScript !

Ce résumé des primitives et fonctionnalités principales d'_ECMAScript_ a pour but de vous apprendre ou de vous rappeler des fonctionnalités du langage disponibles dans Node {nodeCurrentVersion}.

==== String

Chaque élément d'une chaîne de caractères est encodé au format UTF-16 et peut donc contenir 16 bits de données.

L'opérateur `typeof` permet d'identifier une chaîne :

[source%interactive,javascript]
----
typeof 'Eyrolles'; <1>
----
<1> Retourne `'string'`.

On peut connaître la longueur d'une chaîne via son attribut `length`.

[source%interactive,javascript]
----
'I ♥ JavaScript'.length; <1>
----
<1> Retourne `14`.

On peut nettoyer les espaces englobant une chaîne avec la méthode `trim` :

[source%interactive,javascript]
----
'  w w w  '.trim(); <1>
----
<1> Retourne `'w w w'`.

On peut connaître la position d'un ou plusieurs caractères via la méthode `indexOf` :

[source%interactive,javascript]
----
'I ♥ JavaScript'.indexOf('JavaScript'); <1>
'I ♥ JavaScript'.indexOf('I'); <2>
'I ♥ JavaScript'.indexOf('?'); <3>
----
<1> Retourne `4` ;
<2> Retourne `0` ;
<3> Retourne `-1`, aucune occurrence n'ayant été trouvée.

On peut collecter les occurrences correspondantes à un masque de caractères via la méthode `match` :

[source%interactive,javascript]
----
'I ♥ JavaScript'.match('♥'); <1>
'I ♥ JavaScript'.match(/\wa/g); <2>
'I ♥ JavaScript'.match('!'); <3>
----
<1> Retourne `['♥']` ;
<2> Retourne `['Ja', 'va']` ;
<3> Retourne `null`.

On peut remplacer les occurrences correspondantes à un masque de caractères via la méthode `replace` :

[source%interactive,javascript]
----
'I ♥ JavaScript'.replace('♥', 'love'); // <1>
'I ♥ JavaScript'.replace(/[A-Z]/g, (char) => char.toLowerCase()); // <2>
----
<1> Retourne `'I love JavaScript'` ;
<2> Retourne `'i ♥ javascript'`.

Les _template literals_ servent à composer des chaînes de caractères multilignes et/ou contenant des expressions ECMAScript :

[source%interactive,javascript]
.primivite-template-literals.js
----
include::{sourceDir}/primitives/template-literals.js[]
----
<1> Retourne `'I ♥ JavaScript.\nCet exemple se trouve dans le fichier "primitives/template-literals.js"'`.

Les _template literals_ peuvent se préfixer d'un nom de fonction.
Ce mécanisme nommé _tagged template literals_ sert de filtre pour interpréter et interpoler le contenu de chaque _template_ (élément contenu dans `${}`). Vous pouvez écrire vos propres fonctions mais aussi utiliser des modules _npm_. +
L'exemple suivant illustre une sécurisation de contenu tiers à l'aide de la fonction `safeHtml` fournie par le module `common-tags` ([URL]#https://npmjs.com/common-tags#) :

[source%interactive,javascript]
.primivite-template-literal-tags.js
----
include::{sourceDir}/primitives/tagged-template-literals.js[]
----
<1> Affiche `<div class="user-content">\n<script>alert(document.cookie)</script>\n</div>` ;
<2> Affiche `<div class="user-content">\n\&lt;script\&gt;alert(document.cookie)\&lt;/script\&gt;\n</div>`.


[[primitive-boolean]]
==== Boolean

Un booléen est une donnée de type logique qui peut être _vraie_ ou _fausse_ en prenant respectivement la valeur `true` ou `false`.
C'est un type de choix pour effectuer des _assertions_ et vérifier des _conditions_.

[source%interactive,javascript]
.primitives/bool.js
----
include::{sourceDir}/primitives/bool.js[]
----
<1> Affiche `3` ;
<2> Affiche `true` car la condition est vérifiée ;
<3> Affiche `false` car la condition n'est pas vérifiée ;
<4> Affiche `true` car `3` _équivaut strictement_ à `3` ;
<5> Affiche `true` car la condition est vérifiée.

Une donnée peut être convertie en un booléen à l'aide de la fonction `Boolean`.
Toute valeur non-nulle convertie en booléen retournera `true`.
On dit alors que cette valeur est `truthy`.
À l'inverse, une valeur nulle, vide ou indéfinie sera dite `falsy` – `null`, `0`, `''`, `undefined`, `false` et `NaN`.

[source%interactive,javascript]
.primitives/bool-truthy-falsy.js
----
include::{sourceDir}/primitives/bool-truthy-falsy.js[]
----
<1> Affiche `false` car il s'agit d'une _chaîne vide_ convertie en booléen ;
<2> Affiche `true` car il s'agit d'un _nombre différent de 0_ converti en booléen ;
<3> `counter` vaut `3` donc la _condition est vérifiée_ – elle est _truthy_ – et exécutera la ligne d'après.

[CAUTION]
.[RemarquePreTitre]#Méfiance# Double égalité vs. triple égalité
====
Il est recommandé d'utiliser l'opérateur de _triple égalité_ pour s'assurer que deux éléments sont *de même type et de même valeur*.
Les cas de figure où la _double égalité_ évite les effets de bord indésirables sont peu nombreux…

----
console.log('' == 0);   // <1>
console.log('' === 0);  // <2>
----
<1> Affiche `true` car les deux valeurs sont _falsy_ ;
<2> Affiche `false` car les deux valeurs ne sont pas _strictement identiques_ (même type et même valeur).
====

==== Number

Tous les nombres en ECMAScript sont des flottants (double précision) respectant le standard link:https://fr.wikipedia.org/wiki/IEEE_754[_IEEE 754_].
Un nombre peut donc contenir 64 bits de données, comme en Python et PHP, entre autres.

L'opérateur `typeof` permet d'identifier un nombre :

[source%interactive,javascript]
----
typeof 42;    // <1>
typeof 13.37; // <1>
typeof NaN;   // <2>
----
<1> Retourne `'number'` ;
<2> Retourne également `'number'`, ce qui est souvent source de confusion.

On peut effectuer des opérations mathématiques grâce aux opérateurs `+` (addition), `-` (soustraction), `*` (multiplication), `/` (division) et `%` (modulo).

L'exception dont il faut se méfier est l'addition, car le signe `+` est également l'opérateur de concaténation de chaîne. +
Dès qu'une chaîne est détectée, l'opération d'addition est remplacée par une concaténation.

[source%interactive,javascript]
----
1 + 2;    // <1>
'1' + 2;  // <2>
1 + '2';  // <2>
undefined + 2; // <3>
----
<1> Retourne `3` ;
<2> Retourne `'12'` ;
<3> Retourne `NaN`.

Les fonctions `parseInt` et `parseFloat` permettent de respectivement de convertir en nombre entier et nombre flottant :

[source%interactive,javascript]
----
typeof 2.10 === 'number';
typeof '2.10' === 'string';

parseInt('2.10', 10); // <1>
parseFloat('2.10');   // <2>
----
<1> Retourne `2` ;
<2> Retourne `2.10`.

[TIP]
.[RemarquePreTitre]#FAQ# Le second argument de parseInt
====
Le second argument de la fonction `parseInt` indique dans quelle base la valeur est représentée dans la chaîne. La base décimale (10) est la plus souvent utilisée, mais il est également possible de convertir une chaîne représentant un nombre binaire (base 2) ou hexadécimal (base 16).
====

La méthode `isNaN` permet d'être sûr de ne pas manipuler un nombre indésirable :

[source%interactive,javascript]
----
Number.isNaN(undefined + 1);  // <1>
Number.isNaN(2.10);           // <2>
Number.isNaN(undefined);      // <2>
----
<1> Retourne `true` ;
<2> Retourne `false`.

Il également possible de choisir le nombre de décimales après la virgule avec la méthode `toFixed`. +
Attention toutefois, la valeur retournée est de type `String` :

[source%interactive,javascript]
----
10.0101.toFixed(2);   // <1>
10.0101.toFixed(0);   // <2>
parseInt(10.0101, 10);// <3>
----
<1> Retourne `'10.01'` ;
<2> Retourne `'10'` ;
<3> Retourne `10`.

[[primitive-function]]
==== Function

Les fonctions permettent d'isoler des portions de code et de les rendre réutilisables via l'utilisation de paramètres.

Vous pouvez les déclarer via une expression ou une déclaration assignée à une variable.
La déclaration d'une fonction est soumise à la portée du contexte dans lequel le bloc de code est placé.
Une fonction peut être créée de trois manières :

* *nommée* `function nomDeLaFonction(){ ... }` ;
* *anonyme* `function (){ ... }`
* *fléchée* `() => { ... }`.

Les fonctions anonymes sont fréquemment employées en tant que _callbacks_ ou dans des contextes itératifs (tels `Array.map` etc.)

Il est important de noter que la déclaration d'une fonction et son exécution sont deux choses différentes.

[source%interactive,javascript]
.primitives/function.js
----
include::{sourceDir}/primitives/function.js[]
----
<1> Utilisation d'une fonction fléchée (_arrow function_) en tant que fonction anonyme de _callback_ ;
<2> Utilisation d'une fonction nommée comme _callback_ de la méthode `Array.map` ;
<3> Illustration d'une _Immediatly Invocked Function Expression_, aka _IIFE_ aka _fonction immédiatement exécutée_ ;
<4> Retourne `'function'` ;
<5> Retourne `false` — la valeur étant nulle ;
<6> Retourne `[ 3, 1 ]` — un tableau filtré des valeurs nulles ou égales à `undefined` ;
<7> Lève une exception car la constante `values` n'est pas définie dans ce _scope_.

Le code contenu dans le bloc déclaratif d'une fonction crée une _portée_ (ou _scope_) qui est invisible au contexte parent de l'exécution de cette fonction.
Il s'agit d'une excellente manière d'isoler des variables, notamment pour éviter des effets de bord indésirables liés à l'état d'exécution de vos scripts.

L'exemple précédent illustre un tel cas de portée en contenant la constante `values` dans l'_IIFE_ : le contexte parent n'a aucune connaissance de son existence — et c'est tant mieux.

Une syntaxe abrégée est disponible via les fonctions fléchées :

.Tableau d'équivalence de syntaxe
|=========
| `x => x*2` | `function(x){ return x*2 }`
| `x => { x }` | `function(x){ x }`
| `x => ({ x })` | `function(x){ return { x }; }`
| `(x, y) => ({ x: y })` | `function(x, y){ return { x: y }; }`
| `(x, y) => x+y` | `function (x, y){ return x+y }`
| `x => { const y = 2; return x*y }` | `function(x){ const y = 2; return x*y }`
|=========

Il est possible de composer des fonctions à partir d'autres fonctions en utilisant la méthode `bind`.
Ce _pattern_ est extrêmement puissant car il permet de modifier le contexte d'exécution de ladite fonction.

[source%interactive,javascript]
.primitives/function-bind.js
----
include::{sourceDir}/primitives/function-bind.js[]
----
<1> Retourne `'100 EUR'` ;
<2> Retourne `'100 GBP'`.

`bind` est également capable de créer une nouvelle fonction à laquelle vous auriez appliqué partiellement des arguments :

[source%interactive,javascript]
.primitives/function-partials.js
----
include::{sourceDir}/primitives/function-partials.js[]
----
<1> Affiche `'Hello World'` ;
<2> Affiche `'Hello Paris'`.

Ce procédé est particulièrement utile pour rendre des fonctions génériques et composer des dérivées, notamment dans le cas de pagination.

Les méthodes `call` et `apply` reposent sur le même principe mais à la différence de `bind`, elles exécutent immédiatement la fonction.
Le seul élément différenciant correspond à la syntaxe d'application des arguments :

[source%interactive,javascript]
.primitives/function-call-apply.js
----
include::{sourceDir}/primitives/function-call-apply.js[]
----
<1> Retourne `'<title>'` dans les deux cas.

[[primitive-array]]
==== Array

L'opérateur `typeof` ne permet pas d'identifier un tableau. Il faut pour cela privilégier la méthode `isArray` :

[source%interactive,javascript]
----
typeof [];        // <1>
Array.isArray([]);// <2>
----
<1> Retourne `'object'` ;
<2> Retourne `true`.

Il est possible de connaître la longueur d'un tableau en utilisant la propriété `length` :

[source%interactive,javascript]
----
[1, 2, 3].length; // <1>
----
<1> Retourne `3`.

La méthode `join` permet de concaténer tous les éléments d'un tableau avec le séparateur de votre choix :

[source%interactive,javascript]
----
[1, 2, 3].join(', ') + '… soleil';  // <1>
----
<1> Retourne `'1, 2, 3… soleil'`.

À l'inverse, la méthode `from` prend en charge la création de tableau à partir d'_itérables_ ou de structures similaires à des tableaux, comme `arguments` ou `NodeList` (dans un navigateur).

[source%interactive,javascript]
.primivite-array-from.js
----
include::{sourceDir}/primitives/array-from.js[]
----
<1> Retourne `[ 'c', 'a', 'm', 'e', 'm', 'b', 'e', 'r', 't' ]` ;
<2> Retourne `[ 1, 'b', 3, 'd' ]` ;
<3> Retourne `[ 1, 'b', 3, 'd' ]`.

En complément, la méthode `concat` permet de concaténer d'autres éléments :

[source%interactive,javascript]
----
include::{sourceDir}/primitives/array-concat.js[]
----
<1> Retourne `[ 1, 2, 3 ]` ;
<2> Retourne `[ 1, 2, 3, 4 ]` ;
<3> Retourne `[ 1, 2, 3, 4, 4, 5 ]` — cf. <<primitive-map-set,Map et Set>>.

La fonction de tri via la méthode `sort` se base sur des comparaisons positives, négatives ou neutres pour retourner un nouveau tableau, réindexé :

[source%interactive,javascript]
----
[1, 3, 2].sort((a, b) => a - b);  // <1>
[1, 3, 2].sort((a, b) => b - a);  // <2>

['A', 'b', 'c', 'a'].sort((a, b) => a.localeCompare(b))); // <3>
----
<1> Retourne `[1, 2, 3]` ;
<2> Retourne `[3, 2, 1]` ;
<3> Retourne `['a', 'A', 'b', 'c']`.

Les méthodes suivantes sont des nouveautés d'ECMAScript 5.
Elles facilitent énormément les itérations sur les tableaux tout en ajoutant une orientation fonctionnelle, utile pour la lisibilité du code.

La méthode `map` permet de retourner un nouveau tableau avec des valeurs modifiées :

[source%interactive,javascript]
.primitives/array-map.js
----
include::{sourceDir}/primitives/array-map.js[]
----
<1> Retourne `['A', 'B', 'C']`.

La méthode `filter` quant à elle retourne un nouveau tableau ne contenant que les éléments retournant un <<primitive-boolean,booléen _truthy_>> :

[source%interactive,javascript]
.primitives/array-filter.js
----
include::{sourceDir}/primitives/array-filter.js[]
----
<1> Retourne `[1, 0]` ;
<1> Retourne `[1, 'a', 120]`.

De manière similaire, les méthodes `some` et `every` retournent un booléen si _au moins une itération_ et _toutes les itérations_ ont renvoyé une _valeur positive_ :

[source%interactive,javascript]
.primitives/array-some.js
----
include::{sourceDir}/primitives/array-some.js[]
----
<1> Renvoie `true` puisqu'au moins une valeur équivaut à `undefined` ;
<2> Renvoie `false` puisque toutes les valeurs n'équivalent pas à `undefined` ;
<3> Renvoie `true` puisque toutes les valeurs sont égales à `undefined`.

ECMAScript 2015 introduit les méthodes `find` et `findIndex`, respectivement pour retourner une valeur et son index selon une fonction prédicat :

[source%interactive,javascript]
.primitives/array-find.js
----
include::{sourceDir}/primitives/array-find.js[]
----
<1> Valeur que l'on recherche ;
<2> Affiche `stram` (valeur recherchée) ;
<3> Affiche `1` (index de la valeur recherchée).

La méthode `reduce` a un comportement similaire à `sort` mais fonctionne de manière accumulative :

[source%interactive,javascript]
.primitives/array-reduce.js
----
include::{sourceDir}/primitives/array-reduce.js[]
----
<1> Affiche `21` ;
<2> Affiche `[9, 12]`.

[TIP]
.[RemarquePreTitre]#FAQ# Tableau non contigu.
====
Il se peut que des valeurs soient manquantes dans un tableau.
On dit alors que les valeurs ne sont pas contiguës.

Cela affecte les fonctions itératives et peut se révéler problématique si vous cherchez à conserver cette absence de valeurs :

----
const a = [1,, 3, undefined, null];
const print = (value) => console.log(value);

a.length;         // <1>
a.forEach(print); // <2>
----
<1> Retourne `5` ;
<2> Affiche 4 valeurs : `1`, `3`, `undefined` puis `null`.
====

[[primitive-object]]
==== Object

Dans ECMAScript, tout est objet. C'est le _prototype_ qui détermine le comportement dudit objet.
Les objets peuvent être créés de manière littérale, avec la fonction `Object.create` ou via un constructeur. +
À la différence d'un `Array`, il est possible de nommer une clé par une chaîne de caractères – statique ou dynamique – ou avec un <<primitive-symbol,symbole>>.

[source%interactive,javascript]
.primitives/object.js
----
include::{sourceDir}/primitives/object.js[]
----
<1> Retourne `'lateral'` ;
<2> Retourne également `'lateral'` ;
<3> Retourne `true`, les deux objets étant la même instance ;
<4> Retourne `false`, les deux objets étant deux instances différentes.

L'opérateur `typeof` permet d'identifier la primitive d'une variable — au sens d'ECMAScript, pas au sens logique de votre application, c'est à dire le prototype d'un objet.

L'opérateur `instanceof` ou la méthode `getPrototypeOf` permettent justement de comparer les appartenances logiques.

[source%interactive,javascript]
.primitives/object-typeof-instanceof.js
----
include::{sourceDir}/primitives/object-typeof-instanceof.js[]
----
<1> Affiche `function` ;
<2> Affiche `object` ;
<3> Affiche `true` ;
<4> Affiche `[object Object]` ;
<5> Affiche `PseudoBookClass`.

`Object.keys` extrait les propriétés énumérables d'un objet, à la différence de `Object.getOwnPropertyNames()` :

[source%interactive,javascript]
.primitives/object-keys.js
----
include::{sourceDir}/primitives/object-keys.js[]
----
<1> Affiche `[ 'name', 'services' ]` ;
<2> Affiche `[ 'name', 'services', 'internal_code' ]`.

[[primitive-object-getset]]
`Object.defineProperty` permet de régler finement d'autres spécificités d'un objet, dont des *accesseurs* (_getters_) et des *mutateurs* (_setters_).
Ces attributs spéciaux nous autorisent la création de _propriétés calculées_, de _propriétés en lecture seule_ ou de _maitriser l'écriture d'une propriété_ :

[source%interactive,javascript]
.primitives/object-getters.js
----
include::{sourceDir}/primitives/object-getters.js[]
----
<1> Nous définissons de nouvelles propriétés pour l'objet `book` ;
<2> Définition d'un _mutateur_ pour la propriété `date_published` ;
<3> La valeur `date` est convertie en objet et stockée dans la propriété `_published_at` ;
<4> Définition d'un _accesseur_ pour la propriété `date_published` ;
<5> Appel du _mutateur_ qui, en interne, convertit la chaîne de caractères en objet `Date` ;
<6> Appel de l'_accesseur_ et affiche `true` car il s'agit bien d'une instance de `Date` ;
<7> Lance une exception car la chaîne assignée n'est pas une date valide.

Trois choses sont à souligner dans cet exemple.

Tout d'abord, notre définition de _mutateur_ ajoute de la sécurité.
Sa valeur est _garantie_ et nous savons que `book.date_published` sera systématiquement une date.

Inconvénient, nous n'avons d'autre choix que de stocker la date dans une autre propriété, ici `book.\_published_at`.
Et rien ne nous empêche de la modifier directement et d'invalider une partie de notre raisonnement… +
Il nous faudrait trouver un moyen de stocker la valeur du _mutateur_ et de l'_accesseur_ de manière _privée_.

Enfin, les propriétés sont assignées _uniquement_ à l'objet `book`. Si nous voulions les généraliser à plusieurs instances d'objets se ressemblant, nous les définirions alors dans une <<primitive-class,classe>>.

Nous pouvons définir des _accesseurs_ et des _mutateurs_ avec une notation raccourcie, ayant exactement le même effet.
Reprenons l'exemple précédent :

[source%interactive,javascript]
.primitives/object-getters-shorthand.js
----
include::{sourceDir}/primitives/object-getters-shorthand.js[]
----
<1> Définition _raccourcie_ du _mutateur_ pour la propriété `date_published` ;
<2> Définition _raccourcie_ de l'_accesseur_ pour la propriété `year_published` – notez qu'on ne définit pas de _mutateur_ pour cette même propriété ;
<3> Lance une _exception_ car la propriété `year_published` est définie en tant qu'_accesseur_ uniquement ; on ne peut donc pas lui _assigner_ de valeur.

`Object.assign` étend des structures existantes et la définition de valeurs par défaut.
Les clés et valeurs sont copiées de gauche à droite avant d'être assignées dans le premier paramètre :

[source%interactive,javascript]
.primitives/object-assign.js
----
include::{sourceDir}/primitives/object-assign.js[]
----
<1> Les clés et valeurs de `DEFAULT` et celles de `userOptions` sont copiées dans un objet vide puis retournées dans `mergedOptions` ;
<2> Affiche `{ concurrency: 10, timeout: 'https', tags: [] }` ;
<3> Affiche `[ 'img', 'h1' ]` ;
<4> Affiche `[ 'url', 'env', 'tags' ]` — l'objet `testOptions` est donc modifié.

==== Date

L'opérateur `typeof` ne permet pas d'identifier une date. Il convient d'utiliser `instanceof` :

[source%interactive,javascript]
----
typeof (new Date('2014-03-24'));  // <1>
(new Date('2014-03-24 13:37')) instanceof Date; // <2>
typeof Date.parse('2014-03-24 13:37');          // <3>
----
<1> Retourne `'object'` ;
<2> Retourne `true` ;
<3> Retourne `'number'`, car il s'agit d'une date exprimée en millisecondes depuis le 1er janvier 1970 (temps _EPOCH_).

Il également possible d'obtenir la date actuelle exprimée en millisecondes avec `Date.now` :

[source%interactive,javascript]
----
Date.parse(new Date()); // <1>
Date.now();             // <2>
----
<1> Retourne `1397381941000` ;
<2> Retourne `1397381941031`, équivalent à la syntaxe précédente donc, la précision à la milliseconde près en plus.

[[primitive-destructuring]]
==== Décomposition

L'affectation par _décomposition_ (_destructuring_) est une manière élégante et intuitive de piocher dans un <<primitives/array,tableau>> ou dans un <<primitives/object,objet>>.
La décomposition n'altère pas le contenu des variables décomposées.

Les valeurs d'un tableau sont décomposées dans l'ordre tandis que l'opérateur _spread_ (`...`) permet d'assigner le _reste_ des valeurs dans une seule et même variable ou constante :

[source%interactive,javascript]
.primitives/destructuring-array.js
----
include::{sourceDir}/primitives/destructuring-array.js[]
----
<1> Décompose la première valeur du tableau et assigne _le reste_ dans une autre constante ;
<2> Affiche `Bordeaux` ;
<3> Affiche `[ 'Toulouse', 'Montpellier', 'Aix-en-Provence' ]` ;
<4> Affiche `[ 'Bordeaux', 'Toulouse', 'Montpellier', 'Aix-en-Provence' ]`.

Il est également possible de _sauter_ des valeurs en ne nommant pas _autant_ de variables ou de constantes lors de la décomposition :

[source%interactive,javascript]
.primitives/destructuring-spread.js
----
include::{sourceDir}/primitives/destructuring-spread.js[]
----
<1> Assigne la première valeur dans la constante `first`, saute la seconde et assigne le reste des valeurs dans `end` ;
<2> Affiche `un` ;
<3> Affiche `[ 'deux', 'trois', 'quatre' ]`.

Le même mécanisme existe pour les <<primitives/object,objets>>, y compris dans des arguments de fonction :

[source%interactive,javascript]
.primitives/destructuring-object.js
----
include::{sourceDir}/primitives/destructuring-object.js[]
----
<1> Destructure la fonction `join` directement depuis le `require` de module ;
<2> Destructure la valeur `debug` du premier argument;
<3> Affiche `folder/filename.txt` – `folder\filename.txt` sous Windows ;
<4> Affiche `true` car la clé `debug` a été décomposée en `configDebug` ;
<5> Affiche `undefined` – cette valeur n'existe pas dans l'objet `config` ;
<6> Affiche `Demo` – cette valeur est complétée par défaut dans l'assignation ;
<7> Affiche `true`.

Comme indiqué en début de section, il est possible de nommer les clés de manière dynamique mais aussi d'utiliser une syntaxe raccourcie d'assignation de valeur :

[source%interactive,javascript]
.primitive-object-advanced.js
----
include::{sourceDir}/primitives/object-advanced.js[]
----
<1> Utilise la valeur d'une variable comme nom de clé ;
<2> Syntaxe alternative possible, utile lorsqu'un objet existe déjà ;
<3> Affiche `{ SNCF: { country: 'France' }, Reinfe: { country: 'Spain' } }` ;
<4> Utilise la syntaxe d'assignation raccourcie, donc assigne la valeur de `sncf` à la clé `sncf` — affiche `{ sncf: 'SNCF', foo: 'bar' }` ;
<5> _Idem_ mais sans la syntaxe d'assignation raccourcie.

[[primitive-rest]]
==== Paramètres du reste

Les _paramètres du reste_ (_rest parameters_) utilisent une syntaxe identique à la _décomposition_ mais opèrent au niveau des arguments de fonctions :

[source%interactive,javascript]
.primitives/rest.js
----
include::{sourceDir}/primitives/rest.js[]
----
<1> Assigne la constante décomposée `args` en tant que constante `cheeses` ;
<2> Affiche `Fromages` ;
<3> Affiche `[ { name: 'Cabécou' }, { name: 'Chaource' } ]` –

En bref, ils sont l'équivalent de l'ancienne variable _magique_ `arguments` mais avec une meilleure finesse quant aux paramètres concernés.
Les éléments retournés par les _paramètres du reste_ ont aussi l'avantage d'être un véritable objet de <<primitives/array,tableau>> – `arguments` est _itérable_ mais n'est pas un tableau et ne bénéficie donc pas des méthodes de compréhension telles que `forEach`, `map`, etc.

[[primitive-map-set]]
==== Map et Set

Deux nouvelles interfaces d'itération sont disponibles depuis _ECMAScript 2015_ : _Map_ et _Set_.
Elles font penser respectivement à `Object` et `Array` mais diffèrent de ces primitives sur les points suivants :

- elles garantissent l'*unicité par référence* des valeurs ;
- elles garantissent l'*ordre* des valeurs ;
- elles exposent la *même interface* de navigation et de manipulation ;
- elles peuvent être créées à partir d'un __itérable__ ou d'un tableau (de valeurs ou de clés+valeurs).

[source%interactive,javascript]
.primitive-set.js
----
include::{sourceDir}/primitives/set.js[]
----
<1> Construit un `Set` depuis un `Array` ;
<2> Reconstruit un `Array` à partir des valeurs du `Set` et affiche `[ 11, 13 ]`;
<3> Ce tableau sera ajouté car s'il est identique au précédent, il s'agit d'un objet différent, donc d'une référence d'objet différente ;
<4> On peut ajouter un `Set` en tant que valeur de `Set` si on le souhaite ;
<5> À l'inverse du point 3, l'ajout multiple d'une référence à un même objet (ici, `primesArray`) ne fonctionnera pas ;
<6> Affiche `Set { 2, 3, [ 5, 7 ], [ 5, 7 ], Set { 11, 13 }, [ 11, 13 ] }` ;
<7> Utilise la <<primitive-destructuring,décomposition>> pour extraire les valeurs du `Set` et affiche `[ 2, 3, [ 5, 7 ], [ 5, 7 ], Set { 11, 13 }, [ 11, 13 ] ]`.

`Map` offre quelques avantages à l'utilisation d'un `Object` :

- les clés peuvent être de n'importe quel type (y compris une référence à un autre objet ou tableau ECMAScript) ;
- `.size` retourne le nombre de clés de la _Map_ ;
- l'itération est très simple avec `for..of`, `forEach` ou même en utilisant la <<primitive-destructuring,décomposition>>.


[source%interactive,javascript]
.primitive-map.js
----
include::{sourceDir}/primitives/map.js[]
----
<1> Assigne un objet en référence de `Map` vers un objet de type `Set` ;
<2> Parcourt chaque enregistrement de `Map` et en affiche sa clé et sa valeur ;
<3> _Ditto_ mais avec l'expression `for..of` ;
<4> Affiche `2` car notre `Map` comporte 2 enregistrements ;
<5> Affiche les enregistrements de la `Map` sous forme de paires `[clé, valeur]`;
<6> Affiche `{nbsp}` (_rien_) car la `Map` a été vidée à la ligne précédente.

Toutefois _Map_ et _Set_ ont quelques inconvénients :

- absence des méthodes de compréhension de tableau (`map`, `reduce` etc.) ;
- pas de conversion native en JSON.

À vous de choisir entre `Object` et `Map` ou entre `Array` et `Set` en fonction de la rigueur de vos besoins.

[TIP]
.[RemarquePreTitre]#Documentation# Pour en savoir plus
====
La documentation complète de `Map` et de `Set` est disponible en français sur la ressource communautaire MDN :

- [URL]#https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Map#
- [URL]#https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Set#
====


[[primitive-class]]
==== Class

ECMAScript 2015 ajoute au langage des sucres syntaxiques facilitant la création et maintenance d'objets métier.
Nous bénéficions d'une véritable notion de constructeur, de méthodes statiques et même d'extension de prototype — on pourrait parler d'héritage mais nous n'avons pas envie d'aller dans cette direction, pas vrai ?

Tout ce que nous attachions auparavant à une _fonction_, nous nous référons désormais à une _classe_ à proprement parler. +
En voici un exemple de définition :


[source%interactive,javascript]
.class-view.js
----
include::{sourceDir}/class-view.js[]
----

La définition de la classe `View` comporte trois fonctions :

- `constructor` : le constructeur invoqué à chaque nouvelle instantiation via l'opérateur `new` ;
- `render` : une méthode partagée par toutes les instances de `View` — équivalent à `View.prototype.render = function () { ... }` ;
- `removeDuplicates` : une méthode statique, utilisable indépendamment des instances de `View` — équivalent à `View.removeDuplicates = () => ({ ... })`.

L'exemple suivant illustre le comportement de la classe `View` :

[source%interactive,javascript]
.primitives/class-constructor.js
----
include::{sourceDir}/primitives/class-constructor.js[]
----
<1> Affiche `object` ;
<2> Affiche `true` ;
<3> Affiche `{ blacklist: [ 'object', 'iframe' ] }` — l'objet de configuration initial ;
<4> Affiche `Node.js` ;
<5> Affiche une exception personnalisée.

Nous l'avons vu précédemment au niveau des <<primitive-object,objets>>, ECMAScript permet de définir des accesseurs. +
L'exemple suivant illustre leur définition au sein d'une classe :

[source%interactive,javascript]
.primitives/class-accessors.js
----
include::{sourceDir}/primitives/class-accessors.js[]
----
<1> Retourne `'978'`;
<2> Retourne `'2212136401'` ;
<3> Retourne `'978-2212136401'`.

La logique des accesseurs est ainsi partagée entre _tous les objets_ étant des instances de `Book`.

L'exemple suivant illustre deux classes héritant de notre classe `View` :

[source%interactive,javascript]
.primitives/class-extends.js
----
include::{sourceDir}/primitives/class-extends.js[]
----
<1> Retourne une chaîne de HTML après avoir interpolé les variables avec leur valeur respective ;
<2> Retourne la chaîne de texte `# Node.js\n#{empty}#\#{empty}#\#{empty}#\#{empty}#{empty}#\n\nHello World!`.

`HTMLView` surcharge le constructeur tandis que `TextView` se contente du comportement par défaut défini par le constructeur de `View`.

L'appel à la fonction `super` revient à _appeler le constructeur de la classe que l'on étend_.
Ne pas l'appeler revient à ne pas exécuter le constructeur de la classe parent.

S'il est désormais plus sûr d'utiliser l'extension de chaîne prototypale, *il ne faut pas abandonner la composition* pour autant.

Il est en effet bien plus simple de réutiliser (et de tester) des fonctions agnostiques de contexte — agnostiques du `this` — que de maintenir de grosses classes héritant sur plusieurs niveaux.

[[primitive-promise]]
==== Promise

L'organisation du code autour des _callbacks_ est difficile et ce, que ce soit en terme de maintenance, de gestion des erreurs ou de propagation d'information.

Un motif a émergé en réponse à cette complexité grandissante : les *promesses*.
*Il s'agit d'une primitive à maitriser* et disponible _nativement_ à la fois dans Node et les navigateurs modernes.

Historiquement, de nombreuses librairies ont proposé leur propre implémentation de promesses mais avec le défaut de ne pas être interopérables entre elles.
La spécification _Promise/A+_ a émergé pour établir un standard de compatibilité.
ECMAScript 2015 introduit nativement cette API, la rendant alors disponible pour le web et pour Node, avec ou sans _polyfill_.

Les cas d'utilisation des promesses sont multiples :

- exécuter une continuité d'actions asynchrones ;
- paralléliser des actions asynchrones et exécuter des instructions lorsqu'une ou plusieurs de ces actions sont terminées ;
- simplifier la gestion des erreurs à n'importe quelle étape du processus asynchrone.

[TIP]
.[RemarquePreTitre]#Définition# Promesse
====
Une promesse est *un objet retourné immédiatement* et qui exécute une fonction de résolution *une seule et _unique_ fois dans le futur*.
Cette résolution peut être soit _positive_ soit _négative_.

C'est un peu comme envoyer un _courrier suivi_ :

- le bureau de poste vous remet une preuve de dépôt (la promesse) ;
- les services postaux acheminent l'accusé de réception lorsque le destinataire a reçu le courrier et signé l'avis de délivrance (_résolution positive_) ;
- les services postaux émettent un accusé de non-délivrance si le destinataire n'a pas signé ni récupéré son courrier dans un délai imparti (_résolution négative_).
====

Une `Promise` consiste à appeler un _constructeur_ implémentant le _pattern_ _Executor_.
Le constructeur transmet les fonctions d'exécution permettant de _résoudre_ la promesse, _positivement_ en appelant `resolve` ou _négativement_, en appelant `reject`. +
`resolve` et `reject` transmettent les valeurs passées en argument à vos _callbacks_ souscrivant respectivement à `then` et `catch`.

[source%interactive,javascript]
.primitives/promise.js
----
include::{sourceDir}/primitives/promise.js[]
----
<1> Affiche `un` car la promesse est résolue de manière asynchrone, donc après l'exécution de cette ligne synchrone ;
<2> Affiche `deux` ;
<3> Affiche `DEUX` car la promesse précédente résoud la valeur _DEUX_ ;
<4> Affiche `undefined` car la promesse précédent ne résoud _rien_.

L'exemple suivant illustre une encapsulation de la fonction `fs.readFile` de Node en tant que promesse :

[source%interactive,javascript]
.primitives/readfile.js
----
include::{sourceDir}/primitives/readfile.js[]
----
<1> La promesse englobe l'exécution asynchrone — toute exception levée revient à implicitement appeler `reject` ;
<2> Résout négativement la promesse en passant le contenu de la dite erreur ;
<3> Résout positivement la promesse — si le _parsing_ échoue, la promesse sera rejetée.

Une instance de `Promise` expose plusieurs méthodes pour propager le statut de son exécution.
Les plus couramment employées sont `then` et `catch`:

- `then(onSuccess[, onError])` : fonction acceptant un _callback_ de résolution et un _callback_ de rejet facultatif ;
- `catch(onError)` : fonction acceptant un _callback_ de rejet.

Illustrons désormais la consommation d'une promesse en se basant sur le code précédent :

[source%interactive,javascript]
.primitives/promise-readfile.js
----
include::{sourceDir}/primitives/promise-readfile.js[]
----
<1> Création d'une `Promise` ;
<2> Consommation du résultat et propagation d'une nouvelle promesse retournant le nombre de dépendances contenu dans le `package.json` de ce chapitre ;
<3> Consommation du nouveau résultat ;
<4> Cette fonction sera appelée si une erreur se déclenche en amont de la chaîne de promesses.

`Promise.all` est une méthode statique de l'API _Promise_ qui retourne elle-même une promesse.
Elle sera résolue positivement lorsque toutes les promesses passées en argument seront résolues ou négativement dès que l'une d'entre elles échouera.

Reprenons le précédent exemple pour compter _en parallèle_ les dépendances de trois fichiers `package.json` :

[source%interactive,javascript]
.primitives/promise-all.js
----
include::{sourceDir}/primitives/promise-all.js[]
----
<1> On passe un tableau de promesses non-résolues à `Promise.all` ;
<2> Cette fonction est exécutée dès que le tableau est résolu, avec le contenu de chaque fichier – dont nous comptons un par un le nombre de dépendances ;
<3> Cette ligne ne change pas par rapport au précédent exemple — un bénéfice d'une bonne découpe de code.

Usez et abusez des promesses : elles sont un des meilleurs moyens à notre disposition pour *modulariser*, *linéariser* et *clarifier le sens* du flot de notre code.

Nous aborderons à nouveau les <<pattern-promise,promesses en tant que _design pattern_>> dans ce même chapitre.

[TIP]
.[RemarquePreTitre]#Lien# Guide des promesses
====
Un guide _très_ complet — en anglais — est publié en libre consultation sur le site du W3C.
Un dépôt sur GitHub permet d'y contribuer.

- [URL]#https://www.w3.org/2001/tag/doc/promises-guide#
- [URL]#https://github.com/w3ctag/promises-guide#
====

[TIP]
.[RemarquePreTitre]#Documentation# Pour en savoir plus
====
La documentation complète de `Promise` est disponible en français sur la ressource communautaire MDN :

- [URL]#https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Promise#
====


[[primitive-async-await]]
==== async/await

Nous avons beaucoup appris sur les différents moyens d'organiser notre code de manière asynchrone.
Peut-être avec une indigestion de `then()`. +
Les opérateurs `async` et `await` sont là pour respectivement :

. déclarer une fonction comme pouvant _être mise en pause_ ;
. mise en pause effectuée avec l'opérateur `await`, pause suivie jusqu'à ce qu'une… promesse retourne un résultat.

Une promesse placée derrière un `await` jettera une exception.
Cette exception est interceptable avec un bloc `try/catch`, comme du code synchrone.

Reprenons une nouvelle fois notre exemple précédent, en combinant la transformation en promesses et les opérateurs `async` et `await` :

[source%interactive,javascript]
.primitives/async-await.js
----
include::{sourceDir}/primitives/async-await.js[]
----
<1> Déclaration de la fonction `getAllDeps` en tant que fonction asynchrone ;
<2> On itère comme de manière synchrone, en demandant à l'interpréteur d'attendre que la promesse `readFilePromise` soit résolue ;
<3> Le contenu de `fileBuffer` est disponible à la ligne d'après, sans utiliser `readFilePromise.then()` ;
<4> La fonction `getAllDeps` retourne une promesse ;
<5> <2> Résultat identique à celui calculé dans `primitives/promise-all.js`.

À travers cet exemple on comprend qu'une fonction `async` retourne en réalité une promesse.
Promesse résolue lorsque toutes ses conditions `await` sont elles aussi résolues séquentiellement.

L'inconvénient de notre exemple est que la lecture des fichiers ne se fait plus en _parallèle_ mais bel et bien de manière _séquentielle_.
En effet, notre code est mis en pause à chaque itération de boucle, lors de l'appel de `readFilePromise`.

[[primitive-regexp]]
==== RegExp

Les expressions régulières en JavaScript permettent de pratiquer des recherches de motifs simples et complexes au sein de chaînes de caractères.
Elles sont inspirées de l'implémentation dans Perl 5.

L'opérateur `instanceof` permet d'identifier une instance d'expression régulière :

[source%interactive,javascript]
----
/Eyroll?es/g instanceof RegExp; <1>
(new RegExp('Eyroll?es', 'g')) instanceof RegExp; <1>
----
<1> Retourne `true`.

La méthode `exec` permet de capturer les occurrences d'une expression régulière au sein d'une chaîne de caractères :

[source%interactive,javascript]
----
/(.+)(Script)/.exec('ECMAScript'); <1>
----
<1> Retourne `['ECMAScript', 'ECMA', 'Script']`.

Plusieurs drapeaux peuvent être utilisés :

- `g` pour chercher dans toute la chaîne et ne pas s'arrêter à la première occurrence trouvée ;
- `i` pour ne pas tenir compte de la casse ;
- `m` pour que les caractères `^` et `$` correspondent respectivement au début et à la fin d'une ligne au lieu du début et de la fin de la chaîne ;

[source%interactive,javascript]
----
let re;
const text = ['JavaScript', 'ECMAScript'].join("\n");

re = /^([a-z]+)(Script)/;
re.exec(text); <1>

re = /^([a-z]+)(Script)/i;
re.exec(text); <2>

re = /([a-z]+)(Script)$/i;
re.exec(text); <3>

re = /([a-z]+)(Script)$/im;
re.exec(text); <4>

re = /^([a-z]+)(Script)$/gim;
re.exec(text); <5>
re.exec(text); <6>
re.exec(text); <7>
----
<1> Retourne `null` ;
<2> Retourne `['JavaScript', 'Java', 'Script']` ;
<3> Retourne `['ECMAScript', 'ECMA', 'Script']` ;
<4> Retourne `['JavaScript', 'Java', 'Script']`, puisque `$` correspond à la fin de ligne et non la fin de chaîne ;
<5> Retourne `['JavaScript', 'Java', 'Script']` ;
<6> Retourne `['ECMAScript', 'ECMA', 'Script']` puisque le curseur a effectué la recherche après la position de la précédente occurrence ;
<7> Retourne `null` puisque le curseur a rencontré la fin de la chaîne ;

[CAUTION]
.[RemarquePreTitre]#Remarque# Gare à la réutilisation de l'objet _RegExp_ !
====
Vous l'aurez remarqué avec le drapeau `g`, le comportement de la méthode `exec` peut renvoyer un résultat différent à chaque appel.

Il faut juste veiller à ce que ce soit un résultat escompté pour éviter tout effet de bord dans vos applications.
====

À la manière de `exec`, la méthode `test` se contente de renvoyer un booléen si un motif a été trouvé ou non :

[source%interactive,javascript]
----
/(.+)(Script)/.test('ECMAScript'); <1>
----
<1> Retourne `true`.


[[primitive-json]]
==== JSON

L'introduction du support natif du parsing JSON dans ECMAScript 5 a apporté un grand confort dans la consommation de données issues d'API.
La sécurité de cette consommation a été améliorée de par sa prise en charge par les développeurs de VM ECMAScript.

La fonction `JSON.parse` tente de convertir une chaîne de texte supposée au format JSON en un objet natif :

[source%interactive,javascript]
----
const jsonContent = '{ "ECMAScript": 5.1 }';

typeof jsonContent; <1>

const content = JSON.parse(jsonContent);
content.ECMAScript; <2>

try {
  JSON.parse('{ "ECMAScript": 5.1');
}
catch (err) {
  console.log(err.message); <3>
}
----
<1> Retourne `'string'` ;
<2> Retourne `5.1` ;
<3> Affiche `Unexpected end of input` car `JSON.parse` a lancé une exception `SyntaxError`.

À l'inverse, la fonction `JSON.stringify` convertit un objet natif en chaîne de caractères au format JSON :

[source%interactive,javascript]
----
JSON.stringify({ ECMAScript: 5.1 }); <1>
JSON.stringify({ ECMAScript: 5.1 }, null, 2); <2>
----
<1> Retourne `'{"ECMAScript":5.1}'` ;
<2> Retourne `'{\n{nbsp}{nbsp}"ECMAScript": 5.1\n}'`, le troisième argument formate proprement avec la taille d'indentation spécifiée, exprimée en nombre d'espaces par niveau de profondeur.

[TIP]
.[RemarquePreTitre]#URL# Spécification ECMAScript
====
L'ensemble de la spécification ECMAScript est disponible aux formats PDF et HTML.
Il s'agit d'une mine d'or pour comprendre les mécanismes internes du langage, les types et primitives à disposition.

- [URL]#https://www.ecma-international.org/ecma-262/5.1/#
====
