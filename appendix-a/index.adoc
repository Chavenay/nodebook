:chapterNumber: A
:chapterId: appendix-a
:sectnums:
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:revdate: {docdate}
:sourceDir: ./examples
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

[appendix]
= Sélection de modules npm

Cette annexe est une sélection de modules npm ([URL]#https://npmjs.com#)
à laquelle vous réferer pour démarrer rapidement mais aussi pour découvrir
les nombreux contextes d'utilisation de Node.

J'ai bâti cette liste à partir de mon expérience personnelle et sur la confiance
que je porte aux personnes à l'origine de ces modules.

include::../docs/tip-versions.adoc[]
include::../docs/tip-examples.adoc[]


== Boîte à outil du quotidien

Ces modules adressent des besoins quotidiens, pour travailler plus rapidement
sur des structures ECMAScript.

=== lodash

_lodash_ ([URL]#https://npmjs.com/lodash#) est une collection de plusieurs
dizaines de fonctions pour travailler plus facilement avec des chaînes de caractères,
des tableaux, des fonctions et des objets.

Vous pourrez ainsi filtrer, sélectionner, fusionner, vérifier et composer
de nouvelles variables aussi bien pour Node que dans les navigateurs web.

[source,javascript]
.npm/lodash.js
----
include::{sourceDir}/npm/lodash.js[]
----
<1> Affiche `['A', 'B', 'C', 'D']`.

=== he

_he_ ([URL]#https://npmjs.com/he#) est un utilitaire pour encoder et décoder
des entités HTML dans des chaînes de caractères.

[source%interactive,javascript]
.he.js
----
include::{sourceDir}/he.js[]
----
<1> Affiche `<h1>Blog Post</h1>`.
<2> Affiche `&#x3C;h1&#x3E;Blog Post&#x3C;/h1&#x3E;`.

=== chance

_chance_ ([URL]#https://npmjs.com/chance#) crée des données de manière aléatoire.
Le module retourne aussi des prénoms fictifs mais aussi des numéros de téléphone,
des nombres, des paragraphes, des dates d'anniversaire, des identifiants Android ou Apple, etc.

Il s'utilise surtout pour générer des données factices à des fins de tests,
en attendant les vraies données.

=== date-fns

_date-fns_ ([URL]#https://npmjs.com/date-fns#) est une collection de fonctions
pour travailler avec des dates, plus facilement qu'avec l'objet natif `Date`.

Vous pouvez formatter, ajouter ou retirer des jours, vérifier si deux périodes
de temps se chevauchent ou si deux dates font partie d'une même semaine calendaire.


=== tcomb

_tcomb_ ([URL]#https://npmjs.com/tcomb#) renforce la création de structures
typées et immutables.
Ça a pour effet de réduire les effets de bord de nos applications lorsque les
données n'ont pas la structure attendue.

[source%interactive,javascript]
.tcomb.js
----
include::{sourceDir}/tcomb.js[]
----
<1> Définition d'une structure stricte qui a pour propriété `lat` et `lon`, pour _latitude_ et _longitude_.
<2> Cet appel va jeter une exception car la propriété `long` est inconnue.
<3> Cet appel va jeter une exception car la propriété `lon` doit être un nombre.

=== eventemitter3

_eventemitter3_ ([URL]#https://npmjs.com/eventemitter3#) permet de gérer
des événements de manière uniforme dans un script Node et dans les navigateurs web.

[source%interactive,javascript]
.npm/eventemitter3.js
----
include::{sourceDir}/eventemitter3.js[]
----
<1> Affiche `[ [Function], [Function] ]`.
<2> Affiche `on: ping,ping\nonce: ping,ping`.
<3> Affiche `on: ping,ping`.
<4> N'affiche rien, l'événement étant désormais déconnecté.


[[dev]]
== Pendant le développement

=== debug

TBD.

[source,javascript]
.npm/debug.js
----
include::{sourceDir}/npm/debug.js[]
----

=== nodemon

TBD.

=== npm-run-all

_npm-run-all_ ([URL]#https://npmjs.com/npm-run-all#) est mon outil favori
pour composer avec les _scripts npm_.
Il a l'avantage d'être versatile, de permettre de régler finement ce qui
doit être exécuté en parallèle ou en série et transfère les options aux
sous-scripts.

[source,javascript]
.package.npm-run-all.json
----
include::{sourceDir}/package.npm-run-all.json[]
----

=== husky

=== onchange

=== tiny-lr

=== livereactload



== Protéger nos applications

=== sanitize-filename

=== helmet

=== dompurify

=== filenamify

=== retire.js
_retire.js_ ([URL]#https://npmjs.com/retire#) est un module npm pour
scanner soi-même des vulnérabilités connues dans le code JavaScript de son
choix.

Il fonctionne aussi bien pour du JavaScript interprété par un navigateur
web que dans Node.


== Vérifier la syntaxe de notre code

La vérification syntaxique est un mécanisme s'assurant que votre code respecte
la grammaire du langage associé.
Elle peut autant révéler des anomalies fondamentales (balise mal fermée,
expression inconnue etc.) que renforcer des pratiques de programmation
réduisant les erreurs potentielles lors de l'exécution du-dit code.

Il s'agit d'une excellente première étape avant d'introduire des tests
unitaires ou fonctionnels.
C'est aussi une pratique rapide à mettre en œuvre — de préférence dès le
début du projet — et poussant à harmoniser les pratiques de développement
au sein d'un group d'individus.

Les modules à disposition dans npm vous permettront de couvrir vos fichiers
CSS, HTML et ECMAScript bien sûr !

=== htmlhint

_htmlhint_ ([URL]#https://npmjs.com/htmlhint#) est un outil en ligne de
commande vérifiant la structure de vos documents HTML.
Il rapporte les doublons d'attributs `id`, la présence de paires de balises
mal formées, l'absence de balise fermante ou encore l'existance de chaînes de caractère non-imprimables dans des attributs critiques, entre autres.

Prenons en exemple le document suivant :

[source,html]
.sample.html
----
include::{sourceDir}/sample.html[]
----

Une lecture distraite pourrait nous faire passer à côté des erreurs mais
également des inconsistances de programmation.
Sur un document plus réaliste et donc volumineux, avec de fréquents
changements, autant oublier la vérification manuelle.

L'exécution de _htmlhint_ avec ses règles par défaut remontera les alertes
suivantes :

----
$ npm run lint-html
sample.html:
line 1, col 1: Doctype must be first.
line 8, col 10: Id redefinition of [ btn ].
line 10, col 3: Tagname [ BUTTON ] must be lower case.
line 10, col 10: The value of attribute [ class ] must closed by double quotes.
line 10, col 52: Tagname [ BUTTON ] must be lower case.
----

Si elle peuvent paraître opiniatres, sachez qu'elles n'ont pour seul but que
de décider une bonne fois pour toute quelle attitude adopter : tout ou rien
en miniscule, guillemets simples ou doubles, doctype explicite etc.

=== eslint

_eslint_ ([URL]#https://npmjs.com/eslint#) est l'outil de vérification syntaxique pour ECMAScript le plus *complet et modulaire*.
Il offre un niveau de souplesse extrême au niveau de la configuration des règles à appliquer (utilisation systématique de `use strict`, nombre maximum de paramètres de fonctions, objets non-déclarés, variables inconnues etc.). +
Il expose également une API relativement simple afin de créer vos propres règles métier.
Un autre mécanisme permet d'inclure et d'étendre un ou plusieurs  fichiers de configuration afin de les réutiliser dans différents projets.

[TIP]
.[RemarquePreTitre]#Bon à savoir# Règles par défaut
====
_eslint_ n'applique aucune règle par défaut.
Ses premières utilisations nécessiteront donc de prendre connaissance des
règles à disposition ou d'opter pour un module _npm_ définissant une
configuration _à votre goût_.

En effet si certaines règles nous alertent de dangers potentiels,
d'autres sont totalement subjectives et sujettes à des préférences
purement personnelles.
====

_eslint_ lit la section `eslintConfig` du fichier `package.json` pour
adapter son comportement.

L'exemple suivant illustre une configuration d'_eslint_ renforçant
la déclaration du mode strict au niveau global, l'emploi des égalités
strictes, l'interdiction de l'utilisation de variables non déclarées,
la cohérence d'utilisation des accolades ainsi que l'utilisation de guillemets
simples uniquement :

[source,json]
.package.json
----
include::{sourceDir}/package-eslint.json[]
----

Le niveau de sévérité de chaque règle est représenté par un identifiant :

- `none` : règle désactivée ;
- `warn` : affiche un avertissement ;
- `error` : affiche une erreur (le processus se terminera avec un code d'erreur).

Certaines règles demandent ou acceptent des arguments supplémentaires.
Elles sont toutes documentées sur le site web du projet
[URL]#http://eslint.org/docs/rules/#.

Il serait fastidieux de répéter ou copier/coller la configuration de projet en projet.
Ça tombe bien, _eslint_ fournit un mécanisme d'extension.
Ce mécanisme accepte aussi bien des chemins relatifs vers un fichier de
configuration mais aussi vers des modules npm.

L'exemple suivant illustre l'utilisation combinée de deux configurations
_eslint_ :

[source,json]
.package.json
----
include::{sourceDir}/package-eslint-extend.json[]
----

Il y a deux éléments combinés dans le précédent exemple :

- l'utilisation d'un module _npm_ pour obtenir de nouvelles règles —
spécifiques à l'analyse syntaxique d'applications React ;
- l'utilisation d'un module _npm_ (_eslint-config-airbnb_) pour configurer
_eslint_, à la fois pour du code à destination de Node, des navigateurs web
et de React.

Le détail des règles de configuration mises en application sont disponible
simplement en parcourant l'arborescence du dépôt de code disponible sur
[URL]#https://github.com/airbnb/javascript#.

=== csslint

_csslint_ ([URL]#https://npmjs.com/csslint#) est un outil de vérification
syntaxique de feuilles de style CSS.
Il a été créé par deux anciens ingénieurs de _Yahoo!_.
Leurs anciens travaux dans le domaine de la performance ont influencé
l'architecture et le choix des règles par défaut.
Celles-ci peuvent d'ailleurs être étendues, moins aisément que pour
_eslint_ certes, mais suffisamment pour adapter l'outil aux besoins modernes,
notamment ceux du web mobile.

_csslint_ fournit les mécanismes de vérification adéquats pour alerter de
possibles effets de bord de _box model_, de déclaration incompatible de
`@font-face`, de _vendor prefix_ dépréciés (voir la section
<<optimize,optimiser notre code>>) ou encore de combinaisons de
propriétés connues
pour casser l'affichage dans certains navigateurs.

Prenons par exemple le fichier CSS suivant :

[source,css]
.sample.css
----
include::{sourceDir}/sample.css[]
----

_csslint_ génèrera trois alertes en lisant le fichier `sample.css` et ce,
même si celui-ci est syntaxiquement parfaitement valide :

----
$ csslint sample.css

csslint: There are 3 problems in sample.css.

sample.css
1: warning at line 4, col 11
Values of 0 shouldn't have units specified.
  border: 0px solid black;

sample.css
2: warning at line 4, col 3
Using height with border can sometimes make elements larger than you expect.
  border: 0px solid black;

sample.css
3: warning at line 6, col 3
Using height with padding can sometimes make elements larger than you expect.
  padding: 10px;
----

Si la présence d'une mesure en pixels n'est qu'une affaire de micro-optimisation,
les deux autres erreurs sont nettement plus problématiques car elles impliquent
un manque de consistance d'affichage, selon le navigateur effectuant le rendu. +
Éviter l'utilisation de ces cas limites évite également d'avoir à empiler des
couches de CSS pouvant accentuer encore peu plus l'instabilité d'affichage.

=== doiuse

_doiuse_ ([URL]#https://npmjs.com/doiuse#) est un utilitaire qui se repose
sur la base de données de [URL]#caniuse.com#.
Il vous alerte des possibles incompatibilités de syntaxe en fonction de la
compatibilité désirée avec une liste de navigateurs web définie par vos soins.
Cette liste peut aussi bien concerner des versions spécifiques ou encore
cibler en fonction leurs parts de marché.

L'exemple suivant illustre les alertes relevées par _doiuse_ dans le cas
d'une recherche de compatibilité avec Internet Explorer 6 et Internet
Explorer 7 :

----
$ doiuse -b 'ie < 8' sample.css
sample.css:1:1: CSS 2.1 selectors not supported by: IE (6)
sample.css:8:1: CSS 2.1 selectors not supported by: IE (6)
sample.css:12:1: CSS3 Transitions not supported by: IE (6,7)
sample.css:14:1: CSS 2.1 selectors not supported by: IE (6)
----


[[optimize]]
== Optimiser notre code

Commentaires, indentations ou encore noms de variables : tout ça occupe de
la place, donc des caractères textuels et donc des octets de bande passante.

Sans outillage, l'optimisation repose littéralement entre les mains des
développeurs.
Ces derniers doivent alors compromettre lisibilité et maintenabilité au
profit de quelques kilo-octets. +
Ce que nous chercherons à tout prix à ne pas sacrifier.

Les minifieurs mettent en œuvre différentes techniques pour réduire cette occupation d'espace :

- suppression des commentaires et caractères non-significatifs ;
- renommage de variables ;
- factorisation d'occurrences multiples similaires ;
- suppression des instructions relatives au débogage/développement ;
- suppression du code inutilisé ;
- écriture automatique de code pour supporter des environnements anciens ou futurs.

=== cssmin

_cssmin_ ([URL]#https://npmjs.com/cssmin#) est un portage ECMAScript du
compresseur CSS _YUICompressor_ développé par la compagnie _Yahoo!_ à la
fin des années 2000. +
L'approche de _cssmin_ consiste principalement à supprimer les caractères
et commentaires non-significatifs.
Il ne cherche pas à faire davantage que son homologue originel.

_cssmin_ est donc un outil simple, exposant un exécutable système ainsi
qu'un module Node.
Il ne fournit en revanche aucun support pour les _Source Maps_. Il vous
faudra reposer sur l'outillage proposé par les navigateurs web modernes
pour le débogage (reformatage du code, inspection des propriétés etc.).

.Exemples d'utilisation de *cssmin*
----
$ cssmin sample.css > sample.min.css # <1>

$ cat sample.css | cssmin | wc -c | awk '{print $1}' # <2>
----
<1> Exporte le résultat de la minification dans le fichier `sample.min.css`.
<2> Utilisation des _pipes_ UNIX pour afficher le nombre de caractères d'une version minifiée de `sample.css`.

=== uglify-js2

_UglifyJS_ ([URL]#https://npmjs.com/uglify-js2#) est un des premiers
compresseurs à utiliser une  représentation syntaxique en arbre
(_Abstract Syntax Tree_ — _AST_) en lieu et place des classiques
optimisations à coups d'expressions régulières.

Cette méthode permet d'élargir les perspectives de la compression via de
la réécriture de code :

- _hoisting_ des variables (remontée de leur déclaration en début de _scope_) ;
- combinaison des déclarations de variables ;
- factorisation des valeurs de variables ;
- réécriture partielle d'expressions ;
- injection en ligne du contenu de variables.

_UglifyJS_ s'utilise de manière autonome, en ligne de commande ou via son
API ECMAScript, mais aussi par le biais de plugins grunt, gulp et
<<browserify,browserify>> (uglifyify et minifyify).

=== autoprefixer

_autoprefixer_ ([URL]#https://npmjs.com/autoprefixer#) est _le_ module qui
vous épargnera l'écriture de centaines de lignes en ajoutant automatiquement
les bons préfixes aux bons endroits.
Travail d'autant plus ingrat si vous n'avez pas envie ni le loisir de
recourir à des _mixins_ Less ou Sass. +
_autoprefixer_ expose une API ECMAScript, un exécutable système ainsi qu'une
API de _streaming_ permettant une intégration sans plugin avec
<<browserify,browserify>>, entre autres.

.Exemple d'utilisation d'_autoprefixer_ en fonction des besoins en compatibilité navigateur
----
$ autoprefixer -o - sample.css | grep transition
  -webkit-transition: font-weight 0.2s ease;
          transition: font-weight 0.2s ease;

$ autoprefixer -b 'firefox > 8' -o - sample.css | grep transition
  -webkit-transition: font-weight 0.2s ease;
     -moz-transition: font-weight 0.2s ease;
          transition: font-weight 0.2s ease;
----

L'exemple précédent illustre comment la propriété `transition` a été préfixée pour couvrir les navigateurs ayant plus de 1% de part de marché, puis en incluant les versions supérieures à Firefox 8 — assez obsolètes il faut se l'avouer. +
L'utilisation du paramètre `-o -` (_o_ pour _output_) suivi du caractère _trait d'union_ redirige le code réécrit en _sortie standard_ au lieu de modifier le fichier originel.

=== uncss

_uncss_ ([URL]#https://npmjs.com/uncss#) est le pendant inverse d'_autoprefixer_
puisqu'il se charge de supprimer le code inutilisé.
Pour se faire, _uncss_ charge une ou plusieurs pages de référence et fait la
différence entre les règles CSS utilisées et celles qui ne le sont pas.
Libre à vous de mentionner une liste blanche de règles à ne jamais supprimer
pour éviter qu'elles soient écrémées par mégarde.

Si le monde de l'optimisation ECMAScript a explosé depuis l'apparition d'_esprima_,
il en est de même pour CSS avec _PostCSS_ ([URL]#https://npmjs.com/postcss#). +
Cet outil est construit autour du triptyque suivant :

- un parseur CSS ;
- un arbre syntaxique ;
- un compilateur texte.

Cette combinaison rend possible la production de _Source Maps_ mais aussi la
construction d'une multitude d'outils destinés à faciliter la vie des développeurs.
Ces outils se greffent sur le parseur, l'arbre ou le compilateur pour parvenir
à leurs fins. +
Avec une ou plusieurs extensions, vous avez ainsi accès à _autoprefixer_, à
votre nettoyeur de code mort ou même à votre propre réimplémentation de Sass
entièrement en ECMAScript !

=== google-closure-compiler-js

_Google Closure Compiler_ ([URL]#https://npmjs.com/google-closure-compiler-js#)
est un compilateur ECMAScript plus poussé qu'_UglifyJS_ mais qui impose un
style d'écriture plus strict, voire plus contraignant.

=== csswring

_csswring_ ([URL]#https://npmjs.com/csswring#) est une alternative plus
moderne que _cssmin_.
Il s'interface aussi avec _PostCSS_ et offre un support des _Source Maps_.

=== csso

_csso_ ([URL]#https://npmjs.com/csso#) est une alternative à _cssmin_ et _csswring_.
Elle est écrite par l'équipe derrière la méthodologie BEM
([URL]#https://en.bem.info#), moins bien documentée mais plus efficace en
terme d'optimisations.

_csso_ ira jusqu'à réécrire les codes couleurs, les `margin` et `padding` et
factorisera les sélecteurs similaires.

=== svgo

[URL]#https://www.npmjs.com/svgo#



== Transformer du code

Les préprocesseurs sont des outils de productivité transformant un langage vers un autre langage, en général compatible avec une majorité de navigateurs.

Certains vous permettront même de compiler du code Node vers du code compatible avec un navigateur Web.

=== less

_less_ ([URL]#https://npmjs.com/less#) est un préprocesseur permettant de
compiler vers du code CSS.
Ses atouts résident dans la gestion des variables, de _mixins_ et de fonctions
encourageant une écriture modulaire, plus logique et plus succincte.

[source]
.stylesheet.less
----
include::{sourceDir}/stylesheet.less[]
----

L'exécutable `lessc` compile le fichier LESS:

----
$ lessc stylesheet.less
----

La sortie de la commande précédente génère ce résultat :

[source,css]
----
.btn {
  border: 1px solid black;
  border-radius: 3px;
  font-size: 18px;
}
.btn--large {
  font-size: 27px;
}
.btn--warning {
  border-color: rgba(255, 0, 0, 0.9);
  color: #ff0000;
}
----

=== sass

_Sass_ ([URL]#https://npmjs.com/node-sass#) est un autre préprocesseur
populaire issu du monde Ruby.
Un portage en C++ est disponible via le module _node-sass_ et ne requiert pas
l'installation de Ruby.

=== browserify

_browserify_ ([URL]#https://npmjs.com/browserify#) transforme des modules
CommonJS et des appels aux API Node en un code ECMAScript capable d'être
exécuté dans un navigateur Web.

Un puissant mécanisme de _transforms_ introduit des remplacements de modules
à la volée ou le mélange de modules AMD et CommonJS.

_webpack_ ([URL]#https://npmjs.com/webpack#) est une alternative à _browserify_.
Aux fonctionnalités précédemment listées s'ajoutent une prise en charge
plus aisée de multiples modules ainsi que la compilation de fichiers CSS ou Less.

[source,javascript]
.npm/browserify.js
----
include::{sourceDir}/npm/browserify.js[]
----
<1> Affiche `Open Sky`.

[source,javascript]
.package.json
----
{
  "browser": {
    "cheerio": "jquery"
  },
  "dependencies": {
    "cheerio": "^0.17.0",
    "jquery": "^2.1.1",
  },
  "devDependencies": {
    "browserify": "^5.0.0"
  }
}
----

La commande `browserify` remplacera l'appel au module _cheerio_ par un appel
au module _jquery_ :

----
$ browserify npm/browserify.js -o npm/browserify.bundle.js
----

Inclus dans un navigateur Web, le fichier `npm/browserify.bundle.js` affichera
le même résultat que l'interpréteur Node.



[[fs]]
== Gérer des fichiers

Ces librairies adressent des besoins quotidiens de manipulation de fichiers, que ce soit leur création, suppression mais aussi leur sélection ou l'écoute d'événements liés à ces activités.

=== mkdirp

_mkdirp_ ([URL]#https://npmjs.com/mkdirp#) est identique à la commande UNIX `mkdir -p`.
C'est-à-dire que les répertoires seront créés récursivement s'ils n'existent pas au préalable.

L'exemple précédent illustre l'écriture de la date courante dans un fichier.
Ce fichier n'est écrit que lorsque l'arborescence est préalablement créée.

=== rimraf

_rimraf_ ([URL]#https://npmjs.com/rimraf#) se situe dans la lignée de
_mkdirp_ : il supprime une arborescence de manière récursive — équivalent
de la commande `rm -rf`.
Encore une fois, sans la complexité d'avoir à gérer un enchevêtrement de
fonctions asynchrones.

=== glob

_glob_ ([URL]#https://npmjs.com/glob#) est un utilitaire très pratique pour
filtrer une recherche récursive au sein du système de fichiers.

Sa syntaxe équivalente à ce qui se fait dans le monde UNIX évite une écriture
de code complexe reposant sur l'API `fs`.

[source%interactive,javascript]
.npm/glob.js
----
include::{sourceDir}/npm/glob.js[]
----
<1> Affiche un tableau contenant la liste des fichiers du répertoire courant.

=== fs-extra

_fs-extra_ ([URL]#https://npmjs.com/fs-extra#) complète _rimraf_ et
_mkdirp_ et ajoute d'autres fonctions utilitaires telles que la copie et
le déplacement récursifs.


=== graceful-fs

_graceful-fs_ ([URL]#https://npmjs.com/graceful-fs#) n'apporte aucune API
supplémentaire à l'API native Node `fs`.
Sous le capot la librairie simplifie l'écriture de notre code en tentant
plusieurs fois d'accéder à un fichier si celui-ci n'est pas disponible.
Un module qui vous sera utile si l'activité de lecture et d'écriture sur
disque dépasse les capacités du système.


=== chokidar

_chokidar_ ([URL]#https://npmjs.com/chokidar#) normalise l'observation du
système de fichiers pour une très grande majorité de systèmes d'exploitation.
La librairie ajoute quelques fonctionnalités de filtre, de persistance
d'observation et permet de dynamiquement ajouter ou retirer des fichiers
de l'observation.


[[databases]]
== Stocker dans des bases de données

Node supporte un vaste ensemble de bases de données grâce aux modules npm.
Favorisez toujours les modules faisant état de _driver_ natif/binaire : la communication vers la base de données n'en sera que plus rapide.

=== knex

_knex_ ([URL]#https://npmjs.com/knex#) est une librairie de manipulation
de base de données SQL.
Elle est notamment compatible avec PostgreSQL, MariaDB, MySQL et SQLite.
Son API fluide basée sur des _callbacks_ et des _promesses_ vous sera précieuse pour ne pas écrire de requête à la main.

=== bookshelf

Les auteurs de _knex_ ont créé la surcouche _bookshelf_
([URL]#https://npmjs.com/bookshelf#) pour gérer des modèles de données au
lieu de requêtes SQL.

[source,javascript]
.npm/knex.js
----
include::{sourceDir}/npm/knex.js[]
----
<1> Affiche `[ { id: 1, title: 'Node.js ', created_at: '2015-10-09 16:06:17' } ]`.

L'exemple précédent se charge de créer une table dans une base de données
SQLite, puis y insère trois nouveaux enregistrements.

=== sequelize

https://npmjs.com/sequelize
https://sequelize.readthedocs.io/

=== mongoose

_mongoose_ ([URL]#https://npmjs.com/mongoose#) est un _ODM_
(_Object Document Model_) pour MongoDB.
Il vous aidera à composer vos modèles, gérer la connexion à la base
de données mais aussi à définir des comportements annexes comme des mixins
ou des _accesseurs_ dynamiques.

[source,javascript]
.npm/mongoose.js
----
include::{sourceDir}/npm/mongoose.js[]
----
<1> Affiche `3 enregistrements créés`.

=== levelup

_LevelDB_ ([URL]#https://npmjs.com/levelup#) est un système de base de
données clé/valeur extrêmement modulaire, avec un stockage sur disque
par défaut mais qui peut évoluer vers du stockage en mémoire (module `memdown`).
Et encore mieux, cette base de données fonctionne aussi dans un navigateur web !

[source,javascript]
.npm/levelup.js
----
include::{sourceDir}/npm/levelup.js[]
----

=== redis

_redis_ ([URL]#https://npmjs.com/redis#) est une autre base de données
clé/valeur focalisée sur la performance et la distribution sur de
multiples serveurs.

_hiredis_ ([URL]#https://npmjs.com/hiredis#) est un _driver_ C++ pouvant
être utilisé par le module Node _redis_.
Il permet de travailler directement avec des buffers plutôt qu'avec des
conversions JSON, ce qui accélère le processus de conversion/déconversion
depuis la base de données.

[source,javascript]
.npm/redis.js
----
include::{sourceDir}/npm/redis.js[]
----

[[cli]]
== Ligne de commande

=== yargs-parser

https://npmjs.com/yargs-parser

=== args

https://www.npmjs.com/package/args

=== caporal

https://www.npmjs.com/package/caporal

=== promptly

https://www.npmjs.com/package/promptly

=== supports-color

https://www.npmjs.com/package/supports-color


== Applications web

Une majorité d'articles et de tutoriaux pour Node ont pour habitude
d'illustrer la création d'un serveur HTTP.
S'il est vrai que Node rend les interactions réseaux aisées grâce à
leur gestion non-bloquante, créer un serveur respectant réellement la
spécification du protocole HTTP est une autre paire de manches.

La plupart des modules n'imposant pas de choix d'architecture, vous aurez
souvent à composer vous-même votre application HTTP en fonction de vos besoins.

=== express

_express_ est probablement la librairie la plus populaire.
Elle gère le routage HTTP et la passation de données vers le moteur de rendu de votre choix.
Son système de _middlewares_


=== fastify

https://npmjs.com/fastify
https://npmjs.com/point-of-view

=== passport

_passport_ ([URL]#https://npmjs.com/passport#) est une librairie de gestion
d'authentification.
De nombreux modules complémentaires permettent de gérer une authentification
par mot de passe, par OAuth, par compte Google Apps etc.

Elle fonctionne particulièrement bien puisqu'elle n'impose pas de mécanisme
de persistence d'utilisateurs ni de session.



Référez-vous à sa documentation pour des exemples détaillés d'utilisation
et d'implémentation au sein de votre application.

=== restify

_restify_ ([URL]#https://npmjs.com/restify#) est une alternative à
_express_ si votre application n'a pour
seul but que d'exposer une API REST, sans rendu HTML ou nécessitant un
templating particulier.

Elle rend possible le débogage complet à partir de _dtrace_, la gestion
des versions d'API et expose un client permettant de consommer des données
sur d'autres API REST.

[source,javascript]
.npm/restify.js
----
include::{sourceDir}/npm/restify.js[]
----


=== faye

_faye_ ([URL]#https://npmjs.com/faye#) est à la fois un serveur et un client
de communication en temps réel entre un client et un serveur.
Il utilisera WebSocket, Ajax ou JSON-P selon les capacités technologiques du
client.

[source,javascript]
.npm/faye.js
----
include::{sourceDir}/npm/faye.js[]
----

Ce serveur extrêmement minimaliste expose un point d'entrée qui peut
être accédé via le client _Faye_, dans un navigateur web ou via un autre
script Node.

Tout message émit par un client sera relayé auprès des autres clients
connectés.
Un mécanisme de canaux et d'authentification vous permettra de canaliser
les messages en fonction des besoins de votre application.

=== swagger-client

=== elasticsearch


== Modules front-end et templating

Les librairies de templating proposent chacune à leur manière d'associer une structure de données à une logique de présentation.

Node n'y échappe pas bien sûr, mais a l'avantage de disposer de langages de templating fonctionnant aussi bien dans un environnement Node que dans des navigateurs Web.

Tous les exemples suivant généreront cette sortie HTML :

[source,html]
----
<!DOCTYPE html>
<html>
<head>
  <title>Template demo</title>
</head>
<body>
  <ul>
    <li>CSS maintenables</li>
    <li>Node.js</li>
    <li>Open Sky</li>
  </ul>
</body>
</html>
----

=== nunjucks

_nunjucks_ ([URL]#https://npmjs.com/nunjucks#) est un portage de _Jinja_,
librairie bien connue par les personnes développant en Python.
Sa syntaxe inclut des fonctionnalités comme les filtres, les blocs ou
l'héritage de gabarit.

[source,javascript]
.template.html
----
include::{sourceDir}/template.html[]
----

=== handlebars

_handlebars_ ([URL]#https://npmjs.com/handlebars#) et son prédécesseur _mustache_
sont les vétérans du templating Node.
Leur parti pris est de proposer le minimum de logique afin que celle-ci
reste au plus près des données.

_handlebars_ compile ou précompile les gabarits en des fonctions ECMAScript.

[source,javascript]
.template.hbs
----
include::{sourceDir}/template.hbs[]
----

Cela présuppose que les données adéquates soient passées à la fonction de template `Handlebars.template['template.hbs']`.

=== pug

_pug_ ([URL]#https://npmjs.com/pug#) s'inspire de _yaml_ en optant pour un
parti pris à base d'indentation et d'un balisage dépourvu de chevron.
Son mécanisme de blocs facilite la réutilisation de logiques d'affichage
au sein de votre application.

[source,javascript]
.template.pug
----
include::{sourceDir}/template.pug[]
----

=== ejs

_ejs_ ([URL]#https://npmjs.com/ejs#) part du principe qu'il n'y a pas besoin
d'un langage de templating autre qu'ECMAScript.
Donc c'est tout simplement ce qui vous sera proposé, impliquant de ce fait
une faible courbe d'apprentissage.

[source,javascript]
.template.ejs
----
include::{sourceDir}/template.ejs[]
----

=== react

_react_ ([URL]#https://npmjs.com/react#) est une librairie de présentation
essentiellement connue pour son approche efficace du côté des navigateurs Web.
Ce qui est moins connu en revanche est sa capacité à pouvoir également générer
du balisage côté Node et de servir de moteur de rendu pour des _frameworks_
comme _express_.

[source,javascript]
.template.jsx
----
include::{sourceDir}/template.jsx[]
----

=== storybook

https://github.com/storybooks/storybook + react

== Tester notre code

L'outillage permettant de tester vos applications est également richement fourni.
Il y a bien sûr de quoi couvrir les tests unitaires, générer des couverture de code, exécuter les tests dans différents navigateurs, tester vos API HTTP ou encore créer des _stubs_ et des _mocks_.

[TIP]
.[RemarquePreTitre]#Remarque# require('assert')
====
Node dispose du module `assert` ([URL]#https://nodejs.org/api/assert.html#).
Vous pouvez donc vous lancer dans vos premiers tests Node avec
ce module de base.

Une exception sera levée à chaque fois qu'une assertion ne sera pas satisfaite.
====

=== tape

_tape_ ([URL]#https://npmjs.com/tape#) est une librairie
d'exécution de tests et d'assertion minimaliste.
Elle se base sur la sortie de `console.log` pour
s'assurer de l'état global d'exécution des tests.

[source,javascript]
.npm/tape.js
----
include::{sourceDir}/npm/tape.js[]
----

=== sinon

_sinon_ ([URL]#https://npmjs.com/sinon#) est votre compagnon idéal pour
gérer _spys_, _stubs_ et _mocks_.
En d'autres termes, vous prenez la main sur des portions de votre propre
API pour vérifier que leur _comportement_ répond comme prévu aux signaux
de leur environnement.

_sinon_ peut étendre _chai_ via le module _sinon-chai_ ou être utilisé
directement avec le _framework_ de tests _buster_.

[source,javascript]
.npm/sinon.js
----
include::{sourceDir}/npm/sinon.js[]
----

=== nyc

_nyc_ ([URL]#https://npmjs.com/nyc#) génère une couverture de code en
inspectant le code exécuté par vos tests unitaires.
Les portions de votre applications ignorées par vos tests sont signalées
et une exception peut être lancée si un seuil de couverture n'est pas atteint.

.Résultat de couverture visualisée dans le terminal
image::images/nyc-cli.png[width="85%"]

_nyc_ se greffe sur n'importe quel librairie d'exécution de tests et se base
sur la librairie _istanbul_ ([URL]#https://npmjs.com/istanbul#) pour calculer
la couverture de code.

.Résultat de couverture visualisée dans un navigateur web
image::images/nyc-web.png[width="85%"]

=== karma

_karma_ ([URL]#https://npmjs.com/karma#) pilote l'exécution de tests unitaires
depuis un ou plusieurs navigateurs web.
Ces navigateurs peuvent tout aussi bien être ceux présents sur votre machine,
que des navigateurs résidant dans une VM ou exécutés à distance via des services
comme SauceLabs ou BrowserStack.

.Exemple d'exécution continues de tests avec Karma
image::images/karma.png[width="85%"]

=== supertest

_supertest_ ([URL]#https://npmjs.com/supertest#) est une librairie de tests
pour API HTTP.
Autrement dit, au lieu de tester directement le code de votre application,
vous testez le comportement de votre API au travers des codes HTTP et des
structures de données exposées.


=== eslint

_eslint_ ([URL]#https://npmjs.com/eslint#) teste la qualité de votre code et
signale des pratiques de programmation à risque.

Disponible via une invocation en ligne de commande, libre à vous de paramétrer
le comportement du _linter_ selon vos propres règles ou selon des règles
pré-établies, partagées sur le registre _npm_.

C'est un excellent moyen d'éviter des bugs tout en uniformisant vos pratiques
de codage au sein de vos applications.


== Objets connectés

=== nitrogen

_nitrogen_ ([URL]#https://npmjs.com/nitrogen#) est une plateforme permettant
de gérer les interactions entre différents périphériques, sur un même réseau
local et à travers Internet.

La librairie se base sur un mécanisme déclaratif de fonctionnalités et de
terminaux ainsi que la publication de messages.

=== serialport

_serialport_ ([URL]#https://npmjs.com/serialport#) est une librairie pour
communiquer avec tout appareil bénéficiant d'un port série et relié à un
périphérique via un port USB.

=== firmata

_firmata_ ([URL]#https://npmjs.com/firmata#) est un _firmware_, un protocole
de communication ainsi qu'une librairie de communication pour microcontrôleur
Arduino.
Le module Node communique via ce protocole avec un Arduino préalablement
flashé avec Firmata.

=== johnny-five

_johnny-five_ ([URL]#https://npmjs.com/johnny-five#) est une librairie
haut-niveau pour Arduino, Raspberry Pi et autres microcontrôleurs.
Son API expose des fonctionnalités de manipulations avancées pour simplifier
les interactions avec des moteurs, des servo-contrôleurs, des capteurs etc.

=== node-red

_node-red_ ([URL]#https://npmjs.com/node-red#) est une interface visuelle de
programmation d'objets connectés.
Le module Node démarre un serveur web dont l'interface a pour but de relier
des sources de données, des interactions possibles ainsi que les objets devant
recevoir les instructions.


== Accessibilité

=== a11y

=== chai-a11y

=== a11y.css

=== lighthouse

=== storybook-addon-a11y


== Travailler avec des images, des sons et des vidéos

=== sharp


=== wawoff2

[[av]]
=== av / mp3.js / aac.js

=== jsmediatags

=== video.js

=== hlsify
