:chapterNumber: 6
:sourceDir: ./examples
:sourceSample: TODO.js
:nodeCurrentVersion: v6
:nodeNextVersion: v7
:npmCurrentVersion: v4
:toc-title: Table des matières
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Héberger, déployer et monitorer

====
.Sommaire
- Considérations avant une mise en production
- Où héberger une application Node ?
- Déployer une application manuellement ou automatiquement
- S'assurer du bon fonctionnement d'une application
- Inspecter les erreurs et ralentissements d'une application
====

[abstract]
--
--

include::../resources/tip-versions.adoc[]
include::../resources/tip-examples.adoc[]

toc::[]

== Considérations avant une mise en production

Nous avons déjà vu dans le chapitre 2 <<../chapter-02/index.adoc#invoke,comment invoquer Node>>.
Cette section va nous aider à préparer notre application Node pour l'exécuter sur *d'autres environnements* que notre machine de développement sans changer une seule ligne de code.

Nous allons aussi nous interroger sur les raisons qui pourraient emmener une application à s'interrompre mais aussi comment confortablement *inspecter les problèmes* sur notre machine.

Enfin nous nous intéresserons aux différents mécanismes de *démarrage automatique* d'applications Node et aux actions renforçant leur *sécurité*.

=== Configuration

L'*environnement change entre notre machine de développement et la production*, le serveur de tests ou encore une plate-forme de services.
Le nom et paramètres d'accès à une base de données diffèrent, le système d'exploitation n'est pas le même ni même les codes d'accès pour accéder à certaines APIs.
Dans certains cas, nous n'avons même pas la main sur la décision d'un élément de configuration : il nous est fourni par l'environnement.
À nous donc de nous adapter.

Le premier élément que nous souhaitons maitriser est la *bonne version de Node* pour exécuter une application donnée.
Je recommande l'*utilisation d'un environnement par application* ou à défaut, d'une technologie de _conteneurs_ (comme LXC, Docker etc.) pour héberger plusieurs applications sur un même environnement.

Gérer plusieurs applications sur un même environnement implique soit de *_forcer_ toutes les applications* à se baser sur la même version de Node (mauvaise idée) soit à permettre à *chaque application d'expliciter sa préférence* (meilleure idée). +
Les _outils de gestion de version pour Node_ exposent justement un mécanisme pour indiquer la version désirée de *manière déclarative* via un fichier texte – ici, `.nvmrc` dans le cas de <<../chapter-02/index.adoc#nvm,nvm>> (cf. Chapitre 2).

.{empty}.nvmrc
----
include::.nvmrc[]
----

Les commandes exposées par _nvm_ ont _connaissance_ de la version de Node déclarée dans le fichier `.nvmrc`.
Elles s'adapteront à cette version sauf à demander une version explicite :

[subs="attributes"]
----
$ nvm install
$ nvm install {nodeNextVersion}
$ nvm run config/version.js
$ nvm run {nodeNextVersion} config/version.js
$ nvm exec npm start
----

Les cinq précédentes commandes permettent de :

. installer Node {nodeCurrentVersion} – version obtenue via `.npmrc` ;
. installer Node {nodeNextVersion} – version explicite ;
. exécuter le script `config/version.js` avec Node {nodeCurrentVersion} – version obtenue via `.npmrc` ;
. exécuter le script `config/version.js` avec Node {nodeNextVersion} – version explicite ;
. exécuter la commande `npm start` dans un environnement Node {nodeCurrentVersion}.

[CAUTION]
.[RemarquePreTitre]#Performance# Temps de démarrage
====
L'utilisation de _nvm_ entraine une pénalité d'environ _une seconde_ lors du _démarrage_ de l'application.
====

Nous n'avons certainement *pas envie de modifier le code* de notre application pour refléter ces différences.
C'est également l'*horreur de maintenir un fichier de configuration* par environnement.
Alors comment faire ?

L'utilisation de *variables d'environnement pour configurer une application* est la solution la plus aisée à implémenter.

Ces variables sont accessibles via l'objet `process.env` et ce, quel que soit le contexte d'exécution de Node.

L'exemple suivant décrit comment définir le _port réseau_ sur lequel écoutera le serveur HTTP.
Le numéro du port sera déterminé soit par le contexte d'exécution (_environnement de test_ ou _environnement de production_) soit par un numéro de port explicitement passée en tant que _variable d'environnement_.

[source,javascript]
.config/env.js
----
include::{sourceDir}/config/env.js[]
----
<1> Décompose `PORT` de `process.env` et si la clé n'existe pas, assigne la valeur de `defaultPort`.

Jouons avec le script `config/env.js` pour illustrer ces différents scénarios :

----
$ PORT=8000 node config/env.js     # <1>
$ NODE_ENV=test node config/env.js # <2>
$ node config/env.js               # <3>
----
<1> Affiche `En écoute sur http://localhost:8000` ;
<2> Affiche `En écoute sur http://localhost:3001` ;
<3> Affiche `En écoute sur http://localhost:3000`.

Le mécanisme des _variables d'environnement_ est détaillé dans la section <<../chapter-02/index.adoc#process-env,variables d'environnement>> du chapitre 2.

[TIP]
.[RemarquePreTitre]#À savoir# `NODE_ENV`
====
La variable d'environnement `NODE_ENV` a été adoptée par de nombreux outils et _frameworks_ pour déterminer le contexte d'exécution d'une application, effectuer des optimisations ou afficher des informations de débug supplémentaires.

Il est *recommandé d'utiliser `NODE_ENV=production`… en production*.

* `development` +
  C'est le contexte assumé par défaut lorsqu'une personne développe sur sa machine.
  Les exceptions sont affichées de manière verbeuse et du code supplémentaire .
  Des informations sensibles peuvent être contenues dans les traces d'erreurs ;
* `test` +
  C'est la valeur que l'on choisit pour exécuter des tests applicatifs, augmenter la verbosité des _logs_ et activer les _Source Maps_ pour faciliter le débogage de fichiers transpilés.
  Certains _frameworks_ de test et outils d'_intégration continue_ assignent cette variable d'environnement par défaut ;
* `production` +
  Les exceptions n'affichent pas de détails – il faut aller <<exceptions,inspecter les erreurs et exceptions>>, l'outillage d'introspection est désactivé et la verbosité des _logs_ est supposée être moins verbeuse.
  On constate généralement des *améliorations de performance*.
====

Opter pour un fichier de configuration fait sens si de nombreux paramètres sont à fournir à l'application — ou si certains de ces paramètres impliquent des arborescences d'objets ou de tableaux ECMAScript.

Plusieurs stratégies s'offrent à vous :

- un *fichier unique* pour éviter les valeurs en dur dans le code ;
- un *fichier par environnement d'exécution* (test, préprod, production etc.) ;
- un *fichier par domaine d'application* (base de données, backend, frontend API etc.).

Cette liste n'est pas exhaustive – l'essentiel étant de facilement maintenir ce ou ces fichiers.

Commençons par l'approche par environnement d'exécution, reposant sur la notion d'un fichier de configuration par environnement.

[source,javascript]
.config/file.js
----
include::{sourceDir}/config/file.js[]
----

Ainsi, un appel au module précédent chargera :

- `production.json` lors du premier appel ;
- `dev.json` lors du second appel ;
- `test.json` lors du premier appel si `NODE_ENV=test` ;
- `dev.json` lors du second appel si `NODE_ENV=test`.

[TIP]
.[RemarquePreTitre]#npm# Le module nconf
====
Des modules comme _nconf_ proposent des abstractions gérant de multiples cas de figure.

Ils vont jusqu'à la prise en charge des notions d'héritage et de cascade pour faciliter la maintenance et ne gérer que les différences entre environnement, plutôt que d'avoir à tout spécifier à chaque fois.

- [URL]#https://npmjs.com/nconf#
====

Une autre approche, tout aussi voire plus simple consiste à réutiliser le fichier `package.json` en y ajoutant des propriétés supplémentaires.

[source,javascript]
.config/file-package.js
----
include::{sourceDir}/config/file-package.js[]
----
<1> Affiche `{ port: '3000' }`.

On peut également se passer de l'étape `require()` si l'on invoque un <<../chapter-02/index.adoc#npm-scripts,script npm>> (cf. chapitre 2) :

[source,javascript]
.config/file-npm.js
----
include::{sourceDir}/config/file-npm.js[]
----

npm aplatira la structure d'objet du fichier `package.json` et séparera chaque niveau de profondeur par le caractère `_`, le préfixera par `npm_package_` et l'injectera dans l'objet `process.env`. +
Par exemple, `require('./package.json').config.port` sera accessible via `process.env.npm_package_config_port`.

----
$ node config/file-npm.js     # <1>
$ npm run display-config/port # <2>
----
<1> Affiche `undefined` ;
<2> Affiche `3000`.

On comprend ainsi que l'exposition du contenu du fichier `package.json` sous forme de variables d'environnement est l'œuvre de la commande npm.

[TIP]
.[RemarquePreTitre]#Astuce# Combinaison avec les variables d'environnement
====
Un bon moyen de ne pas inscrire en dur l'emplacement d'un fichier de configuration est encore d'indiquer son emplacement via une variable d'environnement :

----
CONFIG_FILE=~/.secured/config.json node app.js
----
====

=== Persistance des données

TBD.

=== Causes et raisons d'un plantage applicatif

TBD.

////
* erreur de syntaxe dans module chargé
* erreur de runtime
** utilisation structure inexistante (variable indispo, opération)
** exception qui n'est pas gérée
** effet de bord d'un module tiers
**
* ressource liée qui devient indisponible (bdd, mémoire, disque, connexion réseau)
** parce que notre application mange les ressources
** système mal configuré (rotation de logs etc.)
////

=== Déboguer une application Node

TBD.

////
- require('debug')
- node --inspect
- devtool
////

=== Principes de sécurité

TBD.

////
- http://nodegoat.herokuapp.com/tutorial
- permissions d'exécution du processus
////

=== Démarrage automatique

[[system]]
==== Intégration en tant que service système

TBD.

_Upstart_ est l'outil de gestion de processus de la distribution Linux Ubuntu.
Sa configuration est une des plus faciles à apprendre :

[source]
./etc/init/your-app
----
start on runlevel [2345] and net-device-up IFACE=eth0

exec /usr/bin/node /path/to/your/app.js
----

Cette configuration ultra simpliste décrit la commande à exécuter et quand lancer automatiquement le service.
Dans ce cas, au démarrage du système, une fois le réseau disponible sur l'interface `eth0`.

[TIP]
.[RemarquePreTitre]#Outil# Upstart
====
Une introduction ainsi qu'une documentation détaillée d'_Upstart_ est disponible à l'adresse suivante :

- [URL]#https://doc.ubuntu-fr.org/upstart# (en français)
- [URL]#http://upstart.ubuntu.com/cookbook/# (en anglais)
====

L'apprentissage et le débogage de tels scripts peut se révéler fastidieuse et rébarbative… _foreman_ dispose d'une fonctionnalité d'export adressant le problème.
Pensez-y !

[[application-manager]]
==== Serveur d'applications web

TBD.

////
- Phusion Passenger
////

[[process-manager]]
==== Démarrage avec un gestionnaire de processus

TBD.

////
- Strongloop Process Manager
- PM2
////

[[hosting]]
== Héberger une application Node

=== Directement sur le port 80 ou 443

TBD.

////
tl;dr ne pas le faire
////

[[reverse-proxy]]
=== Reverse Proxy

TBD.

////
- Apache
- nginx
////

[[shared-hosting]]
=== Hébergement mutualisé

TBD.
////
- Alwaysdata
////

[[paas]]
=== Plate-forme de services (_Platform as a Service_)

TBD.

////
- Heroku
- Clever Cloud
////

_Foreman_ est un programme écrit en Ruby.
Il est destiné à gérer les multiples processus d'une même application. +
C'est l'outil de déclaration de services utilisé par la plateforme _Heroku_.

Vos différents processus sont à déclarer dans un fichier `Procfile`, somme toute assez simpliste :

[source]
.Procfile
----
web: node www.js
api: PORT=$PORT node api.js
worker: node bin/cli.js --retries 3
----

Le précédent exemple fait état de trois processus à démarrer, dont certains avec des arguments spécifiques.

La commande suivante démarrera ces trois services, créera deux processus pour le module `api.js` en leur attribuant automatiquement un port différent grâce à :

----
foreman start -c api=2
----

[TIP]
.[RemarquePreTitre]#Outil# foreman
====
D'autres fonctionnalités et paramètres de configuration sont expliqués dans la documentation officielle du projet :

- [URL]#https://ddollar.github.io/foreman/#
- [URL]#https://devcenter.heroku.com/articles/getting-started-with-nodejs#define-a-procfile#
====

[[aws]]
=== Amazon Web Services (_AWS_)

TBD.

////
- AMI EC2
- Beanstalk
////

[[lambda]]
=== Invocation éphémère (_Function as a Service_)

TBD.

////
- Lambda
////

[[deploy]]
== Déployer une application Node

////
Préciser que pour aller rapidement faut aller sur le PaaS (git push)
////

[TIP]
.[RemarquePreTitre]#npm# --production
====
Si vous suffixez la commande `npm install` avec l'option `--production`, toutes les dépendances seront installées à _l'exception_ de celles listées en tant que _devDependences_.

Il s'agit d'un moyen d'installer moins de dépendances lors d'une livraison — à condition de ne pas avoir besoin de l'outillage de tests.
====

[[automated-deploy]]
=== Déploiement automatisé

TBD.


[[immutable-deploy]]
=== Déploiement immutable

TBD.

////
- deb/etc.
- `slc build`
- tar
////

[[private-npm]]
=== Dépendances _npm_ privées

TBD.

////
- git+ssh
- private npm
////

=== Scripter le scénario de déploiement Node

TBD.

////
- Ansible
////

[[database-migration]]
=== Migration de base de données

TBD.

== Monitorer et déboguer une application

Cette section s'intéresse à la *détection proactive des incidents* et au *suivi de la santé de notre application* une fois mise en ligne.
Nous allons ainsi apprendre à *dresser un diagnostic sans nous connecter* sur la ou les machines hébergeant l'application… en partie car nous n'y avons pas toujours accès.
Et c'est tant mieux.


[[healtcheck]]
=== Surveiller la santé de l'application

TBD.

////
webping
Nagios
////

[[exceptions]]
=== Déceler les erreurs et exceptions

TBD.

[[performance]]
=== Identifier les problèmes de performance

TBD.

[[security]]
=== Se tenir à jour des alertes de sécurité

Il existe quatre niveaux où des failles de sécurité peuvent s'immiscer :

* *notre propre code* +
  Des revues de code, une amélioration de vos connaissances et la commande d'audits nous aideront à identifier les possibles failles et vulnérabilités ;
* *nos dépendances* +
  Mais aussi dans les dépendances de nos dépendances ;
* *Node* +
  Le code de certains modules Node – ou leur intégration avec un système d'exploitation spécifique – contient des failles ou fuites mémoire qui sont corrigées au fil des versions ;
* *dépendances de Node*
  Il est arrivé à plusieurs reprises que des vulnérabilités soient décelées dans _libuv_, _OpenSSL_ ou _V8_ — seule une mise à jour de Node peut mettre à ces dépendances.

On n'oubliera pas les vulnérabilités liés à notre système d'exploitation et celui de nos serveurs de production ainsi qu'à leur exposition au monde extérieur.

Plusieurs canaux sont à notre disposition pour être notifié très rapidement de mises à jour correctives :

* *Failles de sécurité de modules npm* : [URL]#https://nodesecurity.io/advisories# — et son flux RSS [URL]#https://nodesecurity.io/rss.xml# ;
* *Failles de sécurité de Node* : son flux RSS [URL]#https://nodejs.org/en/feed/vulnerability.xml# ;
* *Mises à jour de Node* : [URL]#https://nodejs.org/en/blog/# — et son flux RSS [URL]#https://nodejs.org/en/feed/blog.xml#.

////
- https://snyk.io/
- https://nodesecurity.io/
- greenkeeper
////

=== Tester la montée en charge

TBD.

////
minigun
////

== Conclusion

TBD.
