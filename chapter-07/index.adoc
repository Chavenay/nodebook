:chapterNumber: 7
:chapterId: chapter-07
:sourceDir: ./examples
:serverUrl: http://localhost:4000
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Créer une application web

TBD.

====
.Sommaire
- TBD.
====

[abstract]
--
TBD.
--

include::../docs/tip-versions.adoc[]

Une application web est une *construction applicative qui est à l'écoute*
de connexions réseaux initiées par un client.
Elle est structurée autour de la lecture d'une requête entrante (lecture)
et l'émission d'une réponse sortante (écriture).
Chaque *requête porte en elle une intention* — un chemin d'accès, une préférence
de format, des éléments d'identification — et implique une réponse en retour
— des données et des éléments pour les contextualiser.

L'ingéniérie d'une application web consiste à comprendre les requêtes entrantes
et à construire une réponse appropriée à chaque fois, le plus rapidement possible.

Ce chapitre s'inscrit dans la continuité du
<<../chapter-04/index.adoc#http,module `http`>> (re)découvert au cours du
<<../chapter-04/index.adoc#,chapitre 4>>.

////
# Et si je devais créer un serveur web, comment ça se passe ?
- distingo serveur web/serveur http ? (pas sûr que ça vaille le coup/coût à ce stade là)
- c'est quoi cette histoire d'ouvrir un port pour lancer un serveur ?

- dans le cas de formulaire, le client _envoie_ des informations en même temps que la requête
  - comme on est dans un format texte, il faut l'interpréter le parser

- les trucs auxquels il faut faire gaffe
  - qu'est-ce qui occupe de la mémoire ?
  - ça a d'autant plus d'impact qu'on est sur des processus longs (aka programme qui tourne en continu — le serveur web)
  - donc si on nettoie pas (ce qu'on ouvre, si on charge tout d'un coup), les ressources disponibles diminuent jusqu'au plantage
////

[NOTE]
.[RemarquePreTitre]#Documentation# Entêtes HTTP
====
Ce chapitre fait souvent référence à des entêtes HTTP.
La documentation _MDN web docs_ ([URL]#https://developer.mozilla.org/fr/docs/Web/HTTP/Headers#)
les liste toutes, avec le détail de leurs valeurs possibles.

C'est un onglet intéressant à ouvrir en parallèle de cette lecture
— je l'ai ouvert en permanence pour écrire ce chapitre.
====

== Composer son application web

Dans cette première section, nous allons nous focaliser sur la construction
d'une application web avec une approche modulaire.
Nous partirons du concept de requête et de réponse
Petit à petit, nous allons greffer des modules pour comprendre et
donner du sens à leur contenu respectif.

Le _protocole HTTP_ est le dialecte informatique utilisé et compris pour exprimer
les requêtes (émises par un client) et les réponses (émises par un serveur).
Les navigateurs web sont des clients tandis que notre application Node est un serveur.

Le logiciel _curl_ ([URL]#https://curl.haxx.se#) est un client en ligne de commande.
Il est souvent installé par défaut sur les distributions Linux, sur macOS et
à partir de Windows 7 — via le terminal _PowerShell_.

Utilisons _curl_ pour observer le contenu d'une requête et sa réponse.

.Exemple de requête HTTP vers le site [URL]#perdu.com#.
----
$ curl -v http://perdu.com  # <1>
GET / HTTP/1.1              # <2>
Host: perdu.com             # <3>
User-Agent: curl/7.54.0
Accept: */*
----
<1> Exécution de la requête.
<2> Expression de la méthode, du chemin d'accès demandé et du protocole de discussion employé — ici, le protocole HTTP dans sa version `1.1`.
<3> Entête de requête.

Une entête est exprimée sous la forme `Clé: Valeur`.
Chaque entête précise un élément de contexte.
Certaines entêtes influencent plus que d'autres la réponse du serveur, si
celui-ci la comprend.

Voyons maintenant la réponse.

.Exemple de réponse HTTP transmise en retour.
----
HTTP/1.1 200 OK                                       # <1>
Date: Thu, 28 Jun 2018 19:02:27 GMT                   # <2>
Server: Apache
Last-Modified: Thu, 02 Jun 2016 06:01:08 GMT
ETag: "cc-5344555136fe9"
Accept-Ranges: bytes
Content-Length: 204
Vary: Accept-Encoding
Content-Type: text/html                               # <3>

&lt;html>&lt;head>&lt;title>Vous Etes Perdu ?&lt;/title> …&lt;/html> # <4>
----
<1> Expression du statut de la réponse avec un code numérique et une version intelligible.
<2> Entête de réponse.
<3> Entête de réponse — celle-ci indique au client comment interpréter le corps du message.
<4> Corps du message.

La réponse dispose elle aussi d'entêtes.
Cette fois, elles guident le client dans son interprétation du résultat.
Le corps du message est séparé par une ligne vide.
C'est la partie visible de la réponse dans un navigateur web, c'est le contenu
qui s'affiche sous nos yeux.

Dans la prochaine section, nous allons visualiser ces mêmes informations
à partir d'un serveur HTTP que nous allons créer par nous-même.
Nous retracerons plus en détail l'odyssée d'une requête HTTP dans la section
<<http,Comprendre le modèle HTTP>>, en fin de chapitre.

include::../docs/tip-examples.adoc[]

[[server]]
=== Démarrer un serveur HTTP

Nous l'avons vu juste avant : une requête HTTP envoyée vers un hôte
renvoie une réponse.
Cet hôte doit au préalable avoir installé et démarré un serveur HTTP qui
écoute ces demandes.

Le script d'exemple `server/start.js` répond à ce besoin.
Une fois démarré, il est joignable à l'adresse `{serverUrl}`.
Il affichera alors les entêtes des requêtes et de leur réponse :

----
$ node server/start.js
----

[source%interactive%endpoint,javascript]
.server/start.js
----
include::{sourceDir}/server/start.js[]
----
<1> Comme nous retournons du HTML au client, nous explicitons le type de contenu retourné en réponse.
<2> Affiche les entêtes de la requête reçue par le serveur — le contenu varie selon le client utilisé.
<3> Affiche les entêtes de la réponse — en l'occurence `{ 'content-type': 'text/html' }`.

Nous avons composé la fondation minimum pour créer une application web
en étant en mesure d'accepter des requêtes et de répondre, quelque chose
d'arbitraire certes mais quelque chose qui est compris par un navigateur web.

*Pourquoi avoir démarré le serveur sur le port 4000* dans l'exemple précédent ?
C'est un choix arbitraire de ma part : nous pouvons démarrer un serveur HTTP
sur n'importe quel port tant qu'il est libre et supérieur ou égal à 1000.
Quand on cherche à se connecter à une adresse comme `http://localhost` (HTTP)
ou `https://localhost` (HTTPS), la valeur du port vaut implicitement 80 et 443,
respectivement.

Le module npm _get-port_ ([URL]#https://npmjs.com/get-port#) retourne
un numéro de port parmi ceux disponibles sur le système d'exploitation.

----
$ node server/port.js
http://localhost:51765
----

[source%interactive,javascript]
.server/port.js
----
include::{sourceDir}/server/port.js[]
----
<1> Exprime une préférence pour retourner le port 4000 s'il est disponible.
<2> Affiche `{serverUrl}` si le port est disponible, sinon un autre nombre s'affichera à la place.
<3> Le serveur se met à l'écoute sur ce port.

Pour vous en rendre compte, démarrez le script `server/start.js` pour utiliser
le port 4000 et démarrez ensuite `server/port.js`.

[[path]]
=== Répondre à un chemin (_routing_)

Nous avons vu qu'une URL est un identifiant qui se décompose en plusieurs
parties grâce au <<../chapter-04/index.adoc#url,module `url`>>
(cf. <<../chapter-04/index.adoc#,chapitre 4>>).
Une de ces parties est le _chemin d'accès_ à une ressource. +
Par exemple, le chemin de l'URL `{serverUrl}/coucou` est `/coucou`.

----
$ node path/request-url.js
----

[source,javascript]
.path/request-url.js
----
include::{sourceDir}/path/request-url.js[]
----
<1> Affiche un message spécifique au chemin `/`.
<2> Affiche un autre message spécifique au chemin `/coucou`.

Les deux seules ressources mises à disposition sur `http://localhost:4000`
sont accessibles avec les chemins `/` et `/coucou`.
Tout autre chemin n'aboutira pas.

C'est d'ailleurs un problème puisqu'en réalité, nous n'envoyons pas de réponse
pour un chemin inconnu.
Et c'est à nous de gérer ce cas de figure :

----
$ node path/404.js
----

[source,javascript]
.path/404.js
----
include::{sourceDir}/path/404.js[]
----
<1> Seul le chemin `/` est disponible dans l'application.
<2> Le code HTTP de la réponse est réglé sur `404`.
<3> Une page introuvable peut quand même retourner du contenu.

La prise en compte d'une ressource inconnue à notre application fait émerger
un nouveau concept : le _statut de la réponse_.
Ce statut est un code numérique qui donne des indications sur la ressource retournée.
Dans ce cas de figure le statut `404` de la réponse indique au client de
ne pas considérer le contenu comme celui qui était demandé. +
Par défaut et sauf mention contraire, le statut est `200`.

[format="csv", options="header", cols="1,2,4"]
.Principaux codes HTTP et leur signification.
|===
Code, Raison, Explication
`200`, `OK`, La ressource demandée est retournée en réponse.
`301`, `Moved Permanently`, La ressource demandée a été déplacée.
`304`, `Not Modified`, La ressource n'a pas été modifiée depuis la dernière fois.
`400`, `Bad Request`, La requête est incomplète ou incompréhensible par le serveur.
`401`, `Unauthorized`, La ressource est accessible sur preuve d'identification.
`403`, `Forbidden`, L'accès à la ressource est interdit.
`404`, `Not Found`, La ressource n'existe pas.
`500`, `Internal Server Error`, Le serveur distant est en erreur.
|===

Les statuts HTTP sont importants dans la création d'applications web.
Leur code permet de vérifier que le client et le serveur se sont bien compris. +
Si une page d'erreur est affichée avec un statut `200`, le client sera dans
l'impossiblité de deviner qu'il ne s'agit pas du contenu attendu.

[options="header", cols="1,1,4"]
.D'autres codes HTTP utiles à connaître.
|===
| Code | Raison | Explication
| `201` | `Created` | La ressource demandée a été créée.
| `202` | `Accepted` | La demande a été acceptée et la ressource sera disponible ultérieurement.
| `204` | `No Content` | La ressource demandée n'a pas de contenu.
| `302` | `Found` | La ressource demandée est temporairement disponible à une autre adresse.
| `503` | `Service Unavailable` | Le serveur distant répond qu'il n'est pas disponible pour l'instant.
|===

Une application web devient vite compliquée à se gérer si nous avons à lister
tous les chemins possibles.
C'est à ce moment qu'entre en jeu le _routing_, une technique pour décrire
des chemins d'accès au lieu de s'embourber dans une longue liste de `if/else`.

Nous utilisons le module npm _find-my-way_ ([URL]#https://npmjs.com/find-my-way#)
pour transformer l'exemple `path/request-url.js`
en quelque chose de plus modulaire :

----
$ node path/routes.js
----

[source,javascript]
.path/routes.js
----
include::{sourceDir}/path/routes.js[]
----
<1> Création de la table de routage.
<2> Définition de la réponse du chemin d'accès `/`.
<3> Définition de la réponse du chemin d'accès `/coucou`.
<4> Intégration du routeur aux requêtes entrantes du serveur HTTP.

Les routeurs commencent à nous vraiment nous faire gagner du temps
lorsqu'il s'agit d'extraire des informations utiles depuis le chemin et
de les gérer dynamiquement :

----
$ node path/route-params.js
----

[source,javascript]
.path/route-params.js
----
include::{sourceDir}/path/route-params.js[]
----
<1> Création d'une route paramétrée — le symbole `:word` est accessible dans le troisième argument, en tant que `params.word`.
<2> Affiche une phrase composée avec le paramètre de notre route.

Dirigez vous vers `{serverUrl}/hello/word` pour voir le résultat s'afficher.
Changez le dernier segment du chemin pour observer le changement.

Ce mécanisme est utile pour relier un identifiant à un enregistrement précis
en base de données, par exemple.
Il se complète avec les <<argument,arguments d'URL>> pour véhiculer des
éléments optionnels — nous en parlons quelques sections plus loin.

[CAUTION]
.[RemarquePreTitre]#Sécurité# Filtrer les données entrantes
====
C'est le moment de rappeler que *toute information saisie par l'utilisateur*
doit être filtrée et nettoyée avant d'être utilisée.
L'exemple `path/route-params.js` n'est pas sécurisé ; vous vous en rendrez
compte en visitant [URL]#{serverUrl}/hello/<script>alert(h4ck)<%2Fscript>#. +
Ce type de failles s'exploite pour faire fuiter des données confidentielles.

Nous verrons tous ces aspects plus en détail dans la section
<<security,protéger l'application>>.
====

Enfin, les routeurs contextualisent les actions à effectuer vis à vis d'une
ressource grâce au _verbe HTTP_.
Le verbe communique une intention — récupération, mise à jour, suppression.
Le routeur organise notre code pour déclencher une action adaptée
à la méthode employée :

----
$ node path/method.js
----

[source,javascript]
.path/method.js
----
include::{sourceDir}/path/method.js[]
----
<1> Définition du chemin d'accès `/` — verbe `GET` (récupération).
<2> Définition du chemin d'accès `/` — verbe `HEAD` cette fois.
<3> La méthode `response.writeHead` est un moyen de définir le statut en même temps que les entêtes de réponse.
<4> Définition d'une entête personnalisée — le préfixe `X-` indique qu'elle n'est pas liée au standard HTTP.
<5> Écriture du corps du message — nous verrons qu'il est ignoré et n'est pas transmis au client.

Les navigateurs web affichent seulement notre route `GET` car c'est
leur fonctionnement par défaut.
Ils comprennent le verbe `POST` pour <<upload,uploader des fichiers>> ou
<<post,transmettre des formulaires>>. +
Tournons-nous à nouveau vers le programme `curl` pour observer les différences
entre la réponse nos deux verbes HTTP `GET` et `HEAD` :

[subs="+attributes"]
----
$ curl {serverUrl}
Bienvenue
$ curl <i>--head</i> {serverUrl}
HTTP/1.1 200 OK
<i>X-Jobs: https://jobs.humancoders.com</i>
Date: Sun, 01 Jul 2018 15:43:56 GMT
Connection: keep-alive
----

L'utilisation de `HEAD` renvoie uniquement les entêtes de réponse et nous
économise la <<templating,génération d'un gabarit>>.
D'un point de vue client, le verbe `HEAD` aide à inspecter des ressources
sans avoir à télécharger le contenu — ce sont autant de kilo ou méga-octets
d'économisés.

[options="header", cols="1,4"]
.Principaux verbes HTTP et leur utilisation.
|===
| Verbe | Description
| `GET` | Récupération d'une ressource.
| `HEAD` | Récupération d'une ressource — seulement les entêtes.
| `POST` | Création d'une ressource.
| `PUT` | Mise à jour d'une ressource.
| `PATCH` | Mise à jour _partielle_ d'une ressource.
| `DELETE` | Demande de suppression d'une ressource.
|===

La responsabilité de comprendre ces verbes revient à notre application.
C'est donc à nous de leur associer une action pour les prendre en charge.

[TIP]
.[RemarquePreTitre]#Pratique# Relancer le serveur automatiquement
====
Vous avez essayé de modifier un des exemples précédents pendant que le script
était lancé et vous avez remarqué que _rien ne changeait_ ?

C'est normal, le code exécuté est tel qu'au moment où il a été interprété par
Node à son lancement.
La section <<dev,relancer le serveur automatiquement>> nous donne une piste
pour y remédier.
====

[[static]]
=== Répondre avec des fichiers statiques

Les <<path,chemins d'accès>> s'associent aussi à des fichiers statiques.
Ainsi, une URL correspond un fichier placé sur notre disque dur.
J'ai placé 3 fichiers de différente nature (texte, image, PDF) pour illustrer
les exemples de cette section.

----
$ tree -a static/files
static/files
├── .eslintrc.yaml
├── doc.pdf
└── screenshot.jpg
----

Nous allons commencer par mettre à disposition un seul fichier, quel que soit
le chemin demandé :

----
$ node static/routes.js
----

[source,javascript]
.static/routes.js
----
include::{sourceDir}/static/routes.js[]
----
<1> Nous constituons un chemin d'accès avec `path.join` — cf. <<../chapter-04/index.adoc#path,chapitre 4>>, module `path`.
<2> Nous créons un flux de lecture vers ce fichier — cf. <<../chapter-04/index.adoc#stream,chapitre 4>>, module `stream`.
<3> Nous redirigeons le flux de lecture vers la réponse.

Ce que cet exemple nous apprend,
c'est que l'*objet de réponse est aussi un flux d'écriture*.
Peu importe le volume du fichier, l'envoi se régulera en fonction de la capacité
de téléchargement du client et en consommant le minimum de mémoire possible.
La lecture sera interrompue si le client annule le téléchargement.

Nous pouvons à présent étendre ce savoir nouvellement acquis en
<<path,routant un chemin d'accès>> vers le répertoire qui contient nos fichiers.

----
$ node static/routes.js
----

[source,javascript]
.static/routes.js
----
include::{sourceDir}/static/routes.js[]
----
<1> Création d'une route paramétrée qui répond avec la fonction `staticFiles`.
<2> Réutilisation de la fonction `staticFiles` pour répondre à la méthode `HEAD` — nous verrons plus loin pourquoi c'est important.
<3> Composition dynamique du chemin d'accès au fichier.
<4> Comme toute à l'heure, nous redirigeons le flux de lecture du fichier vers la réponse.

Si nous accédons à `{serverUrl}/files/doc.pdf` et `{serverUrl}/files/screenshot.jpg`,
nous verrons les deux documents s'afficher dans notre navigateur.
Un problème cependant : l'accès à un chemin inconnu fait planter l'application.

Notre approche est un peu trop naïve en regardant les entêtes
de réponse d'un peu plus près :

----
$ curl --head 'http://localhost:4000/files/doc.pdf' # <1>
HTTP/1.1 200 OK
Date: Mon, 02 Jul 2018 15:47:33 GMT
Connection: keep-alive
----
<1> C'est pour exécuter cette commande que j'ai ajouté l'écoute de la méthode `HEAD`.

En fait, nous gagnerions à documenter la ressource en transmettant
des entêtes supplémentaires.
La question est : lesquelles ?

[CAUTION]
.[RemarquePreTitre]#Sécurité# Filtrer les données entrantes
====
*Toute information saisie par l'utilisateur* doit être filtrée et nettoyée avant
d'être utilisée.
L'exemple `static/routes.js` n'est pas sécurisé ; vous vous rendrez
compte en visitant [URL]#{serverUrl}/files/..%2F..%2Fhello.js# que ce chemin
permet de remonter jusqu'à un fichier situé hors du répertoire `static/files`. +
Ce type de faille s'exploite pour accéder aux données confidentielles de notre
système d'exploitation.

Nous verrons tous ces aspects plus en détail dans la section
<<security,protéger l'application>>.
====

Nous allons nous baser sur le module npm _send_ ([URL]#https://npmjs.com/send#)
pour améliorer l'exemple précédent et constater par nous-même quelles
entêtes sont utiles.

----
$ node static/send.js
----

[source,javascript]
.static/send.js
----
include::{sourceDir}/static/send.js[]
----
<1> En utilisant la syntaxe `*`, le routeur accepte une arborescence de chemins — `doc.pdf` tout comme `un/long/chemin.pdf`.
<2> L'arborescence se récupère avec un paramètre du même nom — `*`.
<3> Le module _send_ prend en charge la suite de la transmission.

Pas de grands bouleversements donc.
Si ce n'est que les fichiers inexistants ne font plus planter l'application
et que les entêtes de réponses sont plus fournies qu'avant :

----
$ curl --head 'http://localhost:4000/files/doc.pdf'
HTTP/1.1 200 OK
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Tue, 12 Jun 2018 08:02:40 GMT
ETag: W/"10c5d-163f304b0d2"
Content-Type: application/pdf
Content-Length: 68701
Date: Mon, 02 Jul 2018 15:52:18 GMT
Connection: keep-alive
----

Parmi les entêtes les plus importantes, nous trouvons `Content-Type`,
`Content-Length` et `Last-Modified`.
Elles aident le client à interpréter ou représenter le contenu de manière optimale,
à informer de la taille du contenu (utile à l'animation de la barre de
téléchargement du navigateur web) et à distinguer l'ancienneté du fichier.

[options="header", cols="1,3"]
.Entêtes de réponse utiles pour transmettre des fichiers.
|===
| Entête                | Utilité
| `Content-Type`        | Explicite la nature du contenu mis à disposition.
| `Content-Disposition` | Indique si le contenu doit être affiché dans le client ou téléchargé sous un nom particulier.
| `Cache-Control`       | Active ou désactive la mise en cache de ce fichier par le client.
| `Last-Modified`       | Indique la date de dernière modification du contenu.
| `Content-Length`      | Indique la longueur (en octets) du contenu.
| `Content-Encoding`    | Indique le mode de compression utilisé pour transmettre les données.
| `Accept-Ranges`       | Indique la possibilité ou non de reprendre un téléchargement ou d'en choisir un segment avec l'entête de requête `Range`.
|===

[TIP]
.[RemarquePreTitre]#Performance# Utiliser Apache ou nginx en production
====
Si Node s'en sort bien pour envoyer des fichiers vers le client,
les serveurs web _Apache_ et _nginx_ sont encore plus performants à ce niveau.
C'est quelque chose à considérer si votre application sert principalement
des fichiers statiques.

Lisez le <<../chapter-06/index.adoc#,chapitre 6>> pour apprendre à configurer
Node derrière un autre serveur web.
====

[[arguments]]
=== Réagir aux arguments d'URL

Les arguments d'une URL servent à *affiner le contexte d'affichage* d'une
ressource donnée.
Ces options servent par exemple à paginer du contenu ou spécifier une dimension,
un filtre d'affichage ou encore une expression de recherche.
En clair, elles servent à influencer la représentation d'une ressource
ou information.

Par défaut, les arguments sont représentés de manière textuelle avec
le chemin d'accès, dans l'attribut `request.url` :

----
$ node arguments/intro.js
----

[source,javascript]
.arguments/intro.js
----
include::{sourceDir}/arguments/intro.js[]
----
<1> La page demandée affiche l'attribut de requête `url`.

Nous voyons s'afficher `/test?cle=valeur&option` en nous rendant à l'adresse
`{serverUrl}/test?cle=valeur&option`.
Ce n'est pas utilisable en l'état.

Le <<../chapter-04/index.adoc#url,module `url`>>
(cf. <<../chapter-04/index.adoc#,chapitre 4>>) entre en jeu.
En plus de destructurer une URL entière, il sait aussi décomposer les options
et les transformer en un objet utilisable côté Node :

----
$ node arguments/parse.js
----

[source,javascript]
.arguments/parse.js
----
include::{sourceDir}/arguments/parse.js[]
----
<1> Le deuxième argument de la fonction `url.parse` décompose les arguments, disponibles dans l'attribut `query` de l'objet retourné.
<2> L'attribut `search` correspond aux arguments, sous forme textuelle.
<3> L'attribut `query` est un objet — ici, transformé pour être affiché dans la page sous forme de texte.

Cette fois, nous voyons s'afficher `{"cle": "valeur", "option": ""}` dans notre
navigateur lorsque nous nous rendons sur `{serverUrl}/test?cle=valeur&option`.
C'est tout ce qu'il nous fallait pour l'utiliser dans notre application.

----
$ node arguments/format.js
----

[source,javascript]
.arguments/format.js
----
include::{sourceDir}/arguments/format.js[]
----
<1> Nous rentrons dans ce bloc en présence de l'argument d'URL `format=svg`.
<2> Une entête `Content-Type` fait que le contenu est interprêté (et affiché) comme du HTML — en retirant cette ligne, le document sera alors téléchargé.
<3> Sinon, le reste du temps nous affichons la date telle quelle, en tant que texte.

Les deux URL `{serverUrl}/date?format=svg` et `{serverUrl}/date` font
référence à une même ressource mais l'affichage s'adapte au contexte.

[options="header"]
.Exemples d'arguments et de leur représentation en structure ECMAScript.
|===
| Argument            | Représentation
| `?cle=valeur`        | `{cle: "valeur"}`
| `?cle`               | `{cle: ""}`
| `?cle[]=1&cle[]=2`   | `{cle: [1,2]}`
|===

[TIP]
.[RemarquePreTitre]#Performance# Module npm _parseurl_
====
Si vous êtes à la recherche de performance, le module npm _parseurl_
([URL]#https://npmjs.com/parseurl#) retourne les mêmes résultats
tout en étant jusqu'à 10 fois plus rapide que le module natif à Node.
====

[[post]]
=== Interpréter un corps de message (`POST`, `PUT`)

- JSON
- formulaire


[[upload]]
=== Uploader des fichiers

- solo
- plusieurs (multipart)

[[cookies]]
=== Créer un lien avec le client avec les cookies

[options="header", cols="2,3a,3"]
.Entêtes de réponse
|===
| Entête          | Valeurs possibles | Utilité
| `Set-Cookie`  |   |
|===

[options="header", cols="2,3a,3"]
.Entêtes de requête
|===
| Entête          | Valeurs possibles | Utilité
| `Cookie`  |   |
|===

[options="header", cols="1,2,4a"]
.Directives complémentaires à la valeur d'un cookie.
|===
| Directive | Exemple | Explication
| `Max-Age` | `Max-Age=3600` | Durée de vie du cookie en secondes. +
Si le nombre est inférieur ou égal à zéro, le cookie est supprimé. +
Si cette valeur n'est pas préciée, le cookie est supprimé à la fin de la session.
| `Domain` | `Domain=oncletom.io` | Spécifie le domaine ou les sous-domaines applicables au cookie.
| `Path` | `Path=/` | Contraint le cookie à ce répertoire et tous ses sous-répertoires.
| `Secure` | `Secure` | Le cookie n'est envoyée que si le document est demandé via HTTPS.
| `HttpOnly` | `HttpOnly` | Le cookie ne peut pas être modifié côté client, via la variable `document.cookie`.
|===

[[templating]]
=== Modulariser les gabarits de présentation

je parle de nunjucks mais en fait on s'en fiche y'en a plein de bien
chacun son tyle : pug, twig, ejs, handlebars

[[dev]]
=== Pendant le développement : relancer le serveur automatiquement

nodemon, clairement

[[express]]
== Organiser une application avec le _framework_ express

Express mais ça pourrait être un autre
Y'a plus performant (fastify), plus orienté données (restify),
plus asynchrone (koa) et plus tout terrain (hapi).

choix du bien documenté, bien outillé
proche du module http (plus facile pour greffer des modules npm)

ce qui est expliqué après s'applique sans les frameworks
c'est une manière "consolidée" d'organiser son code et d'y brancher des trucs

[[middleware]]
=== Greffer des extensions

interception / transformation des requêtes entrantes
les routes obtiennent

[[views]]
=== Brancher les gabarits de présentation

c'est pas très différent mais y'a un module intermédiaire
qui gère ça tranquillement

[[frontend]]
=== Intégrer les ressources front-end (CSS, JavaScript)

mieux vaut les générer statiquement
rebuild à la demande
des fois y'a des outils qui font ça (on perd de vue les erreurs je trouve)

[[security]]
=== Protéger l'application

https://npmjs.com/helmet
https://npmjs.com/safe-regex pour utiliser une regex sur du contenu fourni par utilisateur
https://npmjs.com/xss
https://npmjs.com/sql-escape-string
https://npmjs.com/dompurify

path traversal (indexOf)
use strict (réduit les possibilités d'exploiter des bizarreries de JS)

////
L'organisme _Open Web Application Security Project_ (_OWASP_) recueille et diffuse nombre de critères de sécurité à connaître et vérifier pour déjouer au mieux des attaques.
Citons quelques uns de ces critères :

* *dépendences logicielles* ;
* *injection de code arbitraire* ;
* *données d'authentification* (vols, interceptions, brute force etc.) ;
* *contrôles d'accès* (impersonnification etc.) ;
* *optimisme sécuritaire* et *absences de vérifications* ;
* exposition de *données critiques* ;
* attaques *CSRF* (un script tiers actionne des commandes à notre insu) ;
* *uploads de fichiers* (poids limite, formats, chevaux de Troie etc.)
* *redirections* non-contrôlées.

[TIP]
.[RemarquePreTitre]#Ressources# [URL]#owasp.org#
====
Le site d'OWASP offre guides, référentiels, fiches récapitulatives, applications types, outils et tutoriaux pour sensibiliser à la sécurité applicative.

- [URL]#https://www.owasp.org/#
- [URL]#https://nodegoat.herokuapp.com/tutorial#
====
////


[[database]]
=== Brancher une base de données

Mémoriser les données entre deux redémarrages
Partager les données entre plusieurs instances

on va utiliser sqlite parce que pas de dépendance logicielle
node-sqlite pour les promesses mais on aurait très bien pu utiliser sqlite3

==== Quelle base de données choisir ?

en fait on peut en prendre plusieurs, ajuster stratégies

* *en mémoire* +
  Le stockage est dit _éphémère_ car l'information est stockée dans la mémoire vive de la machine et disparait dès que l'application est interrompue ;
* sous forme de *fichiers* +
  Le stockage est _physiquement lié_ à la machine hébergeant l'application.
  Ce support est davantage adapté à un _cache_ n'ayant pas besoin d'être actualisé après l'initialisation de l'application ;
* via une *API* +
  Le stockage est _nécessairement dissocié_ à la machine hébergeant l'application.
  L'accès à la lecture et à l'écriture de l'information se fait au travers d'une _interface de données_ accessible via HTTPS. +
  Nous pourrions tout à fait envisager d'utiliser les APIs de GitHub, Kinto, Google Drive ou KeyBase.io pour persister et collecter des données brutes ou transformées ;
* en *base de données* +
  Le stockage n'est _pas nécessairement lié_ à la machine hébergeant l'application.
  L'information persiste si l'application est interrompue.

[NOTE]
.[RemarquePreTitre]#Question# Dois-je forcément utiliser MongoDB avec Node ?
====
Doit-on nécessairement *utiliser _MongoDB_*, une base de données _orientée documents_ ou _JSON_ avec une application Node ?
La réponse est catégorique : c'est *non*.

*Tout type de base de données s'interface avec Node*, qu'elle soit _relationnelle_ (Postgres, MariaDB, MySQL), _clé/valeur_ (Redis), en _colonnes_ (Cassandra) ou _orientée documents_ (MongoDB, ElasticSearch).
====

[[sessions]]
=== Sessions utilisateur

[[logs]]
=== Tracer les actions

importants pour retrouver des problèmes
contexte où plein de personnes accèdent à une application, font plein de trucs
(ça dépasse l'échelle de compréhension d'un cerveau)

[[tests]]
== Vers un code réutilisable et testable

=== Modulariser le code des routes

but est de rendre une fonction de render la plus fine possible

- middlewares
- initialisation

=== Tester le code indépendamment du framework

mocha, chai, bon duo

=== Tester les aspects cruciaux du front-end

Cf. chapter-09/karma

=== Déployer automatiquement

Cf. chapter-06



[[advanced]]
== Pour aller plus loin


[[advanced.server]]
=== Pourquoi lancer un serveur ?

Il y a des environnements ou des logiciels comme Apache ou Nginx intègrent
notre langage de programmation avec des modules, par exemple PHP avec le `mod_php`
ou Perl avec le `mod_cgi`.
Les requêtes entrantes sont dirigées vers un script que le module interprète
et retourne une réponse, dynamiquement.

Le *script PHP est interprété à chaque requête* et tout cette représentation
est détruite une fois la réponse envoyée — mémoire, valeurs des variables, configuration.
Il faut recourir à un ensemble de modules additionnels pour optimiser ce gâchis
de ressources informatiques — cache d'interprétation, cache applicatif, cache de configuration.

Démarrer un serveur HTTP dans le langage de notre application nous éloigne de
ce modèle coûteux et nous rapproche d'un fonctionnement plus performant, organisé
autour de ces 3 piliers :

- *Node et Apache/Nginx fonctionnent ensemble* — ils se font le relais des requêtes
et des réponses car ils parlent le même protocole ;
- *le serveur Node est préchauffé* — une requête entrante trouve une application
déjà opérationnelle, déjà configurée, déjà connectée à une base de données
et prête à répondre ;
- *le code exécuté est spécifique à la requête* — l'application reçoit chaque
requête de manière indépendante en ayant le minimum d'effort à faire pour
générer une réponse.

Autrement dit, ce modèle réduit le temps de parcours entre une requête entrante
et une réponse sortante.
Ça a un impact significatif sur le temps d'apparition de l'icône de chargement
côté client.

[[http]]
=== Comprendre le modèle HTTP

- quand une requête arrive ça veut dire quoi
  - browser : GET http://monsite.com
  - montrer une requête HTTP brute
  - surprise : c'est que du texte
  - c'est interprété de deux côtés : par le client (programme qui demande, adresse une requête -- un navigateur web c'est un type de client) et le serveur (programme qui reçoit et renvoie des réponses)
  - et une réponse ça ressemble à quoi ?
    - dans la réponse y'a un statut (200, etc) (c'est pour ça 404)
    - dans la réponse y'a un type de contenu (Content-Type)
    - le corps de la réponse peut être du texte, qui suit un certain format (HTML, texte, XML, JSON, image/jpg, image/png)
  - le client interprète en fonction de ses capacités et d'hypothèses pragmatiques
    - un navigateur web : il interprète le HTML, l'affiche, et demande les ressources listées dans les différentes balises (img, video, audio)
      - fait autant de requêtes que nécessaire pour les obtenir et les afficher
      - attention s'il y en a trop, ça fait le même effet que retirer un courier à la Poste à la mauvaise heure
      - le poids des ressources à transférer a un impact (plus c'est lourd, plus c'est gros, plus c'est long à charger — c'est amplifié par la qualité et le débit de la connexion Internet)
      - [TIP] : les WebView ce sont des navigateurs web, genre pour iOS, Android etc.
    - un client en ligne de commande (curl, wget) : il n'interpète pas, récupère juste
      - c'est utilisé pour faire du scrapping
      - c'est utilisé pour donner ça à d'autres programmes (enjoliver le résultat, extraire des informations)
      - voir au chapitre 8 pour en savoir plus sur le fonctionnement d'applications en ligne de commande

.Temporalité de l'exécution d'une requête HTTP et des entêtes de réponse.
image::images/httpstat.png[]

https://github.com/jshttp

[[authentication]]
=== Authentifier des utilisateurs

[[api]]
=== API REST : l'application web orientée données

[[job-queue]]
=== Déléguer le travail aux files d'attente

[[lambda]]
=== Une application minimaliste avec les Lambda

https://npmjs.com/micro

[[https]]
=== Et HTTPS dans tout ça ?

== Conclusion

TBD.
