:chapterNumber: 8
:chapterId: chapter-08
:sourceDir: ./examples
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Créer un outil en ligne de commande

TBD.

====
.Sommaire
- TBD.
====

[abstract]
--
TBD.
--

include::../docs/tip-versions.adoc[]


install global : pour quelqu'un qui n'a pas besoin de l'inclure dans un projet.
Être autonome.
En faire un outil système.
Taper la commande sans avoir à se soucier d'autre chose.

utilisation : le nom c'est le même.
Plus logique.
Plus facile à retenir.
Mais ça peut se changer.

Le développement d'un outil en ligne de commande est proche de celui
d'une <<../chapter-07/index.adoc#,application web>>
(cf. <<../chapter-07/index.adoc#,chapitre 7>>).
L'équivalent du script qui démarre le serveur web est un script exécutable,
les routes de l'application sont des sous-commandes,
les arguments d'URL (_query string_) sont des options et l'affichage dans
un navigateur web est l'affichage dans un terminal.

[[start]]
== Créer un script exécutable

La première étape est de transformer un script Node en un script Node exécutable.
Le système d'exploitation ne percevra plus le script comme un simple fichier texte
mais bel et bien comme un programme au même titre que l'exécutable `npm`.

Nous allons apprendre à faire ce cheminement ensemble, jusqu'à rendre notre
code distribuable sous forme d'un <<../chapter-05/index.adoc#modules,module npm>>
(cf. <<../chapter-05/index.adoc#,chapitre 5>>).

[[script]]
=== Au départ, un simple script Node

Ce dont nous avons besoin pour démarrer, c'est d'un script Node que nous
pouvons appeler depuis notre terminal.
Nous allons placer l'exemple suivant dans le répertoire `bin`
(pour _binary_ en anglais, c'est à dire _exécutable_).
Ça n'a pas d'incidence technique mais c'est une pratique courante au sein
de la communauté Node pour repérer plus facilement les exécutables
sans ambiguité.

[source%interactive,javascript]
.bin/time.js
----
include::{sourceDir}/bin/time.js[]
----
<1> Crée un objet qui représente la <<../chapter-03/index.adoc#date,date>> courante — cf. <<../chapter-03/index.adoc#,chapitre 3>> pour se raffraichir la mémoire au sujet de cette API.

include::../docs/tip-examples.adoc[]

L'exécution du script avec Node retourne la date et l'heure courante — selon
l'horloge de l'ordinateur qui exécute le code.

----
$ node bin/time.js
Il est 13h42.
----


[[permissions]]
=== Modifier les permissions du script

Les systèmes d'exploitation modernes distinguent les fichiers ordinaires
des fichiers exécutables.
L'appel à un fichier exécutable se fait sans avoir à connaître quoique ce soit
d'autre que son emplacement.

Essayons d'exécuter le script précédent pour nous en rendre compte.
Pour se faire, nous allons l'invoquer seulement avec son chemin
— ici, son chemin relatif :

----
$ ./bin/time.js
sh: permission denied: ./bin/time.js
----

Le système refuse de l'exécuter car les permissions du fichier ne sont pas
adéquates.
Comme nous ne les connaissons pas, utilisons la commande `ls` ainsi que
l'option `-l` pour afficher ses informations détaillées :

----
$ ls -l bin/time.js
<i>-rw-r--r--</i> oncletom  staff  175 Jun 14 13:47 bin/time.js
----

Cet affichage détaille les permissions du fichier, l'utilisateur et le groupe
propriétaire, son poids et enfin la date de dernière modification.

[NOTE]
.[RemarquePreTitre]#Déchiffrer# Lire les permissions Unix
====
Les permissions sont cryptiques à lire quand on tombe dessus pour la première fois.

Le premier caractère spécifie le type (fichier, répertoire, lien symbolique) et
ensuite, ce sont des blocs de 3 caractères qui décrivent les permissions de
l'utilisateur propriétaire, du groupe propriétaire et du reste des utilisateurs
du système d'exploitation.

Chaque bloc affiche `r` s'il est lisible, `w` s'il est modifiable et
`x` s'il est exécutable — c'est ce dernier qui nous intéresse.
====

Nous allons rendre le fichier exécutable (`+x`) pour notre utilisateur (`u`)
grâce à la commande `chmod`.
Je préfère utiliser cette notation pour car elle évite des effets de bord :

----
$ chmod u+x bin/time.js
----

L'utilisation renouvelée de la commande `chmod` confirme que la
permission _exécutable_ du fichier a été attribuée à l'utilisateur propriétaire
du fichier :

----
$ ls -l bin/time.js
-rwxr--r-- oncletom  staff  175 Jun 14 13:47 bin/time.js
----

Nous sommes accueillis avec un nouveau message d'erreur lorsque nous
tentons d'exécuter le fichier `bin/time.js` :

----
$ ./bin/time.js
./bin/time.js: line 1: use strict: command not found
./bin/time.js: line 3: syntax error near unexpected token `('
----

La bonne nouvelle c'est que le fichier est exécutable.
Par contre, il semblerait que le système d'exploitation aie du mal
à interpréter le fichier.

[[shebang]]
=== Préciser le contexte d'exécution (_shebang_)

Donner les permissions d'exécution à un fichier ne suffit donc pas.
Nous avons perdu un élément contextuel en supprimant l'appel à `node`
dans l'exécution du script et nous allons voir comment rectifier le tir.

[CAUTION]
.[RemarquePreTitre]#Interopérabilité# Un fonctionnement différent sous Windows
====
Ce mécanisme est n'est pas compris par le système d'exploitation Windows.
Ce dernier utilise une surcouche qui serait trop longue à expliquer dans
cet ouvrage.

Je recommande cependant de conserver le contexte d'exécution sous Windows
car l'exécutable `npm` gère l'interopérabilité pour nous.
Nous verrons comment dans la <<package.json,section suivante>>.
====

Le caractère `#` placé en début de ligne d'un script système signale une ligne
placée en commentaire.
C'est l'équivalent du commentaire `//` en ECMAScript.
Il existe un cas spécial : lorsque le caractère `#` est
suivi par un `!` en tout début de fichier.
Le contenu du commentaire est alors utilisé par le système d'exploitation
pour déterminer quel programme utiliser pour interpréter le script.
C'est ce qu'on appelle _shebang_ (en anglais).

Modifions le script de la section précédente pour ajouter le
_shebang_ en entête :

[source,javascript]
.bin/time-sh.js
----
include::{sourceDir}/bin/time-sh.js[lines=1..5]
...
----

La ligne du _shebang_ crée un nouvel environnement d'exécution avec `env`,
référencé ici par son chemin absolu.
Ce nouvel environnement survit pendant la durée d'exécution du programme
passé en argument, ici `node` :

----
$ ./bin/time-sh.js
Il est 13h42.
----

Le dernier effort à faire pour distribuer ce script exécutable de manière
interopérable est de le lier à un
<<../chapter-05/index.adoc#package.json,module npm>>.

[[package.json]]
=== Faire le lien avec un module npm

Nous avons vu dans le <<../chapter-05/index.adoc#,chapitre 5>>
que Node utilisait la valeur `main` du fichier `package.json` pour déterminer
quel script inclure en faisant `require('<module>')` ou `import <module> from '<module>'`.

Le champ `bin` est une transposition de `main` pour associer un script
exécutable à notre module npm.
Par exemple :

[source,json]
.package.json
----
include::package.json[lines="1..3"]
  ...
}
----

Le moyen le plus simple pour tester l'intégration de l'exécutable
avec notre système d'exploitation est de
l'<<../chapter-05/index.adoc#install.global,installer globalement>>.
L'exécutable `npm` sait aussi installer un module à partir
d'un chemin vers un répertoire contenant un fichier `package.json` :

----
$ npm install --global .
----

Par défaut, l'exécutable est disponible sous le nom du module en question,
déclaré dans le champ `name` du fichier `package.json` :

----
$ nodebook.chapter-08
Il est 13h42.
----

[TIP]
.[RemarquePreTitre]#Pratique# Un autre nom ou plusieurs exécutables
====
Le champ `bin` s'écrit sous forme d'un objet si vous souhaitez utiliser
un autre nom que celui du module npm.
La clé correspond au nom de l'exécutable tel qu'il sera utilisable sur le
système tandis que la valeur contient le chemin d'accès au script exécutable.
Plusieurs exécutables sont alors installés si nous renseignons plusieurs
clés et valeurs.

[source,json,subs="-specialchars"]
.package.json
----
{
  "name": "nodebook.chapter-08",
  "bin": {
    "<i>quelle-heure-est-il</i>": "examples/bin/time-sh.js"
  }
}
----
====

[[interface]]
=== Vers un code testable et réutilisable

Obtenir la surface la plus faible possible entre son code et la lecture
des arguments.

réduire le plus possible ce qu'il y a dans un fichier exécutable
pour tester le plus facilement

((exemple inDir outDir -- réutiliser du code métier))

idéalement ce qui est dans le `main` est consommé par le `bin`

[[interactive]]
== Du script au programme interactif

[[options]]
=== Utiliser des options et arguments

`process.argv`

Tableau qui contient toutes les chaines de caractère utilisées pour lancer la commande.

(héritage UNIX).

`process.argv.slice(2)`

Créer des variables explicites au lieu de `process.argv[2]`.

Et la mémoire ?
Le script utilisera la mémoire disponible, à concurrence des autres applications qui tournent sur la même machine
Sur un Raspberry Pi, y'a moins de mémoire donc on peut atteindre plus rapidement des limites si les fichiers dépassent les capacités (centaine de Mo — vs. plus Go sur des ordinateurs modernes)

[[colours]]
=== Améliorer la lisibilité grâce aux couleurs

- chalk
- un autre module plus fonctionnel
- ANSI (sous Windows c'est différent je crois)

[[questions]]
=== Demander une série d'informations

- demand
- <insérer un module npm qui fait ça bien>

[[progress]]
=== Informer de la progression

- readline
- spinner
- progressbar

[[update]]
=== Inviter à mettre à jour le module

- update-check


[[tests]]
== Tester son code

[[tests.interface]]
=== Seulement l'interface

avec les outils habituels

[[tests.cli]]
=== Tester l'exécutable

plus dur, plus de code à écrire

- à la main avec spawn/exec
- tape-spawn
- cli-tester
- coffee

[[advanced]]
== Aller plus loin

[[application]]
=== Utilisation d'un framework d'application en ligne de commande

ça fait beaucoup de choses qu'on a fait bout par bout
pratique si on a besoin de tout utiliser en même temps
équivalent des express & co pour le web (cf. chapitre 7)

- yargs
- commander
- un autre truc plus léger

[[streaming]]
=== Lire et écrire des données en continu

utilisation des streams

[[packaging]]
=== Rendre le programme indépendant de Node

packager l'application (https://www.npmjs.com/package/pkg).

[[declarative]]
=== Templating et interfaces déclaratives


== Conclusion

TBD.
