:chapterNumber: 8
:chapterId: chapter-08
:sourceDir: ./examples
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Créer un outil en ligne de commande

TBD.

====
.Sommaire
- TBD.
====

[abstract]
--
TBD.
--

include::../docs/tip-versions.adoc[]

install global : pour quelqu'un qui n'a pas besoin de l'inclure dans un projet.
Être autonome.
En faire un outil système.
Taper la commande sans avoir à se soucier d'autre chose.

utilisation : le nom c'est le même.
Plus logique.
Plus facile à retenir.
Mais ça peut se changer.

Le développement d'un outil en ligne de commande est proche de celui
d'une <<../chapter-07/index.adoc#,application web>>
(cf. <<../chapter-07/index.adoc#,chapitre 7>>).
L'équivalent du script qui démarre le serveur web est un script exécutable,
les routes de l'application sont des sous-commandes,
les arguments d'URL (_query string_) sont des options et l'affichage dans
un navigateur web est l'affichage dans un terminal.

[[start]]
== Créer un script exécutable

La première étape est de transformer un script Node en un script Node exécutable.
Le système d'exploitation ne percevra plus le script comme un simple fichier texte
mais bel et bien comme un programme au même titre que l'exécutable `npm`.

Nous allons apprendre à faire ce cheminement ensemble, jusqu'à rendre notre
code distribuable sous forme d'un <<../chapter-05/index.adoc#modules,module npm>>
(cf. <<../chapter-05/index.adoc#,chapitre 5>>).

[[script]]
=== Au départ, un simple script Node

Ce dont nous avons besoin pour démarrer, c'est d'un script Node que nous
pouvons appeler depuis notre terminal.
Nous allons placer l'exemple suivant dans le répertoire `bin`
(pour _binary_ en anglais, c'est à dire _exécutable_).
Ça n'a pas d'incidence technique mais c'est une pratique courante au sein
de la communauté Node pour repérer plus facilement les exécutables
sans ambiguité.

[source%interactive,javascript]
.bin/time.js
----
include::{sourceDir}/bin/time.js[]
----
<1> Crée un objet qui représente la <<../chapter-03/index.adoc#date,date>> courante — cf. <<../chapter-03/index.adoc#,chapitre 3>> pour se raffraichir la mémoire au sujet de cette API.

include::../docs/tip-examples.adoc[]

L'exécution du script avec Node retourne la date et l'heure courante — selon
l'horloge de l'ordinateur qui exécute le code.

----
$ node bin/time.js
Il est 13h42.
----


[[permissions]]
=== Modifier les permissions du script

Les systèmes d'exploitation modernes distinguent les fichiers ordinaires
des fichiers exécutables.
L'appel à un fichier exécutable se fait sans avoir à connaître quoique ce soit
d'autre que son emplacement.

Essayons d'exécuter le script précédent pour nous en rendre compte.
Pour se faire, nous allons l'invoquer seulement avec son chemin
— ici, son chemin relatif :

----
$ ./bin/time.js
sh: permission denied: ./bin/time.js
----

Le système refuse de l'exécuter car les permissions du fichier ne sont pas
adéquates.
Comme nous ne les connaissons pas, utilisons la commande `ls` ainsi que
l'option `-l` pour afficher ses informations détaillées :

----
$ ls -l bin/time.js
<i>-rw-r--r--</i> oncletom  staff  175 Jun 14 13:47 bin/time.js
----

Cet affichage détaille les permissions du fichier, l'utilisateur et le groupe
propriétaire, son poids et enfin la date de dernière modification.

[NOTE]
.[RemarquePreTitre]#Déchiffrer# Lire les permissions Unix
====
Les permissions sont cryptiques à lire quand on tombe dessus pour la première fois.

Le premier caractère spécifie le type (fichier, répertoire, lien symbolique) et
ensuite, ce sont des blocs de 3 caractères qui décrivent les permissions de
l'utilisateur propriétaire, du groupe propriétaire et du reste des utilisateurs
du système d'exploitation.

Chaque bloc affiche `r` s'il est lisible, `w` s'il est modifiable et
`x` s'il est exécutable — c'est ce dernier qui nous intéresse.
====

Nous allons rendre le fichier exécutable (`+x`) pour notre utilisateur (`u`)
grâce à la commande `chmod`.
Je préfère utiliser cette notation pour car elle évite des effets de bord :

----
$ chmod u+x bin/time.js
----

L'utilisation renouvelée de la commande `chmod` confirme que la
permission _exécutable_ du fichier a été attribuée à l'utilisateur propriétaire
du fichier :

----
$ ls -l bin/time.js
-rwxr--r-- oncletom  staff  175 Jun 14 13:47 bin/time.js
----

Nous sommes accueillis avec un nouveau message d'erreur lorsque nous
tentons d'exécuter le fichier `bin/time.js` :

----
$ ./bin/time.js
./bin/time.js: line 1: use strict: command not found
./bin/time.js: line 3: syntax error near unexpected token `('
----

La bonne nouvelle c'est que le fichier est exécutable !
Par contre il semblerait qu'il y ait un problème d'interprétation du fichier.

[[shebang]]
=== Préciser le contexte d'exécution (_shebang_)

Il faut parler à bash. `#!` sert à ça.

Chemin absolu vers exécutable.
`/usr/bin/env` vs `which` vs `/usr/bin/node` ?

> Runs a program in a modified environment.
(chercher plus sur pourquoi env)

[[package.json]]
=== Faire le lien avec un module npm

Champ `bin`
> Il faudra faire le lien avec le package.json

[[install]]
=== Tester une installation globale, localement

----
$ npm i -g .
----

Prend en compte les changements locaux.

[[interface]]
=== Vers un code testable et réutilisable

Obtenir la surface la plus faible possible entre son code et la lecture
des arguments.

réduire le plus possible ce qu'il y a dans un fichier exécutable
pour tester le plus facilement

((exemple inDir outDir -- réutiliser du code métier))

idéalement ce qui est dans le `main` est consommé par le `bin`

[[interactive]]
== Du script au programme interactif

[[options]]
=== Utiliser des options et arguments

`process.argv`

Tableau qui contient toutes les chaines de caractère utilisées pour lancer la commande.

(héritage UNIX).

`process.argv.slice(2)`

Créer des variables explicites au lieu de `process.argv[2]`.

Et la mémoire ?
Le script utilisera la mémoire disponible, à concurrence des autres applications qui tournent sur la même machine
Sur un Raspberry Pi, y'a moins de mémoire donc on peut atteindre plus rapidement des limites si les fichiers dépassent les capacités (centaine de Mo — vs. plus Go sur des ordinateurs modernes)

[[colours]]
=== Améliorer la lisibilité grâce aux couleurs

- chalk
- un autre module plus fonctionnel
- ANSI (sous Windows c'est différent je crois)

[[questions]]
=== Demander une série d'informations

- demand
- <insérer un module npm qui fait ça bien>

[[progress]]
=== Informer de la progression

- readline
- spinner
- progressbar

[[update]]
=== Inviter à mettre à jour le module

- update-check


[[tests]]
== Tester son code

[[tests.interface]]
=== Seulement l'interface

avec les outils habituels

[[tests.cli]]
=== Tester l'exécutable

plus dur, plus de code à écrire

- à la main avec spawn/exec
- tape-spawn
- cli-tester
- coffee

[[advanced]]
== Aller plus loin

[[application]]
=== Utilisation d'un framework d'application en ligne de commande

ça fait beaucoup de choses qu'on a fait bout par bout
pratique si on a besoin de tout utiliser en même temps
équivalent des express & co pour le web (cf. chapitre 7)

- yargs
- commander
- un autre truc plus léger

[[streaming]]
=== Lire et écrire des données en continu

utilisation des streams

[[packaging]]
=== Rendre le programme indépendant de Node

packager l'application (https://www.npmjs.com/package/pkg).

[[declarative]]
=== Templating et interfaces déclaratives


== Conclusion

TBD.
