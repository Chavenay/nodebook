:chapterNumber: 4
:chapterId: chapter-04
:sourceDir: ./examples
:sourceSample: hello.js
:nodeCurrentVersion: v8
:vX: v8.9.4
:npmCurrentVersion: v5
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
:arrowUp: &#11014;
:arrowDown: &#11015;
ifdef::env[]
:imagesdir: .
endif::[]

= Jouer avec Node.js

On peut utiliser Node en parlant directement avec l'interpréteur, en créant un script ou en programmant une application plus complexe.

Ce chapitre explique ce qu'il faut savoir pour interagir avec l'exécutable `node`, le fonctionnement des _modules_ et les variables à disposition.

Nous en profiterons aussi pour passer en revue la variété de modules
disponibles par défaut.

====
.Sommaire
- Interagir avec l’interpréteur Node
- Qu'est-ce qu'un processus Node ?
- Organiser son code en utilisant les modules
- Les modules Node
- S’en sortir quand ça ne se passe pas comme prévu
- Démarrer Node avec un comportement différent
====

[abstract]
--
Le <<../chapter-03/index.adoc#,chapitre 3>> a été l'occasion de pratiquer une
(re)mise en forme côté JavaScript, ECMAScript et tout ça.
On peut désormais mettre à profit nos connaissances pour parler directement
à l'interpréteur Node.
C'est l'occasion de se surprendre à pouvoir faire davantage de choses qu'on
imaginait.
--

include::../resources/tip-versions.adoc[]
include::../resources/tip-examples.adoc[]

toc::[]


== Interagir avec l'interpréteur Node

L'*interpréteur Node* est le programme qui nous permet d'obtenir des résultats
en échange d'instructions ECMAScript.
Le *terminal* est un autre programme qui nous permet de dialoguer avec
un ordinateur et les programmes installés.

Le <<../chapter-02/index.adoc#,chapitre 2>> détaille comment installer
_Node_ et un _terminal_ sur son ordinateur.
Il contient également des conseils pour utiliser Node depuis un
navigateur web.
Cela peut rendre l'accès au terminal plus facile.

La suite de ce chapitre se base sur le principe que vous avez un terminal
sous le nez, prêt·e à saisir des instructions ECMAScript.

.Exemple de _terminal_ sous macOS.
image::images/terminal.png[align="center",width="85%"]

[[node-version]]
=== Afficher la version

Nous pourrions commencer par afficher la version de l'interpréteur Node.
Nous nous assurons ainsi que nous pouvons interagir avec
l'interpéteur Node avec succès _et_ que l'interpréteur
est celui que nous attendons, dans la bonne version.
La version de Node conditionne la liste des fonctionnalités du langage
ECMAScript à disposition.

[TIP]
.[RemarquePreTitre]#Compatibilité# Syntaxe ECMAScript
====
Le site web [URL]#https://node.green# liste le niveau de compatibilité
des fonctionnalités ECMAScript.

Cette page vous aidera à comprendre quelles fonctionnalités utiliser en toute
sécurité, version par version de Node.
====

Une fois votre terminal ouvert, saisissez la commande suivante :

[source,bash]
----
$ node --version
----

Le numéro de version de l'interpréteur Node s'affichera alors.
Par exemple : `{vX}`.

Si c'est ce à quoi vous vous attendiez, nous pouvons passer à la suite.
À l'inverse, si une erreur se produit ou que le numéro de version
n'est pas celui que vous attendiez, jetez un œil à la
<<../chapter-02/index.adoc#install,section _Installer Node.js_>> du chapitre 2.

[[node-printeval]]
=== Avec une expression

L'interpréteur Node sait interpréter du code qu'on lui donnerait
via l'option `-p` (pour _print_, c'est à dire _afficher_).
L'interpréteur affichera le résultat de l'expression ou
détaillera la <<errors,raison de l'erreur>>.

J'utilise cette forme d'interaction pour obtenir un résultat rapide.
Par exemple, le résultat d'une opération mathématique :

[source,bash]
----
$ node -p '2 + 2'
4
----

Toute expression ECMAScript retournera un résultat,
comme cet exemple de
transformation de <<../chapter-03/index.adoc#string,chaîne de caractères>> :

[source,bash]
----
$ node -p '"abc".toLocaleUpperCase()'
ABC
----

[[repl]]
=== Avec l'invite de commande interactive (_REPL_)

L'invite de commande interactive est une manière… interactive de parler
à l'interpréteur Node.
On entre dans un mode de dialogue où tout ce que l'on écrit est interprété
par Node.

J'utilise l'invite de commande pour tester des idées et des approches
avant d'écrire le <<script,code dans un script>>.

Ce mode interactif s'invoque en mentionnant l'exécutable Node,
sans autre argument :

[source,bash,subs="attributes"]
----
$ node
> {empty}
----

On notera au passage que l'invite est préfixée par le caractère `>`
afin de marquer notre présence dans un environnement différent.
On retrouve un comportement similaire dans les invites de commande
des langages Ruby (`irb`), Python (`python`) et PHP (`php -a`)

Lorsque nous sommes dans l'interpréteur interactif,
toutes les expressions sont interprétées par Node :

[source,bash,subs="attributes"]
----
$ node
> 2 + 2
4
> "abc".toLocaleUpperCase()
'ABC'
> {empty}
----

Des expressions sont réservées pour obtenir de l'aide, sortir de l'interpréteur
ou simplement pour nettoyer ce que l'on voit à l'écran.
Pour cela on fait appel à l'instruction `.help` :

[source,bash]
----
$ node
> .help
.break    Sometimes you get stuck, this gets you out
.clear    Alias for .break
.editor   Enter editor mode
.exit     Exit the repl
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands in this REPL session to a file
----

Ces touches ou combinaisons de touches sont utiles pour naviguer dans
l'invite de commande :

- la combinaison de touches kbd:[CTRL+C] annule
la saisie de la ligne en cours (kbd:[^+C] sous macOS) ;
- les touches _flèche haut_ (kbd:[{arrowUp}]) et _flèche bas_
(kbd:[{arrowDown}]) aident à naviguer dans l'historique des commandes ;
- la touche _tabulation_ (kbd:[TAB]) tente de compléter la saisie avec une
expression ou variable connue.

La touche kbd:[TAB] complètera automatiquement la saisie,
offrira une liste de choix de complétion :

[source,bash,subs="attributes,macros"]
----
$ node
> conso{empty}kbd:[TAB]
> console
> console.{empty}kbd:[TAB]
...
console.assert                console.clear                 console.count
...
----

On notera que l'utilisation de kbd:[TAB] après un caractère _point_ (`.`)
listera l'intégralité des propriétés de cet objet.

[TIP]
.[RemarquePreTitre]#Raccourci# Afficher tous les variables connues
====
L'utilisation de la touche kbd:[TAB] affichera _toutes_ les variables connues
de la session interactive en cours.
Il suffit d'appuyer une ou deux fois sur la touche kbd:[TAB]
dans une invite vide :

[source,bash,subs="macros"]
----
$ node
> kbd:[TAB]kbd:[TAB]
Array                         Boolean                       Date
Error                         EvalError                     Function
Infinity                      JSON                          Math
NaN                           Number                        Object
...
----

C'est un excellent moyen de *découvrir des éléments du langage* qui nous
étaient inconnus jusque là.
====

La sortie de l'invite de commande se fait à l'aide de
l'utilisation répétée de la combinaison de touches kbd:[CTRL+C]
(kbd:[^+C] sous macOS).
On revient ainsi à l'état initial où l'on était avant de
saisir la commande `node` :

[source,bash,subs="attributes"]
----
$ node
> {empty}
(To exit, press ^C again or type .exit)
> {empty}
$ {empty}
----

Ce même résultat s'obtient en saisissant `.exit`
ou en utilisant la combinaison de touches kbd:[CTRL+D] (kbd:[^+D] sous macOS).

[TIP]
.[RemarquePreTitre]#Raccourci# Variable magique `_`
====
La variable `\_` est spécifique à l'invite de commande Node.
Elle contient systématiquement le _résultat retourné_ par la
la dernière évaluation de code :

[source,bash]
----
$ node
> 2 + 2
4
> _ + 2
6
----

Cette variable magique est équivalente à la variable `$_` dans la console
des outils de développement des navigateurs web.
====

[[script]]
=== Avec un script

L'interpréteur Node sait lire le contenu d'un fichier pour en exécuter les
différentes instructions.
L'interpréteur reste actif jusqu'à ce que toutes les instructions
soient traitées.

J'utilise un script lorsque la logique à exécuter tient sur plusieurs lignes,
pour versionner ce code avec _git_ mais aussi pour structurer la logique
dans _plusieurs fichiers_ grace au mécanisme de <<modules,modules>>.

Prenons l'exemple d'un fichier nommé `script.js` qui contiendrait :

[source%interactive,javascript]
.script.js
----
include::{sourceDir}/script.js[]
----

Node interprète le contenu du fichier `script.js`.
Dans cet exemple, il indique à Node d'afficher deux messages :

[source,bash]
----
$ node script.js
4
ABC
----

Utilisons un autre exemple pour illustrer l'utilisation d'*arguments*. +
Les _arguments_ aident à personnaliser l'exécution du script :

[source,bash]
----
$ node hello.js 'me'
Hello me
----

Les _arguments_ sont les éléments ajoutés après le nom du fichier
(ici `hello.js`).
On y accède par le biais de la variable `process.argv`
de <<../chapter-03/index.adoc#array,type tableau>> :

[source%interactive,javascript]
.hello.js
----
include::{sourceDir}/hello.js[]
----

Le script précédent récupère le deuxième argument de l'objet `process.argv`.
Nous décrirons le fonctionnement de cet objet ci-après, dans la section <<process.argv,arguments d'exécution>>.

Comme vu au <<../chapter-02/index.adoc#,chapitre 2>> dans la section
<<../chapter-02/index.adoc#array-destructuring,décomposition de tableau>>,
si l'argument est inexistant ou vide, on lui attribue une valeur par défaut.

[source,bash]
----
$ node hello.js
Hello World
----

Cet exemple effleure la capacité de Node à servir à la création
d'*applications en ligne de commande*.
Nous verrons plus en détail _comment_ et _pourquoi_ créer de telles applications
dans le <<../chapter-08/index.adoc#,chapitre 8>>.

Enfin, il faut comprendre que toute exécution de script
entraîne la création d'un <<process,processus système>>.

[[process]]
== Comprendre la notion de _processus_

Le système d'exploitation crée un nouveau processus dès lors que l'on
fait appel à l'interpréteur `node`.
Ce processus peut être de _courte durée_ ou de _longue durée_,
selon qu'il dure quelques secondes ou plusieurs heures… voire
plusieurs jours ou un temps indéfini.

Le _processus_ existe tant qu'il y a des instructions à exécuter.
Ces instructions peuvent être immédiates (_programmation synchrone_),
décalées dans le temps (_programmation asynchrone_)
ou conditionnées par l'écoute d'événements extérieurs (_programmation événementielle_).

Le processus s'arrête en cas d'erreur, lorqu'il n'y a plus d'opération
à effectuer ou en cas d'interruption volontaire.

=== Le coût d'un processus

Démarrer un processus Node a un coût incompressible en ressources machine :
environ *30Mo de RAM* et *quelques millisecondes de CPU* avant d'exécuter nos
instructions.

Un *processus Node est _mono_ CPU*.
Toutes les opérations seront donc prises en charge par le même CPU
au cours de la durée de vie du processus.
Ça veut aussi dire que tous les autres processus système assignés à ce même CPU
se partageront une quantité finie de puissance.

Autrement dit, si le processus Node partage le même CPU qu'une base de données
utilisée par d'autres programmes, la rapidité de traitement de notre
application sera affectée par la quantité de ressources disponibles pour ce CPU.

=== La variable `process`

La variable `process` est une variable créée par l'environnement
d'exécution Node.
Elle est dite _globale_ car elle est accessible et partagée par tous
les <<modules,modules>>.

Cette variable est de <<../chapter-03/index.adoc#object,type _objet_>>.
Elle contient :

- la liste des <<process.env,variables d'environnement>> ;
- la liste des <<process.argv,arguments d'exécution>> ;
- les <<standard-streams,flux standards>> (entrée, sortie, erreur) ;
- des informations à propos de Node (version, support long terme) ;
- des informations système (plate-forme, identifiant, groupe de permissions, etc.) ;
- des méthodes pour interrompre le processus.

Reformulé autrement, la variable `process` renvoie des informations
sur l'environnement dans lequel le script est exécuté.
Notre code peut être interprété par Node
sur plusieurs types de machines
(ordinateur récent ou fatigué, Raspberry Pi, etc.),
sur différents systèmes d'exploitation (Windows, Linux, macOS, etc.). +
Nous avons ainsi tout le loisir d'adapter notre code
à ces différents environnements.

[NOTE,subs="attributes"]
.[RemarquePreTitre]#Documentation# Module _process_
====
L'intégralité des variables, fonctions et classes du module `process`
est documentée sur le site web du projet Node.
La documentation contient des informations à jour et qui ne sont pas
forcément listées dans cet ouvrage.

[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/process.html#
====

[[process.env]]
==== Variables d'environnement

Les variables d'environnement sont des
*variables définies au niveau du système d'exploitation*.
Elles contiennent des informations comme le _répertoire courant_, la langue du système d'exploitation, l'utilisateur système courant, le type de terminal, les emplacements d'installation des exécutables, etc.

On retrouve ces variables sous la forme d'un
<<../chapter-03/index.adoc#object,objet ECMAScript>> nommé `process.env` :

[source,bash]
----
$ node -p 'process.env'
{ ITERM_PROFILE: 'Default',
  LANG: 'en_GB.UTF-8',
  PWD: '/Users/oncletom/workspace/nodebook',
  SHELL: '/bin/zsh',
  TERM_PROGRAM_VERSION: '3.1.5',
  TERM_PROGRAM: 'iTerm.app',
  ...
}
----

Nous pouvons créer des variables d'environnement pour
*transmettre des informations contextuelles* à nos programmes :
des chemins d'accès à une base de données, si on est en situation de test
ou de production, l'emplacement de fichiers nécessaires au fonctionnement
de notre programme, etc.

Par exemple et par convention, la variable `NODE_ENV` est utilisée pour indiquer au programme
s'il est lancé dans le cadre du développement, de l'exécution des tests
ou s'il tourne sur le serveur de production.

Variable d'environnement éphémère::
La variable n'existe que pendant la durée de vie du programme.
La définition `CLÉ=valeur` est placée sur la même ligne que le programme
en question.
[source,bash]
----
$ NODE_ENV=production node env-var.js
mode : production
----
Variable d'environnement permanente::
La variable existe pendant la durée de la session
grâce à l'opérateur `export` sous Linux et macOS et
avec l'opérateur `set` sous Windows. +
La définition `export CLÉ=valeur` est placée sur sa propre ligne.
Elle restera accessible à _tout programme_ jusqu'à la fin de la session
ou jusqu'à ce qu'on efface la variable.
[source,bash]
----
$ export NODE_ENV=production
$ node env-var.js
mode : production
----

[TIP]
.[RemarquePreTitre]#Revenir en arrière# Effacer une variable d'environnement
====
L'utilisation de l'opérateur `unset` dans un terminal efface le contenu
d'une variable d'environnement.
Pratique pour ne pas laisser de traces !

[source,bash]
----
$ export NODE_ENV=dev
$ echo $NODE_ENV
$ unset NODE_ENV
$ echo $NODE_ENV
----
====

Voici le contenu du fichier `env-var.js` utilisé dans les exemples précédents :

[source%interactive,javascript]
.env-var.js
----
include::{sourceDir}/env-var.js[]
----

On notera que son comportement s'adapte à la _présence_ et à la _valeur_
de la variable d'environnement `NODE_ENV`.
Elle est accessible dans Node en tant que `process.env.NODE_ENV`.

[source,bash]
----
$ NODE_ENV=dev node env-var.js
On est en mode développement.
mode : dev
----

Nous verrons d'autres mises en situation des variables d'environnement pour
<<../chapter-06/index.adoc#app-configuration,configurer une application web>>
dans le <<../chapter-06/index.adoc#,chapitre 6>> et pour
<<../chapter-08/index.adoc#debug,déboguer une application en ligne de commande>>
dans le <<../chapter-08/index.adoc#,chapitre 8>>.

[[process.argv]]
==== Arguments d'exécution

Les arguments d'exécution sont des morceaux d'information transmis
à un script Node.
On les place à la droite du nom du fichier, comme illustré dans cet exemple :

----
$ node print-first.js salut
"salut"
----

On utilise les _arguments_ pour affiner le comportement d'un programme.
Je pense par exemple au numéro du port sur lequel lancer un serveur web,
une liste de fichiers à traiter ou
encore de fonctionnalités à activer ou à désactiver.

Il faut imaginer les arguments comme des *paramètres de fonction*,
accessibles dans un programme Node dans
le <<../chapter-03/index.adoc#array,tableau>> `process.argv` :

[source,javascript]
.print-first.js
----
include::{sourceDir}/print-first.js[]
----

Les deux premiers éléments de `process.argv` sont rarement utilisés.
Ils correspondant respectivement à l'emplacement de l'exécutable Node
et à l'emplacement du script.

Tous les autres arguments sont accessibles à partir de l'index 2 de
`process.argv`, dans l'ordre où ils sont placés :

----
$ node print-first.js salut ça va ?
"salut"
----

Le script `print-first.js` affiche le premier argument.
On peut en conclure que les arguments sont séparés par le caractère "espace".

Dans le cas où un argument doit contenir un espace, on l'encadre alors
entre guillemets :

----
$ node print-first.js "salut ça va ?" "oui et toi ?"
"salut ça va ?"
----

L'inconvénient des arguments est que leur ordre compte
et qu'il devient difficile de connaitre leur rôle sans se réferrer
au manuel d'utilisation.

C'est là qu'interviennent les *options*.
Comme le nom l'indique, ce sont des _arguments optionnels_.
Elles sont préfixées de deux _traits d'union_ (`--`).
On peut choisir de leur associer ou non une valeur.

----
$ node print-text.js "salut ça va ?" --uppercase
SALUT ÇA VA ?
----

Quand on n'associe pas de valeur à une option,
on considère qu'elle équivaut à un <<../chapter-03/index.adoc#boolean,booléen>>
de valeur `true`.

[source,javascript]
.print-text.js
----
include::{sourceDir}/print-text.js[]
----
<1> La condition est positive si l'on détecte `--uppercase` dans
la liste des arguments.

Les _options_ se combinent très bien avec les _arguments_.
Il faut les imaginer comme des interrupteurs.

Dans d'autres situations, on a besoin de *passer une valeur à une option* :

----
$ node print-text-limit.js "salut ça va ?" --limit 2
salut ça
----

L'exemple précédent illustre la césure d'une phrase à 2 mots
lorsque l'option `--limit` est associée à la valeur `2`.


[source,javascript]
.print-text-limit.js
----
include::{sourceDir}/print-text-limit.js[]
----
<1> On récupère l'index de l'option `--limit` dans le tableau `process.argv` ;
<2> On récupère la valeur dans l'élément suivant l'index de l'option `--limit` ;
<3> La troncature est paramétrée en fonction de la valeur associée à `--limit`.

Au fond, *les options sont des repères pour les utilisateurs* de nos programmes.
Elles leur permettent de s'interfacer avec leurs fonctionnalités.
Un peu à la manière des différents boutons qu'on retrouve
en façade d'une machine à laver.

L'exemple suivant est totalement fictif mais il illustre comment
on s'interfacerait avec une machine à laver
si elle mettait à disposition en ligne de commande :

----
$ machine-a-laver P-ECO 40 --fast --no-dry --room kitchen
----

Ce qu'il faut en comprendre, c'est qu'on démarrerait la machine située
dans la cuisine avec un programme économique _et_ à 40°C,
en activant l'option rapide et _en désactivant_ l'option séchage.

Nous verrons d'autres mises en situation pour
<<../chapter-08/index.adoc#argv,passer des paramètres à une application en ligne de commande>>
dans le <<../chapter-08/index.adoc#,chapitre 8>>.

[[standard-streams]]
==== Les flux standards

process.stdin, process.stdout, process.stderr

[[process.on]]
==== Écouter les événements

process.on

[[process.kill]]
==== Mettre fin au processus

process.abort
process.kill

[[modules]]
== Organiser son code en utilisant les modules

=== Qu'est-ce qu'on entend par module ?

modules CommonJS

modules ECMAScript

modules UMD ?

=== Importer avec `require()`

=== Exporter avec `module.exports`

[[modules-builtin]]
== Les modules par défaut

[NOTE]
.[RemarquePreTitre]#Documentation# Modules Node
====

[URL]#https://nodejs.org/docs/latest-{nodeCurrentVersion}.x/api/#
====

[NOTE]
.[RemarquePreTitre]#Documentation# Lecture des indices de stabilité
====
Node communique un indice de stabilité pour chacune de ses modules.
L'indice est exprimée selon une échelle graduée de 0 à 5.

.Exemple avec le module `punycode`, déprécié depuis Node v7.
image::images/node-api-deprecation.png[align="center",width="85%"]

Cette échelle se décompose de la manière suivante :

- 0 : le module est *déprécié* et peut être supprimé dans une prochaine version majeure ;
- 1 : le module est *expérimental*, instable et nécessite des retours utilisateurs ;
- 2 : le module est *instable*, son API peut changer et nécessite davantage de tests grandeur nature avant d'être considéré comme stable ;
- 3 : le module est *stable* mais peut être sujet à des changements mineurs d'API ;
- 4 : le module est *gelé*, son API ne devrait plus du tout changer ;
- 5 : le module est *verrouillé*, son code interne ne changera plus.

====

=== `path` : manipuler des chemins de fichier et de répertoire

=== `url` et `querystring` : manipuler des URL

=== `fs` : manipuler le système de fichiers

=== `events` : programmer des événements

`require('events')`

=== `stream` : manipuler des flux de données

=== `http` : créer et interroger des ressources via le protocole HTTP

On ira plus en détail dans le chapitre 7

On verra qu'on peut faire plus simple dans le chapitre 5 (exemple de module npm)

bonus : on peut aussi faire un serveur https ET un serveur http/2

=== `child_process` : appeler un exécutable système

Pratique quand on ne peut pas importer du code mais seulement des résultats


=== `os` : en savoir plus sur les capacités de l'ordinateur

Notamment les interfaces réseaux, les CPU etc.


[[errors]]
== S'en sortir quand ça ne se passe pas comme prévu

=== Le programme ne se termine pas

=== Le programme s'arrête sans exécuter le code que j'imaginais



== Démarrer Node avec un comportement différent


Cf. https://nodejs.org/api/cli.html
Compatible aussi avec `NODE_OPTIONS`

=== Précharger un module

`--require`

=== Inspecter notre code depuis le navigateur Chrome

`node --inspect` et `node --inspect-brk`

=== Utiliser le débogueur interactif

`node debug`

=== Personnaliser les fonctionnalités liées à ECMAScript

`--v8-options`

harmony pour activer les fonctionnalités de langage en cours de développement (en voie de standardisasation)

le reste pour changer le comportement de la VM

== Conclusion

TBD.
