:chapterNumber: 4
:sourceDir: ./examples
:sourceSample: TODO.js
:nodeCurrentVersion: v8
:npmCurrentVersion: v5
:toc-title: Table des matières
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Jouer avec Node.js

TBD.

====
.Sommaire
- TBD.
====

[abstract]
--
TBD.
--

include::../resources/tip-versions.adoc[]
include::../resources/tip-examples.adoc[]

toc::[]

[[invoke]]
== Invoquer Node.js

C'est bien beau de parler d'histoire, d'architecture et d'interpréteur mais concrètement, comment exécuter du code écrit pour Node ?

La plate-forme Node fournit un exécutable système : `node`. C'est lui qui digèrera votre code, préparé à l'avance ou non :

- `node` invoquera le _REPL_, un interpréteur interactif ;
- `node votre-script.js` invoquera le dit script.

[[node-repl]]
=== REPL

Un _REPL_ est un interpréteur interactif exécuté dans votre terminal.
Une fois invoqué, toutes les instructions écrites dans le terminal seront interprétées dès que vous presserez la touche kbd:[ENTRÉE]

L'intérêt principal d'utiliser le _REPL_ est de prototyper rapidement du code ; code que l'on pourra éventuellement sauvegarder en tapant kbd:[.+S+A+V+E+ENTRÉE].

Autre exemple : vous écrivez un programme qui nécessite que l'utilisateur saisisse lui-même du code à faire interpréter par Node.
On pourrait penser à un programme en ligne de commande éducatif ou encore à une interface web qui commanderait un _REPL_ distant.

image::images/node-repl.png[align="center",width="85%"]

Le _REPL_ lui-même est écrit en ECMAScript.
Il est disponible dans le module Node natif `repl` dont la documentation est disponible à l'adresse suivante : [URL]#https://nodejs.org/api/repl.html#.

[[node-exec]]
=== Exécution de script

L'exécution d'un script est très certainement l'invocation la plus classique de Node.

Node tente de charger et d'exécuter le fichier mentionné en argument de l'exécutable `node`.
Le processus Node reste actif tant que l'_Event Loop_ a des instructions à traiter dans le futur.

Un certain nombre d'options sont acceptées par l'exécutable et modifient son comportement en conséquent :

- `node debug votre-script.js` : active le mode débogage ;
- `NODE_ENV=production node votre-script.js` : transmet une variable d'environnement au processus et est accessible sous la forme `process.env.NODE_ENV`.

image::images/node-exec.png[align="center",width="85%"]

Pour connaître l'ensemble des options disponibles de l'exécutable Node, tapez `node --help` dans votre terminal.
Plusieurs options pourraient vous intéresser :

- `-e` (ou `--eval`) : évalue du code ;
- `-p` (ou `--print`) : évalue et affiche le code ;
- `-r` (ou `--require`) : inclue un module ;
- `--harmony` (ou tout sous-ensemble de type `--harmony-xx`) : active des fonctionnalités expérimentales ;
- `--v8-options` : passe des options à la <<../chapter-01.adoc#v8,VM V8>>.

L'option `-p` est idéale pour évaluer du code en une ligne et visualier un résultat :

----
$ node -p 'Date()';
Tue Jan 24 2017 12:42:02 GMT+0100 (CET)

$ FIRST_NAME='Thomas' node -p '`Bonjour ${process.env.FIRST_NAME}`'
Bonjour Thomas
----

[[node-sh]]
=== Script shell

Une autre alternative est de créer un fichier exécutable et de spécifier Node en tant qu'interpréteur.
C'est une opération utile pour rendre un programme accessible s'il est situé dans le `$PATH` système ou pour rendre un programme accessible lors de l'installation globale d'un _paquet npm_, entre autres.

Pour qu'un fichier soit rendu exécutable, nous devons nous assurer de deux choses :

. du _mode exécutable_ du fichier ;
. de la présence de l'entête _shebang_.

Il faut pour cela respectivement :

. ajouter le marqueur `x` avec le programme `chmod` ;
. démarrer le fichier par `#!<chemin vers l'interpréteur node>`.

Voici le contenu d'un fichier (non suffixé avec l'extension `.js`) qui affiche les arguments passé à ce dit-script :

[source,javascript]
.print-args
----
include::{sourceDir}/print-args[]
----
<1> Demande au programme `/usr/bin/env` de retourner le chemin vers l'exécutable système `node` ;
<2> Plus d'informations sur cette syntaxe dans la section <<primitive-destructuring,décomposition>> de ce même chapitre.

Le bloc suivant rend le fichier exécutable et l'exécute avec des arguments :

----
$ chmod +x print-args
$ ./print-args Affiche moi
[ 'Affiche', 'moi' ]
----

[[npm-scripts]]
==== Scripts npm

L'utilisation de _scripts npm_ permet d'invoquer Node de manière légèrement différente tout en masquant la complexité des scripts au niveau du fichier `package.json`.

L'invocation d'un _script npm_ peut se faire de deux manières :

. `npm <script-natif>` pour les scripts natifs à _npm_ (`start`, `publish`, `test` etc.) ;
. `npm run <script>` pour les scripts additionnels définis par l'utilisateur.

----
$ npm start
# équivalent de `npm run start`
----

Cette action exécute la commande contenue dans la section `scripts.start` du fichier `package.json` :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "start": "node server.js"
  }
}
----

L'avantage de cette approche est double :

- uniformisation du _workflow_ au sein de tous les projets ;
- npm modifie la *variable système `$PATH`*.

Ce dernier point est important.
Cela signifie que l'exécution d'un _script npm_ rend disponible les exécutables contenus dans le répertoire `./node_modules/.bin` (voir l'encadré _Répertoires et exécutables_ de la section <<install,Installation>>).

[source,javascript]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "eslint ." // <1>
  },
  "devDependencies": {
    "eslint": "^3.0.0"
  }
}
----
<1> Équivaut donc à `./node_modules/.bin/eslint ./src`.

=== Arguments d'invocation

Les arguments correspondent à un tableau de chaînes exposé par la propriété `argv` de la <<api-process,variable globale `process`>>.

Cette approche est recommandée pour *créer du code générique* et le *personnaliser avec des arguments*.
Le script suivant illustre leur lecture par l'interpréteur Node :

[source,javascript]
.config/argv.js
----
include::{sourceDir}/argv.js[]
----

Ce script peut être invoqué de la manière suivante :

----
$ node argv.js -y 2014 2012 --title 'fromage baguette' #<1>
----
<1> Affiche `["-y", "2014", "2012", "--title", "fromage baguette"]`.

Des librairies sont disponibles pour *transformer les arguments en objets JavaScript*, configurer des valeurs par défaut, de valider les valeurs, de les rendre obligatoire et même de générer automatiquement une aide à l'utilisateur.

Nous aborderons ces techniques avancées dans le <<../chapter-05/index.adoc#,Chapitre 5>>.

=== Plantage applicatif

Un programme Node s'arrête en général pour deux raisons :

. la *pile d'exécution est terminée* et il n'y a plus rien à exécuter ;
. une *erreur s'est produite* et n'a pas été capturée.

C'est souvent le cas lorsqu'une erreur se produit dans un endroit imprévu de notre code, lorsqu'une variable inexistante est appelée dans une branche de notre code appelée de manière asynchrone etc.

C'est une *bonne chose* que le programme s'arrête car cela nous permet de repérer l'erreur, de lire la trace et d'éventuellement patcher notre programme pour éviter cette même erreur dans le futur.

Quand un programme s'arrête de manière imprévue, le `process` émet un événement `uncaughtException`.
Il existe des cas où il est intéressant de l'écouter, notamment si la route d'un serveur cause une erreur et que l'on souhaite maintenir le service disponible malgré tout.

Dans ce cas, il convient d'écouter cet événement et de déterminer quelle est la meilleure action à suivre :

[source,javascript]
.server-crash.js
----
include::{sourceDir}/server-crash.js[]
----
<1> En cas de réception d'une requête HTTP sur le port `4001`, nous allons parser l'URL appélée — sauf qu'une _typo_ s'est glissée (`reb` au lieu de `req`) et provoquera une exception ;
<2> Cette exception remontera jusqu'au niveau du `process` qui déclenchera l'événement `uncaughtException` ;
<3> Une seconde après voir lancé le script, une requête HTTP est envoyée au serveur, entrainant l'exécution du _point 1_.

Encore une fois, *il vaut mieux qu'un programme plante* plutôt que de le protéger faiblement avec `uncaughtException`.

Il se peut qu'aucun code ne capture une erreur dans une <<primitive-promise,promesse>>.
C'est notamment le cas s'il n'y a aucun appel à `.catch()` après un `.then()`.

L'événement du `process` `unhandledRejection` est alors émis, sans pour autant faire planter le programme.
Ce comportement est toutefois amené à être modifié dans Node v8.
Il conviendrait alors de gérer le plantage d'un programme avec l'événement `uncaughtException` de la même manière que vous le feriez avec `uncaughtException`.

[[globals]]
== Variables globales dans Node.js

En plus des primitives ECMAScript, Node introduit des variables globales supplémentaires.
Elles vous seront utiles pour faciliter le débogage ou tout simplement pour le développement et le partage de vos modules.

=== console

Toute personne ayant développé du JavaScript pour le navigateur a très certainement utilisé `console.log` pour tracer l'état d'une expression lors de l'exécution de son code.

Trois fonctions sont à garder dans un coin de la tête :

- `console.log` ;
- `console.error` ;
- `console.trace`.

`console.log` affiche une représentation textuelle d'une expression et la formate avec des motifs équivalents à la fonction C `printf()`. +
Ce contenu est envoyé vers la sortie standard, `process.stdout` :

[source%interactive,javascript]
----
console.log('ECMA%s', 'script'); // <1>
----
<1> Affiche `'ECMAScript'`.

`console.error` a exactement le même comportement mais redirige vers le flux d'erreur, `process.stderr`.

`console.trace` envoie l'état de la _stack trace_ vers le flux d'erreur :

.stack-trace.js
----
$ node stack-trace.js
At level 1
At level 2
At level 3
At level 4
Trace: Level 5
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:11:13)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at traceAtLevel (…/examples/02-first-steps/stack-trace.js:8:5)
    at Object.<anonymous> (…/examples/02-first-steps/stack-trace.js:15:1)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
----

Pour en savoir plus sur les méthodes et fonctions disponibles, reportez-vous à la documentation en ligne du module `console` sur [URL]#https://nodejs.org/api/console.html#.

[[api-process]]
=== process

L'objet `process` correspond à l'instance de l'environnement Node en cours d'exécution.

Il permet de s'interfacer avec le système, en écoutant les évènements qu'il envoie au processus ou en écoutant les évènements que Node s'apprête à envoyer au système d'exploitation.

Le tableau `process.argv` contient le chemin du script exécuté ainsi que les différents arguments transmis à Node :

[source%interactive,javascript]
.process.js
----
include::{sourceDir}/process.js[]
----

Exécutons ce même script avec différents arguments :

----
node process.js <1>
node process.js argument1 "argument 2" --option1 <2>
----
<1> Retourne `[ 'node', '…/examples/chapitre-02/process.js' ]` ;
<2> Retourne `[ 'node', '…/examples/chapitre-02/process.js', 'argument1', 'argument 2', '--option1' ]`.

Il n'en faut pas davantage pour bâtir votre premier programme en ligne de commande.
Pour des besoins plus avancés, il existe un certain nombre de modules _npm_ pour exploiter les options et arguments.

[TIP]
.[RemarquePreTitre]#Remarque# Arguments internes
====
Comment faire pour passer des arguments à Node sans qu'ils soient interprétés par le script et vice-versa ?
Il suffit de les placer au bon endroit lorsque vous construisez l'appel à l'exécutable Node :

----
node <arguments node> chemin/vers/script.js <arguments script>
----

Ces arguments se retrouveront respectivement dans `process.execArgv` et `process.argv`.
====

[[stdio]]
Le deuxième ensemble d'objets à connaître est le trio `process.stdin`, `process.stdout` et `process.stderr`.
Ce sont trois flux (_Streams_) qui permettent d'accéder respectivement à l'entrée standard, à la sortie standard et à l'erreur standard.

Si ces noms ne vous parlent peut-être pas, c'est parce qu'ils sont directement inspirés d'UNIX.
Ils sont directement accessibles via l'interface JavaScript de Node.

Le script suivant convertit toute chaîne de caractères envoyée vers l'entrée standard en lettres majuscules :

[source,javascript]
.uppercase.js
----
include::{sourceDir}/uppercase.js[]
----

Exécutons ce script sur un système Unix :

----
echo "Entrée standard" | node uppercase.js <1>
----
<1> Affiche `ENTRÉE STANDARD`.

Le concept de _Streams_ sera développé petit à petit au fil de ce chapitre et dans le reste du livre.
C'est un concept puissant mais il y a des fonctionnalités plus simples à appréhender pour débuter.

Nous venons de voir que `process` est un objet contenant plusieurs attributs précieux.
L'héritage prototypal est utilisé pour le rendre capable d'émettre des évènements via la méthode `process.on()`.
Cette méthode est utilisée pour écouter les évènements système et permettre à nos programmes de réagir convenablement.

L'exemple suivant illustre la réaction face à un signal d'interruption (abrégé en `SIGINT`, pour _Signal Interrupt_).
Ce signal est notamment émis en pressant les touches kbd:[CTRL+C].

[source,javascript]
.interrupt.js
----
include::{sourceDir}/interrupt.js[]
----

Et maintenant son exécution dans un terminal Unix :

----
node interrupt.js 3 <1>
^C <2>
^C <3>
^C <4>
----
<1> Affiche `Appuyer 3 fois sur CTRL+C arrêtera le programme.` ;
<2> Affiche `Nombre d'essais restants: 2` ;
<3> Affiche `Nombre d'essais restants: 1` ;
<4> Affiche `Arrêt du programme…`.


`process.title` est une API intéressante pour assigner un _titre_ de process.
Cela concerne notamment les commandes de liste de processus actifs (comme `ls`).
On pourrait penser que cela offre l'avantage de rendre un processus singulier et donc plus facile à repérer :

----
$ node
> process.title='hey!'
----

Le résultat lorsqu'on liste les processus :

image::images/process-title.png[align="center",width="85%"]

*Attention* toutefois car il se trouve que le résultat de ce nommage peut se révéler imprédictible en fonction des systèmes d'exploitation où le programme est exécuté.
Il est donc recommandé de *ne pas utiliser `process.title`*.

Pour en savoir plus sur les méthodes et fonctions disponibles, reportez-vous à la documentation en ligne du module `process` sur [URL]#https://nodejs.org/api/process.html#.

=== module

Les modules CommonJS sont au cœur du fonctionnement de Node.
Ils permettent d'isoler, d'empaqueter et de rendre le code réutilisable.

La magie opère principalement grâce à la fonction `require` et à l'objet `module`.
Ils s'occupent respectivement de _charger_ et de _déclarer_ un module.

Techniquement parlant, un module est un fichier JavaScript dont toutes les variables sont privées et inaccessibles depuis l'extérieur.
Seules les variables exposées par `module.exports` sont publiquement accessibles.

Prenons l'exemple suivant :

[source,javascript]
.currency-format.js
----
include::{sourceDir}/currency-format.js[]
----

Dans le précédent exemple, le module `currency-format.js` est exposé en tant que fonction.
Les variables `currencies` et `formatNumber` restent encapsulées dans la portée du module.

Admettons que nous souhaitons utiliser ce module dans un programme, ici `currency-main.js` :

[source,javascript]
.currency-main.js
----
include::{sourceDir}/currency-main.js[]
----

La fonction `require` chargera le fichier `currency-format.js` et assignera le résultat de l'export dans la variable de votre choix, ici, `setupFormatter`.

----
node currency-main.js <1> <2>
----
<1> Affiche `undefined` ;
<2> Puis affiche `'12,00€'`.

Lors de l'exécution du précédent programme, nous avons confirmation que la variable `currencies` contenue dans le module `currency-format.js` n'est pas disponible dans le module `currency-main.js`.

[TIP]
.[RemarquePreTitre]#Remarque# Les modules Node
====
Un module Node est un répertoire contenant un fichier de description `package.json`.
Ce fichier contient notamment une propriété `main` indiquant quel fichier charger par défaut.
Les modules Node sont par convention placés dans un répertoire `node_modules`.

Voici un extrait du fichier `package.json` du module `lodash` :
----
{
  "name": "lodash",
  "version": "2.4.1",
  "main": "dist/lodash.js"
}
----

Ainsi, exécuter `require('lodash');` revient à peu près à faire `require('./node_modules/lodash/dist/lodash.js');`.
====

Pour en savoir plus sur les méthodes et fonctions disponibles, reportez-vous à la documentation en ligne des modules sur [URL]#https://nodejs.org/api/modules.html#.

[[api-require]]
=== require

Nous avons abordé le mécanisme de chargement de modules dans le point précédent.
Regardons plus en détails le comportement de la fonction `require`.

La fonction `require` permet de charger des fichiers locaux, des modules JavaScript, des modules binaires ou même des fichiers JSON :

[source,javascript]
.require.js
----
include::{sourceDir}/require.js[]
----
<1> Charge le module Node natif `fs` ;
<2> Charge le fichier `currency-format.js` : Node suffixe automatiquement le nom du fichier par `.js` (module JavaScript) ou par `.node` (module binaire) si l'extension manque ;
<3> Charge le fichier `examples/index.js` du répertoire `chapitre-02` car Node détecte que `chapitre-02` est un répertoire, découvre le fichier `package.json` et charge le fichier déclaré dans sa propriété `main` ;
<4> Charge le module Node `lodash`, vraisemblablement depuis le répertoire `node_modules/lodash` ;
<5> Charge et parse le fichier `package.json` en tant qu'objet ECMAScript.

`require` est une fonction synchrone _et_ bloquante.
Cela permet de garantir l'ordre de chargement des modules.

[source,javascript]
----
const path = require('path'); <1>
const setupFormatter = require('./currency-format.js'); <2>
----
<1> Node interprète d'abord cette ligne… ;
<2> … puis interprète celle-ci dès que le module `path` est chargé.

Qui dit bloquant dit que si du code est exécuté dans le module _avant_ l'export, il ralentira l'exécution tant que le module n'aura pas été mis en cache. +
L'exemple suivant illustre le phénomène :

[source,javascript]
.blocking-module.js
----
include::{sourceDir}/blocking-module.js[]
----

Dans l'exemple précédent, il faut attendre que la boucle soit complétée avant que la fonction `require` ne rende la main et procède à l'exécution des instructions suivantes :

[source,javascript]
----
require('./blocking-module.js');

console.log('module chargé'); <1>
----
<1> Le message ne sera affiché que tardivement, environ une seconde après le chargement du module `blocking-module.js`.

Il faut s'assurer que le code exécuté pendant le chargement d'un module soit exclusivement non bloquant pour conserver la performance applicative. +
Le concept d'asynchronicité et de non bloquant est explicité plus en détail dans _Comprendre les accès non-bloquants_.

Node optimise le chargement des modules en les mettant en cache.
Autrement dit et de manière générale, *un module est chargé une seule fois*.
L'unicité d'un module est assurée par son emplacement au sein du système de fichiers, en se basant sur la propriété `module.id`.

Prenons le cas de ce module :

[source,javascript]
.increment-module.js
----
include::{sourceDir}/increment-module.js[]
----

Le précédent module affichera son identifiant unique à chaque fois qu'il sera _chargé_.
Dès que la méthode `run()` de l'objet exporté sera appelée, elle incrémentera la variable privée `counter` et retournera sa nouvelle valeur.

Le module suivant fait deux fois appel à `increment-module.js` et assigne le résultat dans deux variables différentes.
Ceci dans le but de vérifier le comportement du mécanisme de chargement des modules Node.

[source,javascript]
.increment-main.js
----
include::{sourceDir}/increment-main.js[]
----

Il ne reste plus qu'à l'exécuter pour constater ce qu'il se passe :

----
node increment-main.js <1> <2> <3> <4>
----
<1> Affiche `…/examples/chapitre-02/increment-module.js` ;
<2> Affiche `0` ;
<3> Affiche `1` ;
<4> Affiche `true`.

Le module ayant déjà été chargé une fois, Node n'ira pas charger le fichier une deuxième fois et ne créera pas de nouvelle instance de l'objet `module`.
Il se contente de *retourner la même instance de module*.

Ce comportement peut être exploité	 en tant que _design pattern_ _Singleton_, explicité plus en détail dans ce même chapitre.

Enfin, Node lancera une exception si une erreur se produit lors du chargement (fichier inexistant, erreur de syntaxe dans le fichier à charger).

[source,javascript]
----
try {
  require('./module-inexistant.js');
}
catch (err) {
  console.log('L\'erreur est la suivante : %s', err.message); <1>
}
----
<1> L'exécution de ce module affichera `L'erreur est la suivante : Cannot find module './module-inexistant.js'`.

Pour en savoir plus sur le fonctionnement de la fonction `require`, reportez-vous à la documentation en ligne des modules sur [URL]#https://nodejs.org/api/modules.html#.

=== \__filename et __dirname

`\__filename` et `__dirname` sont des constantes indiquant respectivement le chemin absolu du fichier exécuté et le chemin absolu du répertoire contenant le fichier exécuté.

[source%interactive,javascript]
.filename-dirname.js
----
include::{sourceDir}/filename-dirname.js[]
----
<1> Affiche `…/examples/chapitre-02/filename-dirname.js` ;
<2> Affiche `…/examples/chapitre-02` ;
<3> Affiche `true`.

Utiliser `\__filename` et `__dirname` est utile pour travailler avec des chemins absolus, indépendamment du répertoire de travail de Node.

=== setTimeout, setInterval et setImmediate

Pour des raisons de commodité, Node fournit des implémentations de `setTimeout`, de `setInterval` et de `setImmediate`.
Pour rappel, ces fonctions de temps ne font pas partie de JavaScript mais de la spécification _DOM Level 0_.

Ces fonctions exécutent une fonction respectivement une seule fois dans un délai imparti, un nombre de fois indéterminé à un intervalle imparti et une seule fois immédiatement :

[source%interactive,javascript]
----
const print = (message) => {
  return print(){
    console.log(message); // <1> <2> <3>
  }
};

const timer = setInterval(print('interval'), 250);
setTimeout(print('timeout'), 200);
setImmediate(print('immediate'));
----
<1> Affichera d'abord `immediate`… ;
<2> … suivi de `timeout` environ 200ms plus tard… ;
<3> … puis `interval` environ 50ms plus tard et ce, toutes les 250ms tant que le programme ne sera pas arrêté ou que `clearTimeout` n'annulera pas l'intervalle.

Pour en savoir plus sur les méthodes et fonctions disponibles, reportez-vous à la documentation en ligne du module `timers` sur [URL]#https://nodejs.org/api/timers.html#.

=== _

La variable globale `\_` est un cas spécial.
Elle n'est prédéfinie que dans le terminal interactif (_REPL_).

Cette variable _magique_ contient systématiquement le résultat de la dernière évaluation de code.

----
$ node
> 2 + 2
4
> _ + 2
6
----
