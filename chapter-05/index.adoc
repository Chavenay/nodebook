:chapterNumber: 5
:chapterId: chapter-05
:sourceDir: ./examples
:sourceSample: cow.js
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:lodashVersion: 4.17.10
:mochaVersion: 5.2.0
:serveVersion: 7.2.0
:npmvX: 6.1.0
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Jouer avec npm

TBD.

====
.Sommaire
- Créer un fichier `package.json`
- Installer un module npm
- Aller et venir entre les versions d'un module npm
- Outiller un projet avec les scripts npm
- Publier un module sur le registre npm
- Questions et mystères autour de npm
====

[abstract]
--
TBD.
--

include::../resources/tip-versions.adoc[]
include::../resources/tip-examples.adoc[]

Le mot _npm_ correspond à trois concepts différents que nous aborderons
tout au long de ce chapitre :

- l'*exécutable* `npm` — un programme écrit en JavaScript ;
- le *registre* _npm_ — une plate-forme de distribution de modules ;
- un *module* _npm_ — en général installé depuis le registre et utilisable avec la fonction `require()`.

Je préciserai toujours si l'utilisation de _npm_ fait référence
à l'_exécutable_, au _registre_ ou à un _module_.

L'exécutable `npm` est installé par défaut avec l'exécutable `node`.
Nous pouvons vérifier la version installée en ouvrant un terminal
et en écrivant la commande suivante :

[subs="+attributes"]
----
$ npm --version
{npmvX}
----

Si un message s'affiche en indiquant que `npm` n'est pas un programme reconnu,
veuillez vous référer au <<../chapter-02/index.adoc,chapitre 2>> et
vérifier que Node {nodeCurrentVersion} est bien installé.


[[cli]]
== Créer un fichier `package.json`

La présence d'un fichier `package.json` est nécessaire pour utiliser npm
dans un projet.
La commande `npm init` génère un tel fichier en nous posant des questions.
Nous irons plus vite en utilisant l'option `--yes` :

----
$ npm init --yes
----

Le fichier `package.json` sera créé avec le contenu suivant :

----
{
  "name": "<nom du répertoire>",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
----

Si le fichier existait déjà, la copie existante sera préservée et affichée
à l'écran.

Nous allons ignorer le contenu du fichier dans un premier temps
afin de nous focaliser sur l'opération la plus importante et la plus
fréquemment utilisée :
l'installation de modules npm avec la commande `npm install`.

[[modules]]
== Installer des modules npm

Le mécanisme de modules est documenté dans
le <<../chapter-04/index.adoc#,chapitre 4>>.
La fonction `require()` charge nos propres modules mais aussi
les modules de base, proposés par Node.
Les modules npm sont des *modules complémentaires et téléchargeables* à l'aide
de l'exécutable `npm`.

Cette section va nous aider à comprendre ce qu'il se passe sous le capot
pendant les phases d'installation et de désinstallation des modules npm.

=== Depuis le registre npm

Le registre npm ([URL]#https://npmjs.com#) est l'hébergement principal
des modules JavaScript.

La commande `npm install` s'utilise directement quand nous connaissons déjà
le nom d'un module à installer,
par exemple le module _cowsay_ ([URL]#https://npmjs.com/cowsay#) :

----
$ npm install cowsay
+ cowsay@1.3.0
added 10 packages from 3 contributors in 1.667s
found 0 vulnerabilities
----

Le module est installé et prêt à être inclus dans un script.
Nous pouvons aussi constater que le champ `dependencies` est apparu
dans le fichier `package.json` :

[source,json]
.package.json
----
include::package.json[lines="1,19..-1"]
----

L'exécutable `npm` tient les comptes des modules installés à notre demande.
Ça nous sera utile pour <<install,installer les modules sur un autre ordinateur>>.
Nous reviendrons plus tard sur la notation des versions
— on en reparlera sous le nom de _versions sémantiques_ (_Semantic Versionning_).

[source%interactive,javascript]
.cow.js
----
include::{sourceDir}/cow.js[]
----

Nous pouvons remarquer que l'inclusion d'un module npm est identique
à celle d'un <<../chapter-04/index.adoc#modules-builtin,module de base>>. +
Regardons le résultat sans plus tarder :

----
$ node cow.js
___________
< Bonjour ! >
-----------
       \   ^__^
        \  (oo)\_______
           (__)\       )\/\
               ||----w |
----

L'utilisation d'un module npm nous a permis d'utiliser du code sans avoir à le
créer alors qu'il n'était pas fourni par la plate-forme Node.

Maintenant que nous savons installer un module npm, nous pouvons en chercher
d'autres et comprendre comment les utiliser.

[NOTE]
.[RemarquePreTitre]#Question# Où sont stockés les modules npm ?
====
Les modules npm et leurs dépendances sont stockés dans un répertoire
`node_modules`.
Ce répertoire est situé au même niveau que le fichier `package.json`.
====


[NOTE]
.[RemarquePreTitre]#Sous le capôt# Ce que fait l'exécutable `npm` pendant l'installation
====
L'exécutable `npm` effectue un bon nombre d'actions après avoir
saisi la commande `npm install cowsay` :

1. il interroge le registre _npmjs.com_ pour obtenir des informations sur le module demandé ;
2. il détermine que `1.3.0` est la version la plus récente ;
3. il télécharge une archive compressée (`.tar.gz`) qui contient tous les fichiers de la version `1.3.0` ;
4. l'archive est décompressée dans le répertoire `node_modules` ;
5. les dépendances sont elles aussi téléchargées puis décompressées dans le répertoire `node_modules` ;
6. le module `cowsay` est inscrit dans le fichier `package.json`.
====


[[registry]]
=== Trouver son bonheur dans le registre npm

Le _registre npm_ ([URL]#https://npmjs.com#) fourmille de modules
— de simples fonctions, des librairies ou des _frameworks_ complets.
Ils couvrent un spectre d'usages allant de l'accès aux bases de données,
à des frameworks web, à des outils frontend, des utilitaires de test,
de compression de données, du paiement bancaire, des frameworks mobiles, etc.

Essayons-nous à chercher une librairie qui puisse nous connecter à une
base de données MySQL ou MariaDB.
Tapez `mysql` dans le champ de recherche du registre npm ou saisissez
directement l'URL menant aux résultats de cette recherche en vous
rendant sur [URL]#https://npmjs.com/search?q=mysql# :

.Extrait des résultats d'une recherche de modules npm avec le mot-clé _mysql_.
image::images/npm-registry-search.png[]

Les résultats sont triés par pertinence — un mélange entre popularité,
qualité et maintenance des projets.

Je trouve qu'il est difficile de décider uniquement en regardant la liste.
J'ai tendance à ouvrir un onglet par module pour lire leur documentation.

Prenons le cas du module _mysql2_ ([URL]#https://npmjs.com/mysql2#) justement :

.Extrait de la page consacrée au module npm _mysql2_.
image::images/npm-package-mysql2.png[]

Plusieurs éléments de cette page tendent à me rassurer
et m'aident à juger de la robustesse de ce module npm :

- les badges qui affichent le statut d'exécution des tests ;
- une introduction de *documentation claire et concise* ;
- un *nombre de téléchargements* en progrès réguliers ;
- il s'utilise avec des promesses ;
- le nombre important de modules dépendants ;
- *je reconnais une autrice* qui contribue du code de qualité.

J'ai un doute quand je lis _108 issues_ et _13 pull requests_.
Dans ce cas-là je me dis que les personnes qui maintiennent le projet ne sont
pas forcément très réactives.

Cependant, il y a suffisamment d'indicateurs au vert pour l'installer à coup de
`npm install mysql2` puis à l'essayer dans un script.

Le module _mysql-libmysqlclient_ ([URL]#https://npmjs.com/mysql-libmysqlclient#)
ne me fait pas du tout le même effet :

.Extrait de la page consacrée au module npm _mysql-libmysqlclient_.
image::images/npm-package-mysql-libmysqlclient.png[]

La page du module ne met pas d'exemple simple à comprendre et fait référence
à des versions de Node antédiluviennes.
Rien n'indique qu'il ne peut pas fonctionner avec Node {nodeCurrentVersion}
mais la présence du mot _binding_ m'évoque que l'installation du module
compile un programme pour parler avec un programme écrit dans un autre langage
— en l'occurrence, _libmysqlclient_.

Point positif : il n'y a que 14 _issues_ GitHub.
C'est peu mais l'une d'entre elle est intitulée
« __Does not work with any modern version of Node.js__ ».
Ça confirme les doutes du paragraphe précédent :
c'est suffisant pour que je passe mon chemin.

En continuant plus loin dans la liste des résultats de recherche,
je suis tombé sur le module npm nommé _falchion_ :

.Extrait de la page consacrée au module npm _falchion_.
image::images/npm-package-falchion.png[]

Il n'y a qu'une seule version du module, qui date de quatre années
avec une documentation qui tient sur une ligne. +
Il y a très peu de chances que nous puissions en faire quelque chose.

Voici au final ce que j'estime être le plus important pour me faire
une idée d'un module et décider de l'installer ou non :

- présence d'une *documentation* — je peux me faire une idée des fonctionnalités
et de la complexité d'utilisation du module ;
- des badges d'*intégration continue* — je sais ainsi qu'il y a des tests
unitaires qui sont exécutés automatiquement avant que le module soit publié ;
- le nombre de *téléchargements* — je sais si d'autres personnes s'en servent
en espérant qu'ils remontent les problèmes rencontrés ;
- le nombre de *versions* — ça me donne une idée de la maturité du projet
et de la réactivité aux demandes de la communauté.

Ce sont des *critères subjectifs*.
Un module peut être populaire par ancienneté alors qu'il existe des alternatives,
plus légères ou plus simple d'utilisation.
C'est le cas du module _moment.js_ qui est plus populaire que _date-fns_
— alors que je préfère ce dernier.

Il y a aussi des modules pour lesquels j'ai une confiance quasi-aveugle.
Ils sont publiés par les personnes présentes dans cette liste non-exhaustive :

[format="csv"]
.Auteurs et autrices de modules npm à suivre
|===
dougwilson, [URL]#https://npmjs.com/~dougwilson#
feross, [URL]#https://npmjs.com/~feross#
fgribreau, [URL]#https://npmjs.com/~fgribreau#
iarna, [URL]#https://npmjs.com/~iarna#
isaacs, [URL]#https://npmjs.com/~isaacs#
jdalton, [URL]#https://github.com/jdalton#
jshttp, [URL]#https://github.com/jshttp#
mbostock, [URL]#https://npmjs.com/~mbostock#
nodejitsu, [URL]#https://github.com/nodejitsu#
rwaldron, [URL]#https://npmjs.com/~rwaldron#
sindresorhus, [URL]#https://npmjs.com/~sindresorhus#
substack, [URL]#https://npmjs.com/~substack#
zkat, [URL]#https://npmjs.com/~zkat#
|===

[TIP]
.[RemarquePreTitre]#Pratique# Sélection de modules npm
====
J'ai compilé une liste de modules utiles pour mieux démarrer
dans vos projets.

Vous la trouverez en <<../appendix-a/index.adoc#,annexe A>>.
====

[[uninstall]]
=== Désinstaller un module

Nous sommes emmenés à remplacer un module par un autre ou à changer d'avis
sur la nécessité d'un module.
L'utilisation de la commande `npm uninstall` nous aidera à supprimer
les fichiers du module en toute sécurité puis à le retirer de la liste
des dépendances du fichier `package.json`.

----
$ npm un cowsay
removed 10 packages in 1.963s
found 0 vulnerabilities
----

Le module _cowsay_ n'est plus installé.
Que se passe-t-il si nous exécutons à nouveau un des premiers exemples de cette
section ?

----
$ node cow.js
internal/modules/cjs/loader.js:596
    throw err;
    ^

Error: Cannot find module 'cowsay'
----

Une nouvelle erreur se produit sous nos yeux.
Le chargement du module _cowsay_ a échoué car Node n'arrive pas à le trouver
— et c'est normal.

Nous devons à nouveau lancer la commande `npm install cowsay`
pour que le script fonctionne à nouveau.


[[install]]
=== Depuis un fichier `package.json`

Jusqu'à présent, nous avons installé des modules car nous les ajoutions
au projet.
La procédure est légèrement différente si nous avons à installer à nouveau
des dépendances déjà listées dans le champ `dependencies` du fichier
`package.json`.

Pour en avoir le cœur net, plaçons-nous dans le répertoire qui contient
le fichier `package.json` et supprimons le répertoire `node_modules`
qui contient les dépendances déjà installées.
Exécutons ensuite la commande `npm install` sans autre argument :

----
$ rm -rf node_modules
$ npm install
added 10 packages from 3 contributors in 2.276s
found 0 vulnerabilities
----

Au final, la commande `npm install` est s'utilise quand
nous récupérons du code avec Git pour la première fois ou après une mise à jour,
par exemple avec `git pull`.

L'exécutable `npm` vérifie toujours que les modules npm installés dans
le répertoire `node_modules` correspondent bien à ceux qui sont listés
dans le fichier `package.json`.
Il installe, met à jour et retire les modules npm en fonction de ce
qui est nécessaire.

[NOTE]
.[RemarquePreTitre]#Remarque# Dépendances de développement
====
La commande `npm install` a également pour effet d'installer
les <<install.dev,dépendances de développement>> listées dans le fichier
`package.json`.
====

[[install.version]]
=== Spécifier une version

L'exécutable `npm` installe la dernière version d'un module par défaut.
Nous avons la liberté d'en installer d'autres qui sont antérieures.
C'est pratique quand des modules npm arrêtent de supporter
des navigateurs web ou des versions de Node alors que nous les utilisons encore.

Nous allons utiliser le module _lodash_ ([URL]#https://npmjs.com/lodash#)
pour illustrer nos allées et venues entre différentes versions.
À l'heure où j'écris ces lignes, la version la plus récente sur le registre npm
est la `{lodashVersion}`.
C'est ce que rapporte le résultat de la commande `npm install lodash` :

[subs="+attributes"]
----
$ npm install lodash
+ lodash@{lodashVersion}
----

L'utilisation du caractère `@` indique le numéro de version souhaité à
l'exécutable `npm` :

----
$ npm install lodash@3.0.0
+ lodash@3.0.0
----

Nous avons installé une version précise mais il y a surement des mises à jour
qui ont suivi pour corriger des bugs.
Le problème est qu'à ce stade, nous ne connaissons pas le numéro de version
à spécifier.
Idéalement, je préfèrerais installer la version la plus récente de la série 3.
Il se trouve que l'exécutable `npm` sait le faire pour nous et sans effort :

----
$ npm install lodash@3
+ lodash@<i>3.10.1</i>
----

Nous pouvons faire la même chose avec la version
la plus récente de la série 3 et de la série 2.2 :

----
$ npm install lodash@3
+ lodash@3.10.1
$ npm install lodash@2.2
+ lodash@2.2.1
----

[TIP]
.[RemarquePreTitre]#Pratique# Connaître toutes les versions d'un module
====
La <<view,commande `npm view`>> retourne les informations d'un module npm
directement depuis notre terminal.
Elle retourne toutes les versions publiées avec l'argument `versions` :

----
$ npm view lodash <i>versions</i>
[ '0.1.0',
  '0.2.0',
  ...
  '1.0.0',
  '1.0.1',
  '1.0.2',
  ... ]
----
====

Revenons à la version la plus récente en réutilisant la
<<install,commande d'installation>> abordée auparavant :

----
$ npm install lodash
+ lodash@2.4.2
----

Quelque chose d'inattendu s'est produit : la version la plus récente
de la série 2 a été installée au lieu de la version {lodashVersion}. +
Nous trouverons un élément de réponse dans le fichier `package.json` :

[source,json,subs="-specialchars"]
.package.json
----
{
  ...
  "dependencies": {
    "cowsay": "^1.3.0",
    "lodash": "<i>^2.4.2</i>"
  }
}
----

L'exécutable `npm` respecte la version précisée dans le fichier `package.json`
si elle n'est pas précisée dans la commande.
Si la dépendance n'est pas listée, alors l'exécutable `npm` installe la version
la plus récente.

L'étiquette `latest` explicite notre envie d'installer la version
la plus récente et sans tenir compte du fichier `package.json` :

[subs="+attributes"]
----
$ npm install lodash@<i>latest</i>
+ lodash@{lodashVersion}
----

Nous sommes désormais en mesure de choisir entre différentes versions
d'un module et de manière plus ou moins fine. +
Nous prendrons le temps d'explorer le mécanisme de numérotation des versions
dans la section suivante afin de mieux comprendre ce qui est renseigné
dans le fichier `package.json`.

[TIP]
.[RemarquePreTitre]#Pratique# Connaître les étiquettes d'un module
====
La <<view,commande `npm view`>> va à nouveau nous aider.
Elle retourne toutes les versions publiées avec l'argument `dist-tags` :

[subs="+attributes"]
----
$ npm view lodash dist-tags
{ <i>latest</i>: '{lodashVersion}' }
----

Ce mécanisme d'étiquette sert de raccourci pour associer un numéro de version
(qui change) à un intitulé (qui reste dans le temps).
====


[[semver]]
=== Comprendre les numéros de versions (_Semantic Versioning_)

Les numéros de versions ont été utilisées de deux manières dans les
sections précédentes : avec l'exécutable `npm` et en observant la liste
de dépendances dans le fichier `package.json`.

L'exécutable `npm` découpe un numéro de version en trois parties :
_majeur_, _mineur_ et _patch_.
Pour le numéro de version `1.2.3`, `1` est le numéro de version majeur,
`2` est le numéro de version mineur tandis que  `3` est le numéro de version patch.

Étudions la mise à jour de `lodash@2.2.0` :

- vers `lodash@2.2.1` : mise à jour patch — des bugs sont corrigés ;
- vers `lodash@2.4.2` : mise à jour mineure — des fonctionnalités sont ajoutées,
corrigées ou modifiées et ce, sans affecter notre code ;
- vers `lodash@{lodashVersion}` : mise à jour majeure — des fonctionnalités ont
été modifiées, remaniées ou supprimées et peuvent casser notre code qui repose dessus.

Une mise à jour majeure demande de lire attentivement la documentation du module
pour comprendre le volume de travail à fournir avant de monter en version.
La mise à jour mineure peut occasionnellement demander du travail selon
interprétation des développeurs de modules npm.

[format="csv", options="header", cols="1,2,3,3"]
.Différentes manières d'exprimer des versions
|===
Symbole, Version, Représentation alternative, Représentation étendue
   , `1.0.0`, -, -
`^`, `^1.0.0`, `1.x.x`, `>=1.0.0 <2.0.0`
`~`, `~1.0.0`, `1.0.x`, `>=1.0.0 <1.1.0`
`*`, `*`, `x.x.x`, `>=0.0.1`
|===

Je ne pense pas qu'il soit nécessaire de se sentir obligé·e de toujours
être positionné·e sur la dernière version majeure.
Les versions patch et mineures paraissent plus importantes à mes yeux
car elles contiennent des corrections qui peuvent bénéficier à nos applications.

[TIP]
.[RemarquePreTitre]#Outil# Calculateur de version
====
L'outil en ligne [URL]#https://semver.npmjs.com# sert à tester
la syntaxe des versions sémantiques avec de véritables modules npm.
====

[[update]]
=== Mises à jour

Nous avons appris à installer des modules npm dans les versions de notre choix
et à les réinstaller depuis la liste contenue dans le fichier `package.json`.
Comment savoir si ces derniers sont à mettre à jour ?

L'utilisation combinée des commandes `npm outdated` et `npm update` va
nous permettre d'y arriver.
Il sera plus facile de comprendre cette partie si vous vous êtes familiarisé·e
avec la notion de <<semver,version sémantique>>.

Commençons par installer d'anciennes versions des modules _lodash_ et _cowsay_ :

----
$ npm install lodash@2.0.0 cowsay@1.0.0
----

La commande `npm outdated` affiche les dépendances qui ne sont pas à jour :

[subs="+attributes"]
----
$ npm outdated
Package  Current  Wanted   Latest  Location
cowsay     1.0.0   1.3.0    1.3.0  nodebook.chapter-05
lodash     2.0.0   2.4.2  {lodashVersion}  nodebook.chapter-05
----

Le numéro de version affiché dans la colonne `Wanted` est celui qui sera atteint
avec la commande `npm update`.

----
$ npm update
+ cowsay@1.3.0
+ lodash@2.4.2
added 7 packages and updated 3 packages in 2.717s
----

Observons ce qui a changé dans les résultats de la commande `npm oudated` :

[subs="+attributes"]
----
$ npm outdated
Package  Current  Wanted   Latest  Location
lodash     2.4.2   2.4.2  {lodashVersion}  nodebook.chapter-05
----

Seul le module _lodash_ est désormais listé.
Les modules _cowsay_ et _lodash_ ont été mis à jour au plus sûr.
Le module _lodash_ peut rester en l'état si nous n'avons pas le temps
de rendre notre code compatible avec ses changements.

Sinon, une <<install.version,installation manuelle>> s'impose
avec l'étiquette `latest` :

[subs="+attributes"]
----
$ npm install lodash@latest
+ lodash@{lodashVersion}
----

Un dernier appel à `npm outdated` nous permet d'en avoir le cœur net :

----
$ npm outdated
----

Si rien ne s'affiche, c'est que tout est bon : nos modules sont à jour !

== Autres manières d'installer et d'utiliser des modules npm

Dans la section précédente, nous avons appris à installer des modules
depuis le registre npm. +
Dans cette section, nous allons apprendre à les installer depuis des sources
variées, uniquement à des fins de développement ou en tant que
commandes exécutables au niveau du système d'exploitation.

=== Depuis GitHub, GitLab ou un dépôt Git

Il arrive que nous ayons à utiliser une version modifiée d'un module npm
avant que l'auteur ou autrice accepte une correction de bug qui nous affecte.
Ça vaut aussi pour des modules dont le code serait hébergé dans un dépôt privé
et que nous ne voulons pas publier sur le registre npm.

Le module npm _cowsay_ est hébergé sur GitHub à l'adresse
[URL]#https://github.com/piuccio/cowsay#.

----
$ npm install github:piuccio/cowsay
+ cowsay@1.3.0
updated 1 package in 5.866s
----

Il s'agit en réalité d'une écriture raccourcie.
Nous sommes aussi en mesure d'utiliser l'URL d'un dépôt Git
— pas forcément GitHub ou GitLab donc :

----
$ npm install https://github.com/piuccio/cowsay
+ cowsay@1.3.0
updated 1 package in 4.513s
----

[WARNING]
.[RemarquePreTitre]#Considérations# Performance d'accès à Git
====
L'installation est plus lente depuis un dépôt Git que depuis un registre npm.
L'exécutable `npm` fait appel à l'exécutable `git` pour cloner l'historique
du dépôt et de ses dépendances pour extraire la version adéquate
de la copie de travail.

Le temps de téléchargement sera proportionnel au nombre de _commits_.
====

L'exécutable `npm` sait aussi installer des modules avec les protocoles
`git+ssh` et `git`.

----
$ npm install git://github.com:piuccio/cowsay.git
+ cowsay@1.3.0
updated 1 package in 10.263s
----

Le client Git ou SSH doivent être configurés au niveau du système pour
être en mesure de s'authentifier sur l'hôte distant. +
C'est une solution à privilégier pour les dépôts privés — la configuration
des dépôts privés via le protocole `https` est trop difficile à automatiser.

[[install.dev]]
=== En tant que dépendance de développement

Les dépendances de développement sont des modules npm utilisés
pour *exécuter les tests unitaires*.
Les *modules utilisés pour de l'outillage* et qui ne sont pas appelés
avec la fonction `require()` sont aussi des dépendances de développement.

Par exemple, le module npm _mocha_ est utilisé pour structurer et exécuter
des tests unitaires écrits en ECMAScript — pour Node et les navigateurs web.
Il serait donc logique de l'installer comme dépendance de développement.
L'option `--save-dev` permet de signaler cette intention à l'exécutable `npm` :

[subs="+attributes"]
----
$ npm install --save-dev mocha
+ mocha@{mochaVersion}
----

L'exécutable `npm` range alors ce module dans une nouvelle section du
fichier `package.json` — la section `devDependencies` :

[source,json,subs="+attributes,-specialchars"]
----
{
  ...
  "dependencies": {
    "cowsay": "^1.3.0",
    "lodash": "^{lodashVersion}"
  },
  "<i>devDependencies</i>": {
    "mocha": "^5.2.0"
  }
}
----

Les dépendances de développement sont installées uniquement lorsque
la commande `npm install` est invoquée dans le même répertoire
que le fichier `package.json`

À l'inverse, si vous faisons `npm install cowsay`, ses dépendances de
développement ne seront pas installées pour gagner du temps.

[TIP]
.[RemarquePreTitre]#Pratique# Lister les dépendances de développement d'un module
====
La <<view,commande `npm view`>> combinée à l'option `devDependencies`
retourne toutes les dépendances de développement d'un module donné :

----
$ npm view cowsay devDependencies
{ nodeunit: '~0.11.1',
  rollup: '^0.48.2',
  'rollup-plugin-commonjs': '^8.2.0',
  'rollup-plugin-node-resolve': '^3.0.0',
  'rollup-plugin-string': '^2.0.2' }
----

Ce sont autant de dépendances qui ne sont pas installées dans notre projet.
====

[TIP]
.[RemarquePreTitre]#Optimisation# Installer seulement les dépendances de production
====
La <<install,commande `npm install`>> accepte l'option `--production`.
Seules les dépendances listées dans la section `dependencies`
du fichier `package.json` seront alors installées :

----
$ npm install --production
----
====

[[install.global]]
=== En tant qu'exécutable système (installation globale)

Nous avons parlé des modules npm comme des modules complémentaires,
utilisés avec la fonction `require()` et téléchargés avec l'exécutable `npm`.
Certains modules npm se déclarent comme exécutables depuis un terminal.

C'est le cas du module _serve_ ([URL]#https://npmjs.com/serve#), par exemple.
Il démarre un serveur web en ligne de commande pour tester le rendu
de fichiers HTML sans avoir à configurer de logiciels comme _Apache_ ou _nginx_.

L'installation est rendue globale — à l'échelle du système d'exploitation
— avec l'utilisation de l'option `--global` :

[subs="+attributes"]
----
$ npm install <i>--global</i> serve
+ serve@{serveVersion}
----

[NOTE]
.[RemarquePreTitre]#Question# Comment savoir si un module npm s'installe comme un exécutable système ?
====
En général, les modules npm qui se prêtent bien au jeu du `npm install --global`
sont ceux qui documentent des exemples de commande à exécuter,
qui se décrivent comme des outils en ligne de commande ou qui
mentionnent explicitement l'installation globale.
====

L'exécutable `serve` est disponible suite à l'installation globale :

[subs="+attributes"]
----
$ serve --version
{serveVersion}
----

Le module npm s'exécute de manière transparente, sans invoquer Node ni
l'exécutable `npm` :

----
$ serve .
INFO: Accepting connections at http://localhost:3000
----

[TIP]
.[RemarquePreTitre]#Documentation# L'option `--help`
====
Par convention, les modules npm qui s'utilisent en ligne de commande
embarquent une documentation.
Ce manuel décrit des cas d'usages ainsi que les options à disposition.

.Affichage de la documentation du module npm _serve_ depuis la ligne de commande.
----
$ serve --help
----
====

Un module npm installé de manière globale se désinstalle en passant l'option
`--global` à la <<uninstall,commande `npm uninstall`>> :

----
$ npm uninstall -g serve
----

Le <<../chapter-08/index.adoc#,chapitre 8>> sera l'occasion d'entrer plus en détails
dans le développement d'exécutables système écrits en ECMAScript.

[[install.link]]
=== Depuis un répertoire local


== Outiller un projet avec les scripts npm

[[start]]
=== Démarrer l'application

[[test]]
=== Exécuter des tests


L'écriture de tests et la vérification de la qualité de votre code sont un excellent
moyen de vous assurer que de nouveaux bugs ne sont pas introduits dans votre application.

Écrire des modules et les empiler sans écrire de tests revient à construire un
château de carte : le moindre changement accentue le risque de propager des
erreurs dans toutes les applications en dépendant.

Nous verrons ultérieurement comment écrire des tests unitaires pour vos
applications et votre code exécuté dans un contexte Web.

À la manière du démarrage d'une application, la commande npm fournit un
contexte d'exécution dédié aux tests :

----
$ npm test
----

Cette commande effectue deux choses :

- elle règle la variable d'environnement `NODE_ENV` à `test` ;
- elle exécute l'instruction du script `test` déclarée dans le fichier `package.json` :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*"
  }
}
----

Dans cet exemple, exécuter la commande `npm test` revient à actionner l'exécutable
déclaré par le module _mocha_ avec comme argument l'ensemble des fichiers
JavaScript contenus dans le répertoire `tests/` de notre projet.

En cas de test fautif, l'exécutable de tests affichera des précisions quant à
leur origine et se terminera avec un code de sortie différent de 0.

Ce qui signifie en jargon Unixien que vous pouvez chaîner la commande avec
d'autres actions basées sur un état de réussite des tests :

----
$ npm test && git push
----

Cette précédente commande a deux scénarios possibles :

1. `npm test` échoue et `git push` ne sera pas exécuté ;
2. `npm test` réussit et `git push` sera exécuté.

En se basant sur ce principe de chaîne, vous pouvez faire évoluer votre commande
de test en quelque chose de plus poussé :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "npm run lint-code && npm run unit-tests",
    "lint-code": "eslint ",
    "unit-tests": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*",
    "eslint": "^3.0.0"
  }
}
----

La commande `npm test` est alors composée de deux autres commandes personnalisées.
Vous maintenez ainsi une lisibilité au sein de votre fichier `package.json`
tout en bénéficiant d'une indépendance d'exécution de vos commandes.

[[run]]
=== Créer un script personnalisé

[[run-lifecycle]]
=== S'intégrer au cycle de vie d'un module npm


[[publish]]
== Publier un module npm

=== Le champ `main` du fichier `package.json`

=== Choisir une licence d'utilisation

=== Renseigner les informations importantes

Cf. #heuristics


== Quelques commandes pour aller plus loin

[[view]]
=== `npm view` : voir les informations d'un module

[[home]]
=== `npm home` : visiter le site web d'un module

[[audit]]
=== `npm audit` : vérifier la sécurité des dépendances

[[prune]]
=== `npm prune` : supprimer les dépendances inutilisées

[[doctor]]
=== `npm doctor` : vérifier l'état du système

[[config]]
=== `npm config` : changer les réglages de l'exécutable `npm`

[[link]]
=== `npm link` : utiliser une dépendance qui n'a pas encore été publiée


== Questions et mystères autour de npm

=== Je ne vois pas l'intérêt du fichier `package-lock.json`

=== npm c'est pour le backend, bower (ou autre) pour le frontend

=== Est-ce que je dois versionner le répertoire `node_modules` ?

=== Il paraît que Yarn, c'est mieux

=== npm est lent, il installe la moitié d'Internet à chaque fois

=== Que signifient les erreurs affichées pendant `npm install` ?


== Conclusion
