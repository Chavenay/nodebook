:chapterNumber: 5
:chapterId: chapter-05
:sourceDir: ./examples
:sourceSample: cow.js
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:lodashVersion: 4.17.10
:npmvX: 6.1.0
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Jouer avec npm

TBD.

====
.Sommaire
- Créer un fichier `package.json`
- Installer un module npm
- Aller et venir entre les versions d'un module npm
- Outiller un projet avec les scripts npm
- Publier un module sur le registre npm
- Questions et mystères autour de npm
====

[abstract]
--
TBD.
--

include::../resources/tip-versions.adoc[]
include::../resources/tip-examples.adoc[]

Le mot _npm_ correspond à trois concepts différents que nous aborderons
tout au long de ce chapitre :

- l'*exécutable* `npm` — un programme écrit en JavaScript ;
- le *registre* _npm_ — une plate-forme de distribution de modules ;
- un *module* _npm_ — en général installé depuis le registre et utilisable avec la fonction `require()`.

Je préciserai toujours si l'utilisation de _npm_ fait référence
à l'_exécutable_, au _registre_ ou à un _module_.

L'exécutable `npm` est installé par défaut avec l'exécutable `node`.
Nous pouvons vérifier la version installée en ouvrant un terminal
et en écrivant la commande suivante :

[subs="+attributes"]
----
$ npm --version
{npmvX}
----

Si un message s'affiche en indiquant que `npm` n'est pas un programme reconnu,
veuillez vous référer au <<../chapter-02/index.adoc,chapitre 2>> et
vérifier que Node {nodeCurrentVersion} est bien installé.


[[cli]]
== Créer un fichier `package.json`

La présence d'un fichier `package.json` est nécessaire pour utiliser npm
dans un projet.
La commande `npm init` génère un tel fichier en nous posant des questions.
Nous irons plus vite en utilisant l'option `--yes` :

----
$ npm init --yes
----

Le fichier `package.json` sera créé avec le contenu suivant :

----
{
  "name": "<nom du répertoire>",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
----

Si le fichier existait déjà, la copie existante sera préservée et affichée
à l'écran.

Nous allons ignorer le contenu du fichier dans un premier temps
afin de nous focaliser sur l'opération la plus importante et la plus
fréquemment utilisée :
l'installation de modules npm avec la commande `npm install`.

[[modules]]
== Installer des modules npm

Le mécanisme de modules est documenté dans
le <<../chapter-04/index.adoc#,chapitre 4>>.
La fonction `require()` charge nos propres modules mais aussi
les modules de base, proposés par Node.
Les modules npm sont des *modules complémentaires et téléchargeables* à l'aide
de l'exécutable `npm`.

Cette section va nous aider à comprendre ce qu'il se passe sous le capôt
pendant les phases d'installation et de désinstallation des modules npm.

=== Depuis le registre npm

Le registre npm ([URL]#https://npmjs.com#) est l'hébergement principal
des modules JavaScript.

La commande `npm install` s'utilise directement quand nous connaissons déjà
le nom d'un module à installer,
par exemple le module _cowsay_ ([URL]#https://npmjs.com/cowsay#) :

----
$ npm install cowsay
+ cowsay@1.3.0
added 10 packages from 3 contributors in 1.667s
found 0 vulnerabilities
----

Le module est installé et prêt à être inclus dans un script.
Nous pouvons aussi constater que le champ `dependencies` est apparu
dans le fichier `package.json` :

[source,json]
.package.json
----
include::package.json[lines="1,19..-1"]
----

L'exécutable `npm` tient les comptes des modules installés à notre demande.
Ça nous sera utile pour <<install,installer les modules sur un autre ordinateur>>.
Nous reviendrons plus tard sur la notation des versions
— on en reparlera sous le nom de _versions sémantiques_ (_Semantic Versionning_).

[source%interactive,javascript]
.cow.js
----
include::{sourceDir}/cow.js[]
----

Nous pouvons remarquer que l'inclusion d'un module npm est identique
à celle d'un <<../chapter-04/index.adoc#modules-builtin,module de base>>. +
Regardons le résultat sans plus tarder :

----
$ node cow.js
___________
< Bonjour ! >
-----------
       \   ^__^
        \  (oo)\_______
           (__)\       )\/\
               ||----w |
----

L'utilisation d'un module npm nous a permis d'utiliser du code sans avoir à le
créer alors qu'il n'était pas fourni par la plate-forme Node.

Maintenant que nous savons installer un module npm, nous pouvons en chercher
d'autres et comprendre comment les utiliser.

[NOTE]
.[RemarquePreTitre]#Question# Où sont stockés les modules npm ?
====
Les modules npm et leurs dépendances sont stockés dans un répertoire
`node_modules`.
Ce répertoire est situé au même niveau que le fichier `package.json`.
====


[NOTE]
.[RemarquePreTitre]#Sous le capôt# Ce que fait l'exécutable `npm` pendant l'installation
====
L'exécutable `npm` effectue un bon nombre d'actions après que nous ayons
saisi la commande `npm install cowsay` :

1. il interroge le registre _npmjs.com_ pour obtenir des informations sur le module demandé ;
2. il détermine que `1.3.0` est la version la plus récente ;
3. il télécharge une archive compressée (`.tar.gz`) qui contient tous les fichiers de la version `1.3.0` ;
4. l'archive est décompressée dans le répertoire `node_modules` ;
5. les dépendances sont elles aussi téléchargées puis décompressées dans le répertoire `node_modules` ;
6. le module `cowsay` est inscrit dans le fichier `package.json`.
====


[[registry]]
=== Trouver son bonheur dans le registre npm

Le _registre npm_ ([URL]#https://npmjs.com#) fourmille de modules
— de simples fonctions, des librairies ou des _frameworks_ complets.
Ils couvrent un spectre d'usages allant de l'accès aux bases de données,
à des frameworks web, à des outils frontend, des utilitaires de test,
de compression de données, du paiement bancaire, des frameworks mobiles, etc.

Essayons-nous à chercher une librairie qui puisse nous connecter à une
base de données MySQL ou MariaDB.
Tapez `mysql` dans le champ de recherche du registre npm ou saisissez
directement l'URL menant aux résultats de cette recherche en vous
rendant sur [URL]#https://npmjs.com/search?q=mysql# :

.Extrait des résultats d'une recheche de modules npm avec le mot-clé _mysql_.
image::images/npm-registry-search.png[]

Les résultats sont triés par pertinence — un mélange entre popularité,
qualité et maintenance des projets.

Je trouve qu'il est difficile de décider uniquement en regardant la liste.
J'ai tendance à ouvrir un onglet par module pour lire leur documentation.

Prenons le cas du module _mysql2_ ([URL]#https://npmjs.com/mysql2#) justement :

.Extrait de la page consacrée au module npm _mysql2_.
image::images/npm-package-mysql2.png[]

Plusieurs éléments de cette page tendent à me rassurer
et m'aident à juger de la robustesse de ce module npm :

- les badges qui affichent le statut d'exécution des tests ;
- une introduction de *documentation claire et concise* ;
- un *nombre de téléchargements* en progrés réguliers ;
- il s'utilise avec des promesses ;
- le nombre important de modules dépendants ;
- *je reconnais une autrice* qui contribue du code de qualité.

J'ai un doute quand je lis _108 issues_ et _13 pull requests_.
Dans ce cas là je me dis que les personnes qui maintiennent le projet ne sont
pas forcément très réactives.

Cependant, il y a suffisamment d'indicateurs au vert pour l'installer à coup de
`npm install mysql2` puis à l'essayer dans un script.

Le module _mysql-libmysqlclient_ ([URL]#https://npmjs.com/mysql-libmysqlclient#)
ne me fait pas du tout le même effet :

.Extrait de la page consacrée au module npm _mysql-libmysqlclient_.
image::images/npm-package-mysql-libmysqlclient.png[]

La page du module ne met pas d'exemple simple à comprendre et fait référence
à des versions de Node antédiluviennes.
Rien n'indique qu'il ne peut pas fonctionner avec Node {nodeCurrentVersion}
mais la présence du mot _binding_ m'évoque que l'installation du module
compile un programme pour parler avec un programme écrit dans un autre langage
— en l'occurence, _libmysqlclient_.

Point positif : il n'y a que 14 _issues_ GitHub.
C'est peu mais l'une d'entre elle est intitulée
« __Does not work with any modern version of Node.js__ ».
Ça confirme les doutes du paragraphe précédent :
c'est suffisant pour que je passe mon chemin.

En continuant plus loin dans la liste des résultats de recherche,
je suis tombé sur le module npm nommé _falchion_ :

.Extrait de la page consacrée au module npm _falchion_.
image::images/npm-package-falchion.png[]

Il n'y a qu'une seule version du module, qui date de quatre années
avec une documentation qui tient sur une ligne. +
Il y a très peu de chances que nous puissions en faire quelque chose.

Voici au final ce que j'estime être le plus important pour me faire
une idée d'un module et décider de l'installer ou non :

- présence d'une *documentation* — je peux me faire une idée des fonctionnalités
et de la complexité d'utilisation du module ;
- des badges d'*intégration continue* — je sais ainsi qu'il y a des tests
unitaires qui sont exécutés automatiquement avant que le module soit publié ;
- le nombre de *téléchargements* — je sais si d'autres personnes s'en servent
en espérant qu'ils remontent les problèmes rencontrés ;
- le nombre de *versions* — ça me donne une idée de la mâturité du projet
et de la réactivité aux demandes de la communauté.

Ce sont des *critères subjectifs*.
Un module peut être populaire par ancienneté alors qu'il existe des alternatives,
plus légères ou plus simple d'utilisation.
C'est le cas du module _moment.js_ qui est est plus populaire que _date-fns_
— alors que je préfère ce dernier.

Il y a aussi des modules pour lesquels j'ai une confiance quasi-aveugle.
Ils sont publiés par les personnes présentes dans cette liste non-exhaustive :

[format="csv"]
.Auteurs et autrices de modules npm à suivre
|===
dougwilson, [URL]#https://npmjs.com/~dougwilson#
feross, [URL]#https://npmjs.com/~feross#
fgribreau, [URL]#https://npmjs.com/~fgribreau#
iarna, [URL]#https://npmjs.com/~iarna#
isaacs, [URL]#https://npmjs.com/~isaacs#
jdalton, [URL]#https://github.com/jdalton#
jshttp, [URL]#https://github.com/jshttp#
mbostock, [URL]#https://npmjs.com/~mbostock#
nodejitsu, [URL]#https://github.com/nodejitsu#
rwaldron, [URL]#https://npmjs.com/~rwaldron#
sindresorhus, [URL]#https://npmjs.com/~sindresorhus#
substack, [URL]#https://npmjs.com/~substack#
zkat, [URL]#https://npmjs.com/~zkat#
|===

[TIP]
.[RemarquePreTitre]#Pratique# Sélection de modules npm
====
J'ai compilé une liste de modules utiles pour mieux démarrer
dans vos projets.

Vous la trouverez en <<../appendix-a/index.adoc#,annexe A>>.
====

[[uninstall]]
=== Désinstaller un module

Nous sommes emmenés à remplacer un module par un autre ou à changer d'avis
sur la nécessité d'un module.
L'utilisation de la commande `npm uninstall` nous aidera à supprimer
les fichiers du module en toute sécurité puis à le retirer de la liste
des dépendances du fichier `package.json`.

----
$ npm un cowsay
removed 10 packages in 1.963s
found 0 vulnerabilities
----

Le module _cowsay_ n'est plus installé.
Que se passe-t-il si nous exécutons à nouveau un des premiers exemples de cette
section ?

----
$ node cow.js
internal/modules/cjs/loader.js:596
    throw err;
    ^

Error: Cannot find module 'cowsay'
----

Une nouvelle erreur se produit sous nos yeux.
Le chargement du module _cowsay_ a échoué car Node n'arrive pas à le trouver
— et c'est normal.

Nous devons à nouveau lancer la commande `npm install cowsay`
pour que le script fonctionne à nouveau.


[[install]]
=== Depuis un fichier `package.json`

Jusqu'à présent, nous avons installé des modules car nous les ajoutions
au projet.
La procédure est légèrement différente si nous avons à installer à nouveau
des dépendances déjà listées dans le champ `dependencies` du fichier
`package.json`.

Pour en avoir le cœur net, plaçons nous dans le répertoire qui contient
le fichier `package.json` et supprimons le répertoire `node_modules`
qui contient les dépendances déjà installées.
Exécutons ensuite la commande `npm install` sans autre argument :

----
$ rm -rf node_modules
$ npm install
added 10 packages from 3 contributors in 2.276s
found 0 vulnerabilities
----

Au final, la commande `npm install` est s'utilise quand
nous récupérons du code avec Git pour la première fois ou après une mise à jour,
par exemple avec `git pull`.

L'exécutable `npm` vérifie toujours que les modules npm installés dans
le répertoire `node_modules` correspondent bien à ceux qui sont listés
dans le fichier `package.json`.
Il installe, met à jour et retire les modules npm en fonction de ce
qui est nécessaire.

=== Spécifier une version

L'exécutable `npm` installe la dernière version d'un module par défaut.
Nous avons la liberté d'en installer d'autres qui sont antérieures.
C'est pratique quand des modules npm arrêtent de supporter
des navigateurs web ou des versions de Node alors que nous les utilisons encore.

Nous allons utiliser le module _lodash_ ([URL]#https://npmjs.com/lodash#)
pour illustrer nos allées et venues entre différentes versions.
À l'heure où j'écris ces lignes, la version la plus récente sur le registre npm
est la `{lodashVersion}`.
C'est ce que rapporte le résultat de la commande `npm install lodash` :

[subs="+attributes"]
----
$ npm install lodash
+ lodash@{lodashVersion}
----

L'utilisation du caractère `@` indique le numéro de version souhaité à
l'exécutable `npm` :

----
$ npm install lodash@3.0.0
+ lodash@3.0.0
----

Nous avons installé une version précise mais il y a surement des mises à jour
qui ont suivi pour corriger des bugs.
Le problème est qu'à ce stade, nous ne connaissons pas le numéro de version
à spécifier.
Idéalement, je préfèrerais installer la version la plus récente de la série 3.
Il se trouve que l'exécutable `npm` sait le faire pour nous et sans effort :

----
$ npm install lodash@3
+ lodash@<i>3.10.1</i>
----

Nous pouvons faire la même chose avec la version
la plus récente de la série 3 et de la série 2.2 :

----
$ npm install lodash@3
+ lodash@3.10.1
$ npm install lodash@2.2
+ lodash@2.2.1
----

[TIP]
.[RemarquePreTitre]#Pratique# Connaître toutes les versions d'une module
====
La <<view,commande `npm view`>> retourne les informations d'un module npm
directement depuis notre terminal.
Elle retourne toutes les versions publiées avec l'argument `versions` :

----
$ npm view lodash <i>versions</i>
[ '0.1.0',
  '0.2.0',
  ...
  '1.0.0',
  '1.0.1',
  '1.0.2',
  ... ]
----
====

Revenons à la version la plus récente en réutilisant la
<<install,commande d'installation>> abordée auparavant :

----
$ npm install lodash
+ lodash@2.4.2
----

Quelque chose d'inattendu s'est produit : la version la plus récente
de la série 2 a été installée au lieu de la version {lodashVersion}. +
Nous trouverons un élément de réponse dans le fichier `package.json` :

[source,json,subs="-specialchars"]
.package.json
----
{
  ...
  "dependencies": {
    "cowsay": "^1.3.0",
    "lodash": "<i>^2.4.2</i>"
  }
}
----

L'exécutable `npm` respecte la version précisée dans le fichier `package.json`
si elle n'est pas précisée dans la commande.
Si la dépendance n'est pas listée, alors l'exécutable `npm` installe la version
la plus récente.

L'étiquette `latest` explicite notre envie d'installer la version
la plus récente et sans tenir compte du fichier `package.json` :

[subs="+attributes"]
----
$ npm install lodash@<i>latest</i>
+ lodash@{lodashVersion}
----

Nous sommes désormais en mesure de choisir entre différentes versions
d'un module et de manière plus ou moins fine. +
Nous prendrons le temps d'explorer le mécanisme de numérotation des versions
dans la section suivante afin de mieux comprendre ce qui est renseigné
dans le fichier `package.json`.

[TIP]
.[RemarquePreTitre]#Pratique# Connaître les étiquettes d'un module
====
La <<view,commande `npm view`>> va à nouveau nous aider.
Elle retourne toutes les versions publiées avec l'argument `dist-tags` :

[subs="+attributes"]
----
$ npm view lodash dist-tags
{ <i>latest</i>: '{lodashVersion}' }
----

Ce mécanisme d'étiquette sert de raccourci pour associer un numéro de version
(qui change) à un intitulé (qui reste dans le temps).
====


[[semver]]
=== Comprendre les numéros de versions (_Semantic Versioning_)

[format="csv", options="header", cols="1,2,3,3"]
.Auteurs et autrices de modules npm à suivre
|===
Symbole, Version, Représentation alternative, Représentation étendue
   , `1.0.0`, `1.0.0`, `1.0.0`
`^`, `^1.0.0`, `1.x.x`, `>=1.0.0 <2.0.0`
`~`, `~1.0.0`, `1.0.x`, `>=1.0.0 <1.1.0`
`*`, `*`, `x.x.x`, `>=0.0.1`
|===

Cette syntaxe est notamment employée pour spécifier les plages de mises à jour  acceptées pour les paquets `npm`.
Cela permet entre autres de bénéficier de mises à jour de manière consentante (_opt-in_) à chaque installation ou mise à jour de vos applications.

[TIP]
.[RemarquePreTitre]#Outil# Calculateur de version
====
Un outil est à disposition pour tester la syntaxe des plages de versions en temps réel sur des données de véritables paquets.

- [URL]#https://semver.npmjs.com#
====

[[update]]
=== Mises à jour

== Autres manières d'installer et d'utiliser des modules npm

=== Depuis un répertoire local

=== Depuis GitHub, GitLab ou un dépôt Git

=== En tant que dépendance de développement

=== En tant qu'exécutable système (installation globale)


[NOTE]
.[RemarquePreTitre]#Lien# Versioning romantique
=====
Certaines personnes pensent que l'aspect _sémantique_ n'est pas assez clair pour véhiculer l'_intention_ des auteurs quant à la publication d'une nouvelle version.
Ils en sont venus à proposer plus ou moins sérieusement les notions de *versioning sentimental* et de *versioning romantique*.

- [URL]#http://dafoster.net/articles/2015/03/14/semantic-versioning-vs-romantic-versioning/#
=====

== Outiller un projet avec les scripts npm

=== Démarrer l'application

=== Exécuter des tests


L'écriture de tests et la vérification de la qualité de votre code sont un excellent
moyen de vous assurer que de nouveaux bugs ne sont pas introduits dans votre application.

Écrire des modules et les empiler sans écrire de tests revient à construire un
château de carte : le moindre changement accentue le risque de propager des
erreurs dans toutes les applications en dépendant.

Nous verrons ultérieurement comment écrire des tests unitaires pour vos
applications et votre code exécuté dans un contexte Web.

À la manière du démarrage d'une application, la commande npm fournit un
contexte d'exécution dédié aux tests :

----
$ npm test
----

Cette commande effectue deux choses :

- elle règle la variable d'environnement `NODE_ENV` à `test` ;
- elle exécute l'instruction du script `test` déclarée dans le fichier `package.json` :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*"
  }
}
----

Dans cet exemple, exécuter la commande `npm test` revient à actionner l'exécutable
déclaré par le module _mocha_ avec comme argument l'ensemble des fichiers
JavaScript contenus dans le répertoire `tests/` de notre projet.

En cas de test fautif, l'exécutable de tests affichera des précisions quant à
leur origine et se terminera avec un code de sortie différent de 0.

Ce qui signifie en jargon Unixien que vous pouvez chaîner la commande avec
d'autres actions basées sur un état de réussite des tests :

----
$ npm test && git push
----

Cette précédente commande a deux scénarios possibles :

1. `npm test` échoue et `git push` ne sera pas exécuté ;
2. `npm test` réussit et `git push` sera exécuté.

En se basant sur ce principe de chaîne, vous pouvez faire évoluer votre commande
de test en quelque chose de plus poussé :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "npm run lint-code && npm run unit-tests",
    "lint-code": "eslint ",
    "unit-tests": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*",
    "eslint": "^3.0.0"
  }
}
----

La commande `npm test` est alors composée de deux autres commandes personnalisées.
Vous maintenez ainsi une lisibilité au sein de votre fichier `package.json`
tout en bénéficiant d'une indépendance d'exécution de vos commandes.


== Publier un module npm

=== Le champ `main` du fichier `package.json`

=== Choisir une licence d'utilisation

=== Renseigner les informations importantes

Cf. #heuristics


== Quelques commandes pour aller plus loin

[[view]]
=== `npm view` : voir les informations d'un module

[[home]]
=== `npm home` : visiter le site web d'un module

[[audit]]
=== `npm audit` : vérifier la sécurité des dépendances

[[prune]]
=== `npm prune` : supprimer les dépendances inutilisées

[[doctor]]
=== `npm doctor` : vérifier l'état du système

[[config]]
=== `npm config` : changer les réglages de l'exécutable `npm`

[[link]]
=== `npm link` : utiliser une dépendance qui n'a pas encore été publiée


== Questions et mystères autour de npm

=== Je ne vois pas l'intérêt du fichier `package-lock.json`

=== npm c'est pour le backend, bower (ou autre) pour le frontend

=== Est-ce que je dois versionner le répertoire `node_modules` ?

=== Il paraît que Yarn, c'est mieux

=== npm est lent, il installe la moitié d'Internet à chaque fois

=== Que signifient les erreurs affichées pendant `npm install` ?


== Conclusion
