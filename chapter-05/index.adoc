:chapterNumber: 5
:chapterId: chapter-05
:sourceDir: ./examples
:httpRoot: http://localhost:3000
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:lodashVersion: 4.17.10
:mochaVersion: 5.2.0
:serveVersion: 7.2.0
:microVersion: 9.3.2
:npmvX: 6.1.0
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Jouer avec npm

TBD.

====
.Sommaire
- Créer un fichier `package.json`
- Installer un module npm
- Outiller un projet avec les scripts npm
- Quelques commandes pour aller plus loin
- Questions et mystères autour de npm
====

[abstract]
--
TBD.
--

include::../resources/tip-versions.adoc[]

Le mot _npm_ correspond à trois concepts différents que nous aborderons
tout au long de ce chapitre :

- l'*exécutable* `npm` — un programme écrit en JavaScript ;
- le *registre* _npm_ — une plate-forme de distribution de modules ;
- un *module* _npm_ — en général installé depuis le registre et utilisable avec la fonction `require()`.

Je préciserai toujours si l'utilisation de _npm_ fait référence
à l'_exécutable_, au _registre_ ou à un _module_.

L'exécutable `npm` est installé par défaut avec Node.
Vérifions la version installée en ouvrant un terminal
et en écrivant la commande suivante :

[subs="+attributes"]
----
$ npm --version
{npmvX}
----

Si un message s'affiche en indiquant que `npm` n'est pas un programme reconnu,
veuillez vous référer au <<../chapter-02/index.adoc,chapitre 2>> et
vérifier que Node {nodeCurrentVersion} est bien installé.

include::../resources/tip-examples.adoc[]


[[cli]]
== Créer un fichier `package.json`

La présence d'un fichier `package.json` est nécessaire pour utiliser npm
dans un projet.
La commande `npm init` génère un tel fichier en nous posant des questions.
Nous irons plus vite en utilisant l'option `--yes` :

----
$ npm init --yes
----

Le fichier `package.json` sera créé avec le contenu suivant :

----
{
  "name": "<nom du répertoire>",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
----

Si le fichier existait déjà, la copie existante sera préservée et affichée
à l'écran.

Nous allons ignorer le contenu du fichier dans un premier temps
afin de nous focaliser sur l'opération la plus importante et la plus
fréquemment utilisée :
l'installation de modules npm avec la commande `npm install`.

[[modules]]
== Installer des modules npm

Le mécanisme de modules est documenté dans
le <<../chapter-04/index.adoc#,chapitre 4>>.
La fonction `require()` charge nos propres modules mais aussi
les modules de base, proposés par Node.
Les modules npm sont des *modules complémentaires et téléchargeables* à l'aide
de l'exécutable `npm`.

Cette section va nous aider à comprendre ce qu'il se passe sous le capot
pendant les phases d'installation, de mise à jour et de désinstallation
des modules npm.

=== Depuis le registre npm

Le registre npm ([URL]#https://npmjs.com#) est l'hébergement principal
des modules JavaScript.

La commande `npm install` s'utilise directement quand nous connaissons déjà
le nom d'un module à installer,
par exemple le module _cowsay_ ([URL]#https://npmjs.com/cowsay#) :

----
$ npm install cowsay
+ cowsay@1.3.0
added 10 packages from 3 contributors in 1.667s
found 0 vulnerabilities
----

Le module est installé et prêt à être inclus dans un script.
Nous pouvons aussi constater que le champ `dependencies` est apparu
dans le fichier `package.json` :

[source,json]
.package.json
----
{
  ...
  "dependencies": {
    "cowsay": "^1.3.0"
  }
}
----

L'exécutable `npm` tient les comptes des modules installés à notre demande.
Ça nous sera utile pour <<install,installer les modules sur un autre ordinateur>>.
Nous reviendrons plus tard sur la notation des versions
— on en reparlera sous le nom de _versions sémantiques_ (_Semantic Versionning_).

[source%interactive,javascript]
.cow.js
----
include::{sourceDir}/cow.js[]
----

Nous pouvons remarquer que l'inclusion d'un module npm est identique
à celle d'un <<../chapter-04/index.adoc#modules-builtin,module de base>>. +
Regardons le résultat sans plus tarder :

----
$ node cow.js
___________
< Bonjour ! >
-----------
       \   ^__^
        \  (oo)\_______
           (__)\       )\/\
               ||----w |
----

L'utilisation d'un module npm nous a permis d'utiliser du code sans avoir à le
créer alors qu'il n'était pas fourni par la plate-forme Node.

Maintenant que nous savons installer un module npm, nous pouvons en chercher
d'autres et comprendre comment les utiliser.

[NOTE]
.[RemarquePreTitre]#Question# Où sont stockés les modules npm ?
====
Les modules npm et leurs dépendances sont stockés dans un répertoire
`node_modules`.
Ce répertoire est situé au même niveau que le fichier `package.json`.
====


[NOTE]
.[RemarquePreTitre]#Sous le capôt# Ce que fait l'exécutable `npm` pendant l'installation
====
L'exécutable `npm` effectue un bon nombre d'actions après avoir
saisi la commande `npm install cowsay` :

1. il interroge le registre _npmjs.com_ pour obtenir des informations sur le module demandé ;
2. il détermine que `1.3.0` est la version la plus récente ;
3. il télécharge une archive compressée (`.tar.gz`) qui contient tous les fichiers de la version `1.3.0` ;
4. l'archive est décompressée dans le répertoire `node_modules` ;
5. les dépendances sont elles aussi téléchargées puis décompressées dans le répertoire `node_modules` ;
6. le module `cowsay` est inscrit dans le fichier `package.json`.
====

[NOTE]
.[RemarquePreTitre]#Remarque# Dépendances de développement
====
Il existe une variante de la commande pour distinguer les dépendances
spécifiques à l'outillage du projet.
Rendez-vous dans la section <<install.dev,dépendances de développement>>
pour en savoir plus.
====


[[registry]]
=== Trouver son bonheur dans le registre npm

Le _registre npm_ ([URL]#https://npmjs.com#) fourmille de modules
— de simples fonctions, des librairies ou des _frameworks_ complets.
Ils couvrent un spectre d'usages allant de l'accès aux bases de données,
à des frameworks web, à des outils frontend, des utilitaires de test,
de compression de données, du paiement bancaire, des frameworks mobiles, etc.

Essayons de chercher une librairie qui puisse nous connecter à une
base de données MySQL ou MariaDB.
Tapez `mysql` dans le champ de recherche du registre npm ou saisissez
directement l'URL menant aux résultats de cette recherche en vous
rendant sur [URL]#https://npmjs.com/search?q=mysql# :

.Extrait des résultats d'une recherche de modules npm avec le mot-clé _mysql_.
image::images/npm-registry-search.png[]

Les résultats sont triés par pertinence — un mélange entre popularité,
qualité et maintenance des projets.

Je trouve qu'il est difficile de décider uniquement en regardant la liste.
J'ai tendance à ouvrir un onglet par module pour lire leur documentation.
Prenons le cas du module _mysql2_ ([URL]#https://npmjs.com/mysql2#) justement :

.Extrait de la page consacrée au module npm _mysql2_.
image::images/npm-package-mysql2.png[]

Plusieurs éléments de cette page tendent à me rassurer
et m'aident à juger de la robustesse de ce module :

- les badges colorés qui affichent le statut d'exécution des tests ;
- une introduction de *documentation claire et concise* ;
- un *nombre de téléchargements* en progrès réguliers ;
- il s'utilise avec des <<../chapter-03/index.adoc#promise,promesses>> ;
- le nombre important de modules dépendants ;
- *je reconnais une autrice* qui contribue du code de qualité
— Rebecca Turner ([URL]#https://npmjs.com/~iarna#).

J'ai un doute quand je lis _108 issues_ et _13 pull requests_.
Dans ce cas-là je me dis que les personnes qui maintiennent le projet ne sont
pas forcément très réactives.

Cependant, il y a suffisamment d'indicateurs au vert pour l'installer à coup de
`npm install mysql2` puis à l'essayer dans un script.

Le module _mysql-libmysqlclient_ ([URL]#https://npmjs.com/mysql-libmysqlclient#)
ne me fait pas du tout le même effet :

.Extrait de la page consacrée au module npm _mysql-libmysqlclient_.
image::images/npm-package-mysql-libmysqlclient.png[]

La page du module ne met pas d'exemple simple à comprendre et fait référence
à des versions de Node antédiluviennes.
Rien n'indique qu'il ne peut pas fonctionner avec Node {nodeCurrentVersion}
mais la présence du mot _binding_ m'évoque que l'installation du module
compile un programme écrit dans un autre langage
— en l'occurrence, _libmysqlclient_.

Point positif : il n'y a que 14 _issues_ GitHub.
C'est peu mais l'une d'entre elle est intitulée
« __Does not work with any modern version of Node.js__ ».
Ça confirme les doutes du paragraphe précédent :
c'est suffisant pour que je passe mon chemin.

En continuant plus loin dans la liste des résultats de recherche,
je suis tombé sur le module npm nommé _falchion_ :

.Extrait de la page consacrée au module npm _falchion_.
image::images/npm-package-falchion.png[]

Il n'y a qu'une seule version du module, qui date de quatre années
avec une documentation qui tient sur une ligne. +
Il y a très peu de chances que nous puissions en faire quelque chose.

---

Voici au final ce que j'estime être le plus important pour me faire
une idée d'un module et décider de l'installer ou non :

- présence d'une *documentation* — je peux me faire une idée des fonctionnalités
et de la complexité d'utilisation du module ;
- des badges d'*intégration continue* — je sais ainsi qu'il y a des tests
unitaires qui sont exécutés automatiquement avant que le module soit publié ;
- le nombre de *téléchargements* — je sais si d'autres personnes s'en servent
en espérant qu'ils remontent les problèmes rencontrés ;
- le nombre de *versions* — ça me donne une idée de la maturité du projet
et de la réactivité aux demandes de la communauté.

Ce sont des *critères subjectifs*.
Un module peut être populaire par ancienneté alors qu'il existe des alternatives,
plus légères ou plus simple d'utilisation.
C'est le cas du module _moment.js_ qui est plus populaire que _date-fns_
— alors que je préfère ce dernier.

Il y a aussi des modules dans lesquels j'ai une confiance quasi-aveugle.
Ils sont publiés par les personnes présentes dans cette liste non-exhaustive :

[format="csv"]
.Auteurs et autrices de modules npm à suivre
|===
dougwilson, [URL]#https://npmjs.com/~dougwilson#
feross, [URL]#https://npmjs.com/~feross#
fgribreau, [URL]#https://npmjs.com/~fgribreau#
iarna, [URL]#https://npmjs.com/~iarna#
isaacs, [URL]#https://npmjs.com/~isaacs#
jdalton, [URL]#https://github.com/jdalton#
jshttp, [URL]#https://github.com/jshttp#
mbostock, [URL]#https://npmjs.com/~mbostock#
nodejitsu, [URL]#https://github.com/nodejitsu#
rwaldron, [URL]#https://npmjs.com/~rwaldron#
sindresorhus, [URL]#https://npmjs.com/~sindresorhus#
substack, [URL]#https://npmjs.com/~substack#
zkat, [URL]#https://npmjs.com/~zkat#
|===

[TIP]
.[RemarquePreTitre]#Pratique# Sélection de modules npm
====
J'ai compilé une liste de modules utiles pour mieux démarrer
dans vos projets.
Vous la trouverez en <<../appendix-a/index.adoc#,annexe A>>.
====

[[uninstall]]
=== Désinstaller un module

L'utilisation de la commande `npm uninstall` supprime un module npm
et les fichiers qu'il a installé en toute sécurité.
La commande le retire ensuite de la liste des dépendances
du fichier `package.json`.

----
$ npm uninstall cowsay
removed 10 packages in 1.963s
found 0 vulnerabilities
----

Le module _cowsay_ n'est plus installé.
Que se passe-t-il si nous exécutons à nouveau un l'exemple `cow.js` ?

----
$ node cow.js
internal/modules/cjs/loader.js:596
    throw err;
    ^

Error: Cannot find module 'cowsay'
----

Le chargement du module _cowsay_ a échoué car Node n'arrive pas à le trouver
— et c'est normal.

Nous devons à nouveau lancer la commande `npm install cowsay`
pour que le script fonctionne à nouveau.


[[install]]
=== Depuis un fichier `package.json`

Jusqu'à présent, nous avons installé des modules en les ajoutant un par un.
La procédure est légèrement différente quand nous installons le projet de zéro
ou si le fichier `package.json` a été mis à jour par un·e collègue, par exemple.

Pour en avoir le cœur net, plaçons-nous dans le répertoire qui contient
le fichier `package.json` et supprimons le répertoire `node_modules`
qui contient les dépendances déjà installées.
Exécutons ensuite la commande `npm install` sans autre argument :

----
$ cd $(nodebook dir chapter-05 --root)
$ rm -rf node_modules
$ npm install
added 164 packages from 583 contributors in 4.781s
found 0 vulnerabilities
----

Au final, la commande `npm install` s'utilise de manière systématique quand
nous récupérons du code avec Git pour la première fois (`git clone`)
ou après une mise à jour, par exemple avec `git pull`.

L'exécutable `npm` vérifie toujours que les modules npm installés dans
le répertoire `node_modules` correspondent bien à ceux qui sont listés
dans le fichier `package.json`.
Il installe, met à jour et retire les modules npm en fonction de ce
qui est nécessaire.

[[install.version]]
=== Spécifier une version

Par défaut, l'exécutable `npm` installe la dernière version d'un module.
Nous avons la liberté d'en installer d'autres qui sont antérieures.
C'est pratique quand des modules npm arrêtent de supporter
des navigateurs web ou des versions de Node alors que nous les utilisons encore.

Nous allons utiliser le module _lodash_ ([URL]#https://npmjs.com/lodash#)
pour illustrer nos allées et venues entre différentes versions.
À l'heure où j'écris ces lignes, la version la plus récente _lodash_
est la `{lodashVersion}`.
C'est ce que rapporte le résultat de la commande `npm install lodash` :

[subs="+attributes"]
----
$ npm install lodash
+ lodash@{lodashVersion}
----

L'utilisation du caractère `@` conjointe à un numéro de version précise
la version à installer :

----
$ npm install lodash@3.0.0
+ lodash@3.0.0
----

Nous avons installé une version précise mais il y a surement des mises à jour
qui ont suivi pour corriger des bugs.
Le problème est qu'à ce stade, nous ne connaissons pas le numéro de version
à spécifier.
Idéalement, je préfèrerais installer la version la plus récente de la série 3.
Il se trouve que l'exécutable `npm` sait le faire pour nous et sans effort :

----
$ npm install lodash@3
+ lodash@<i>3.10.1</i>
----

Nous pouvons faire la même chose avec la version
la plus récente de la série 3 et de la série 2.2 :

----
$ npm install lodash@3
+ lodash@3.10.1
$ npm install lodash@2.2
+ lodash@2.2.1
----

[TIP]
.[RemarquePreTitre]#Pratique# Connaître toutes les versions d'un module
====
La <<view,commande `npm view`>> affiche les informations d'un module npm
directement depuis notre terminal.
Elle affiche toutes les versions publiées avec l'argument `versions` :

----
$ npm view lodash <i>versions</i>
[ '0.1.0',
  '0.2.0',
  ...
  '1.0.0',
  '1.0.1',
  '1.0.2',
  ... ]
----
====

Revenons à la version la plus récente en réutilisant la
<<install,commande d'installation>> abordée auparavant :

----
$ npm install lodash
+ lodash@2.4.2
----

Quelque chose d'inattendu s'est produit : la version la plus récente
de la série 2 a été installée au lieu de la version {lodashVersion}.
Nous trouverons un élément de réponse dans le fichier `package.json` :

[source,json,subs="-specialchars"]
.package.json
----
{
  ...
  "dependencies": {
    "cowsay": "^1.3.0",
    "lodash": "<i>^2.4.2</i>"
  }
}
----

L'exécutable `npm` respecte la version précisée dans le fichier `package.json`
si elle n'est pas précisée dans la commande.
Si la dépendance n'est pas listée, alors l'exécutable `npm` installe la version
la plus récente.

L'étiquette `latest` explicite notre envie d'installer la version
la plus récente et sans tenir compte du fichier `package.json` :

[subs="+attributes"]
----
$ npm install lodash@<i>latest</i>
+ lodash@{lodashVersion}
----

Nous sommes désormais en mesure de choisir entre différentes versions
d'un module et de manière plus ou moins fine.

Nous prendrons le temps d'explorer le mécanisme de numérotation des versions
dans la section suivante afin de mieux comprendre ce qui est renseigné
dans le fichier `package.json`.

[TIP]
.[RemarquePreTitre]#Pratique# Connaître les étiquettes d'un module
====
La <<view,commande `npm view`>> va à nouveau nous aider.
Elle affiche toutes les versions publiées avec l'argument `dist-tags` :

[subs="+attributes"]
----
$ npm view lodash dist-tags
{ <i>latest</i>: '{lodashVersion}' }
----

Ce mécanisme d'étiquette sert de raccourci pour associer un numéro de version
(qui change) à un intitulé (qui reste dans le temps).
====


[[semver]]
=== Comprendre les numéros de versions (_Semantic Versioning_)

Les numéros de versions ont été utilisées de deux manières dans les
sections précédentes : avec l'exécutable `npm` et en observant la liste
de dépendances dans le fichier `package.json`.

L'exécutable `npm` découpe un numéro de version en trois parties :
_majeur_, _mineur_ et _patch_.
Pour le numéro de version `1.2.3`, `1` est le numéro de version majeur,
`2` est le numéro de version mineur tandis que  `3` est le numéro de version patch.

Si nous devions mettre à jour `lodash@2.2.0` :

- vers `lodash@2.2.1` : mise à jour patch — des bugs sont corrigés ;
- vers `lodash@2.4.2` : mise à jour mineure — des fonctionnalités sont ajoutées,
corrigées ou modifiées et ce, sans affecter notre code ;
- vers `lodash@{lodashVersion}` : mise à jour majeure — des fonctionnalités ont
été modifiées, remaniées ou supprimées et peuvent casser notre code qui repose dessus.

Une mise à jour majeure demande de lire attentivement la documentation du module
pour comprendre le volume de travail à fournir avant de monter en version.
La mise à jour mineure peut occasionnellement demander du travail selon
interprétation des développeurs de modules npm.

[format="csv", options="header", cols="1,2,3,3"]
.Différentes manières d'exprimer des versions
|===
Symbole, Version, Représentation alternative, Représentation étendue
   , `1.0.0`, -, -
`^`, `^1.0.0`, `1.x.x`, `>=1.0.0 <2.0.0`
`~`, `~1.0.0`, `1.0.x`, `>=1.0.0 <1.1.0`
`*`, `*`, `x.x.x`, `>=0.0.1`
|===

Je ne pense pas qu'il soit nécessaire de se sentir obligé·e de toujours
être positionné·e sur la dernière version majeure.
Les versions patch et mineures sont plus importantes à mes yeux
car elles contiennent des corrections qui peuvent bénéficier à nos applications.

[TIP]
.[RemarquePreTitre]#Pratique# Calculateur de version
====
L'outil en ligne [URL]#https://semver.npmjs.com# sert à tester
la syntaxe des versions sémantiques avec de véritables modules npm.
====

[[update]]
=== Mises à jour

Nous avons appris à installer des modules npm dans les versions de notre choix
et à les réinstaller depuis la liste contenue dans le fichier `package.json`.
Comment savoir si ces derniers sont à mettre à jour ?

L'utilisation combinée des commandes `npm outdated` et `npm update` va
nous permettre d'y arriver.
Il sera plus facile de comprendre cette partie si vous vous êtes familiarisé·e
avec la notion de <<semver,version sémantique>>.

Commençons par installer d'anciennes versions des modules _lodash_ et _cowsay_ :

----
$ npm install lodash@2.0.0 cowsay@1.0.0
----

La commande `npm outdated` affiche les dépendances qui ne sont pas à jour :

[subs="+attributes"]
----
$ npm outdated
Package  Current  Wanted   Latest  Location
cowsay     1.0.0   1.3.0    1.3.0  nodebook.chapter-05
lodash     2.0.0   2.4.2  {lodashVersion}  nodebook.chapter-05
----

Le numéro de version affiché dans la colonne `Wanted` est celui qui sera atteint
avec la commande `npm update`.

----
$ npm update
+ cowsay@1.3.0
+ lodash@2.4.2
added 7 packages and updated 3 packages in 2.717s
----

Observons ce qui a changé dans les résultats de la commande `npm oudated` :

[subs="+attributes"]
----
$ npm outdated
Package  Current  Wanted   Latest  Location
lodash     2.4.2   2.4.2  {lodashVersion}  nodebook.chapter-05
----

Seul le module _lodash_ est désormais listé.
Les modules _cowsay_ et _lodash_ ont été mis à jour au plus sûr.
Le module _lodash_ peut rester en l'état si nous n'avons pas le temps
de rendre notre code compatible avec ses changements.

Sinon, une <<install.version,installation manuelle>> s'impose
avec l'étiquette `latest` :

[subs="+attributes"]
----
$ npm install lodash@latest
+ lodash@{lodashVersion}
----

Un dernier appel à `npm outdated` nous permet d'en avoir le cœur net :

----
$ npm outdated
----

Si rien ne s'affiche, c'est que tout est bon : nos modules sont à jour !

== Autres manières d'installer et d'utiliser des modules npm

Dans la section précédente, nous avons appris à installer des modules
depuis le registre npm. +
Dans cette section, nous allons apprendre à les installer depuis des sources
variées, uniquement à des fins de développement ou en tant que
commandes exécutables au niveau du système d'exploitation.

[[install.git]]
=== Depuis GitHub, GitLab ou un dépôt Git

Il arrive que nous ayons à utiliser une version modifiée d'un module npm
avant que l'auteur ou autrice accepte une correction de bug qui nous affecte.
Ça vaut aussi pour des modules dont le code serait hébergé dans un dépôt privé
et que nous ne voulons pas publier sur le registre npm.

Le module npm _cowsay_ est hébergé sur GitHub à l'adresse
[URL]#https://github.com/piuccio/cowsay#.

----
$ npm install github:piuccio/cowsay
+ cowsay@1.3.0
updated 1 package in 5.866s
----

Il s'agit en réalité d'une écriture raccourcie.
Nous sommes aussi en mesure d'utiliser l'URL d'un dépôt Git
— pas forcément GitHub ou GitLab donc :

----
$ npm install https://github.com/piuccio/cowsay
+ cowsay@1.3.0
updated 1 package in 4.513s
----

[CAUTION]
.[RemarquePreTitre]#Considérations# Performance d'accès à Git
====
L'installation est plus lente depuis un dépôt Git que depuis un registre npm.
L'exécutable `npm` fait appel à l'exécutable `git` pour cloner l'historique
du dépôt et de ses dépendances pour extraire la version adéquate
de la copie de travail.

Le temps de téléchargement sera proportionnel au nombre de _commits_.
====

L'exécutable `npm` sait aussi installer des modules avec les protocoles
`git+ssh` et `git`.

----
$ npm install git://github.com:piuccio/cowsay.git
+ cowsay@1.3.0
updated 1 package in 10.263s
----

Les clients Git ou SSH doivent être configurés au niveau du système pour
être en mesure de s'authentifier sur l'hôte distant. +
C'est une solution à privilégier pour les dépôts privés — la configuration
des dépôts privés via le protocole `https` est trop difficile à automatiser.

[[install.dev]]
=== Dépendance de développement

Les dépendances de développement sont des modules npm utilisés
pour *exécuter les tests unitaires*.
Les *modules utilisés pour de l'outillage* et qui ne sont pas appelés
avec la fonction `require()` sont aussi des dépendances de développement.

Par exemple, le module npm _mocha_ est utilisé pour structurer et exécuter
des tests unitaires pour Node et les navigateurs web.
Il serait donc logique de l'installer comme dépendance de développement.
L'option `--save-dev` permet de signaler cette intention à l'exécutable `npm` :

[subs="+attributes"]
----
$ npm install --save-dev mocha
+ mocha@{mochaVersion}
----

L'exécutable `npm` range alors ce module dans une nouvelle section du
fichier `package.json` — la section `devDependencies` :

[source,json,subs="+attributes,-specialchars"]
----
{
  ...
  "dependencies": {
    "cowsay": "^1.3.0",
    "lodash": "^{lodashVersion}"
  },
  "<i>devDependencies</i>": {
    "mocha": "^5.2.0"
  }
}
----

Les dépendances de développement sont installées uniquement lorsque
la commande `npm install` est invoquée dans le même répertoire
que le fichier `package.json`

À l'inverse, si nous faisons `npm install cowsay`, ses dépendances de
développement ne seront pas installées pour gagner du temps.


[TIP]
.[RemarquePreTitre]#Optimisation# Installer seulement les dépendances de production
====
La <<install,commande `npm install`>> accepte l'option `--production`.
Seules les dépendances listées dans la section `dependencies`
du fichier `package.json` seront alors installées :

----
$ npm install --production
----
====

[[install.global]]
=== Exécutable système (installation globale)

Nous avons parlé des modules npm comme des modules complémentaires,
utilisés avec la fonction `require()` et téléchargés avec l'exécutable `npm`.
Certains modules npm se déclarent comme exécutables depuis un terminal.

C'est le cas du module _serve_ ([URL]#https://npmjs.com/serve#), par exemple.
Il démarre un serveur web en ligne de commande pour tester le rendu
de fichiers HTML sans avoir à configurer de logiciels comme _Apache_ ou _nginx_.

L'installation est rendue globale — à l'échelle du système d'exploitation
— avec l'utilisation de l'option `--global` :

[subs="+attributes"]
----
$ npm install <i>--global</i> serve
+ serve@{serveVersion}
----

[NOTE]
.[RemarquePreTitre]#Question# Comment savoir si un module npm s'installe comme un exécutable système ?
====
En général, les modules npm qui se prêtent bien au jeu du `npm install --global`
sont ceux qui documentent des exemples de commande à exécuter,
qui se décrivent comme des outils en ligne de commande ou qui
mentionnent explicitement l'installation globale.
====

L'exécutable `serve` est disponible suite à l'installation globale :

[subs="+attributes"]
----
$ serve --version
{serveVersion}
----

Le module npm s'exécute de manière transparente, sans invoquer Node ni
l'exécutable `npm` :

----
$ serve .
INFO: Accepting connections at http://localhost:3000
----

[TIP]
.[RemarquePreTitre]#Documentation# L'option `--help`
====
Par convention, les modules npm qui s'utilisent en ligne de commande
sont accompagnés d'une documentation.
Ce manuel décrit des cas d'usages ainsi que les options à disposition.

.Affichage de la documentation du module npm _serve_ depuis la ligne de commande.
----
$ serve --help
----
====

Un module npm installé de manière globale se désinstalle en passant l'option
`--global` à la <<uninstall,commande `npm uninstall`>> :

----
$ npm uninstall -g serve
----

Le <<../chapter-08/index.adoc#,chapitre 8>> sera l'occasion d'entrer plus en détails
dans le développement d'exécutables système écrits en ECMAScript.


[[scripts]]
== Outiller un projet avec les scripts npm

Les scripts npm sont des outils puissants qui *autonomisent l'outillage projet*,
*automatisent des actions* manuelles et *simplifient des actions* trop
complexes à mémoriser.

Les scripts npm sont consignés dans la section `scripts` du fichier `package.json`.
Ils se basent sur des scripts Node et des modules npm pour
lancer des actions quand des fichiers sont modifiés,
transformer des feuilles de style, exécuter des tests unitaires ou fonctionnels,
déployer le projet, entre autres.

Les scripts npm permettent de créer des conventions entre nos projets.
Nous pouvons ainsi réutiliser les mêmes noms et adapter les commandes
au projet en question.

[[start]]
=== Démarrer l'application

Le script `npm start` concerne les projets dont le script principal
tourne en continu — une application web par exemple.

L'exemple suivant démarre un serveur web sans que nous ayons à connaître
la commande associée pour démarrer le-dit serveur :

----
$ npm start

> nodebook.chapter-05@1.0.0 start         # <1>
> micro examples/app.js                   # <2>

micro: Accepting connections on port 3000
----
<1> L'exécutable `npm` affiche le nom du script npm en cours d'exécution
<2> `micro examples/app.js` est la commande réellement exécutée par npm

Nous sommes libre de renseigner la valeur du champ `scripts.start`
du fichier `package.json` comme bon nous semble :

[source,json,subs="+attributes"]
.package.json
----
{
  ...
  "scripts": {
    "start": "micro examples/app.js"
  },
  "dependencies": {
    "micro": "^{microVersion}"
  }
}
----

Nous avons utilisé le module npm _micro_ ([URL]#https://npmjs.com/micro#)
pour démarrer une application web.
Plus exactement, nous avons utilisé l'exécutable fourni par ce module.

[TIP]
.[RemarquePreTitre]#Pratique# Les modules npm exécutables dans les scripts npm
====
Les <<install.global,modules npm exécutables>> sont disponibles au niveau du
système lorsqu'ils sont installés avec l'option `--global`.

Les exécutables des modules npm listés dans `dependencies` et `devDependencies`
sont utilisables dans les scripts npm.

Nous pouvons ainsi contenir tous les exécutables nécessaires dans les
dépendances du projet.
====

Nous verrons dans le <<../chapter-06/index.adoc,chapitre 6>> que les
plates-formes de service utilisent aussi la valeur du champ `scripts.start`
pour déterminer comment démarrer notre application.

[[test]]
=== Exécuter des tests

Le script `npm test` concerne tous les projets pour qui nous avons écrit
des tests qu'ils soient unitaires ou fonctionnels.

L'intention de la commande lancée par le script npm est de terminer
en erreur si un des tests n'aboutit pas au résultat escompté.

L'exemple suivant lance un test unitaire qui s'assure de la cohérence
d'un des exemples précédents :

----
$ npm test

> nodebook.chapter-05@1.0.0 test  # <1>
> mocha examples/tests.js         # <2>

app.js
  ✓ prints a cow as a response

1 passing
----
<1> L'exécutable `npm` affiche le nom du script npm en cours d'exécution
<2> `mocha examples/tests.js` est la commande réellement exécutée par npm

Cette fois-ci, nous avons personnalisé la valeur du champ `scripts.test`
du fichier `package.json` :

[source,json,subs="+attributes"]
.package.json
----
{
  ...
  "scripts": {
    "test": "mocha examples/tests.js"
  },
  "devDependencies": {
    "mocha": "^{mochaVersion}"
  }
}
----

Nous avons eu recourt au module npm _mocha_ ([URL]#https://npmjs.com/mocha#).
De même qu'avec le <<start,script de démarrage>>, nous avons eu recourt
à l'exécutable fourni par le module.
En revanche nous l'avons listé dans la <<install.dev,section `devDependencies`>>
car il est relatif à l'outillage du projet.

Les services d'intégration continue lancent le script `npm test`
lorsqu'ils détectent qu'ils ont affaire à un projet Node.

[NOTE]
.[RemarquePreTitre]#Documentation# Scripts définis par npm
====
D'autres scripts que `test` et `start` sont définis par l'exécutable `npm`.
Ils sont tous documentés sur [URL]#https://docs.npmjs.com/misc/scripts#.
====

[[run]]
=== Créer un script npm personnalisé

Les scripts npm personnalisés sont utiles *lorsque nous souhaitons outiller*
notre projet sans forcément que ça soit en rapport avec le lancement des tests
ou de l'application.

Les scripts personnalisés se démarrent avec `npm run` :

----
$ npm <i>run</i> print-args

> nodebook.chapter-05@1.0.0 print-args
> node examples/print-args.js

Rien à signaler.
----

Nous avons créé ce script en configurant la valeur du champ `scripts.print-args`
du fichier `package.json` :

[source,json]
.package.json
----
{
  ...
  "scripts": {
    "print-args": "node examples/print-args.js"
  }
}
----

[TIP]
.[RemarquePreTitre]#Pratique# Lister les scripts disponibles
====
La commande `npm run` (sans argument) liste tous les scripts npm du projet.
====

J'ai développé ces conventions avec le temps :

- `npm run build` : construit les artéfacts à déployer ;
- `npm run deploy` : déploie le projet vers l'hébergeur ;
- `npm run lint` : applique un vérificateur syntaxique au code du projet ;
- `npm run watch` : démarre l'application et la relance à chaque changement.

[TIP]
.[RemarquePreTitre]#Pratique# Passer des arguments à un script npm
====
Une option spéciale nous aide à transmettre des arguments au script en question.
Les arguments doivent être placés à droite de l'option `--` :

----
$ npm run print-args un --test=true
['un']
$ npm run print-args -- un --test=true
['un', '--test=true']
----
====

Un script npm peut faire appel à d'autres scripts npm :

[source,json,subs="-specialchars"]
.package.json
----
{
  ...
  "scripts": {
    "lint": "eslint ./examples",
    "test": "npm run lint <i>&&</i> mocha examples/tests.js"
  }
}
----

J'ai plutôt tendance à découper mes scripts de sorte à ce qu'ils fassent
tous une chose et une seule.
Je peux ainsi les appeler de manière individuelle pour réduire la boucle
de feedback.

[source,json,subs="-specialchars"]
.package.json
----
{
  ...
  "scripts": {
    "lint": "eslint ./examples",
    "test": "npm run lint && npm run test:unit",
    "test:unit": "mocha examples/tests.js"
  }
}
----

La section suivante va nous aider à orchestrer l'exécution des scripts
les uns par rapport aux autres.

[[run-pre-post]]
=== Exécuter des commandes avant et après des scripts npm

L'ordre d'exécution des scripts se contrôle en utilisant les préfixes
`pre` et `post`.
Par exemple, les scripts nommés `pretest` et `posttest` seront exécutés
respectivement avant et après le script `test`.

[source,json,subs="-specialchars"]
.package.json
----
{
  ...
  "scripts": {
    "lint": "eslint ./examples",
    "test": "mocha examples/tests.js",
    "<i>pre</i>test": "npm run lint"
  }
}
----

Dans cet exemple de configuration, l'exécution de la commande `npm test`
lancera d'abord le script `pretest`, puis le script `lint`
puis enfin le script `test` :

----
$ npm test

> nodebook.chapter-05@1.0.0 pretest
> npm run lint
...

> nodebook.chapter-05@1.0.0 lint
> eslint ./examples
...

> nodebook.chapter-05@1.0.0 test
> mocha examples/tests.js
...
----

Ce mécanisme est utile pour s'intercaler sur des temps particuliers
du cycle de vie d'un projet node.
Voici une sélection

[format="csv", options="header", separator=";", cols="1,2,2"]
|===
Script; Quand; Pourquoi
`pretest`; Avant les tests; Préparer l'espace de travail
`posttest`; Après les tests; Vérifier les règles de syntaxe de notre code
`postinstall`; Après installation les dépendances; Préparation significative du projet (téléchargements supplémentaires, etc.)
`prestart`; Avant de démarrer l'application; Préparatifs légers
`prepublishOnly`; Avant de publier le module; Préparation du projet avant de le distribuer (compilation de fichiers, etc.)
|===

[[package.json]]
== Anatomie du fichier `package.json`

TBD.


[[commands]]
== Quelques commandes pour aller plus loin

Nous venons de voir les commandes les plus utilisées de l'exécutable `npm`.
D'autres commandes complètent son utilisation.
Leur intérêt varie en fonction de vos envies et de vos pratiques de développement.
Pas d'inquiétude donc si vous ne les utilisez pas toutes :
j'en parle pour *éclairer quelques points intéressants à explorer*.

[[view]]
=== `npm view` : voir les informations d'un module

La commande `npm view` est une vue synthétique d'un module npm donné.
Elle est similaire à celle que nous pourrions trouver sur le registre npm
mais condensée pour l'affichage dans un terminal.

Nous y retrouvons des informations fournies par les auteurs et autrices du module
ainsi que d'autres, fournies par le registre npm.

----
$ npm view nodebook

nodebook@0.9.1 | CC-BY-NC-SA-4.0 | deps: 6 | versions: 21
Node.js — Apprendre par l'exemple

keywords: nodejs, book, french, livre, learn, apprendre

bin: nodebook

dist
.tarball https://registry.npmjs.org/nodebook/nodebook-0.9.1.tgz
.shasum: 5ea87e9b85782e23164705a49cb7bd2dc4063775
.integrity: sha512-...
.unpackedSize: 15.0 MB

dependencies:
finalhandler: ^1.1.1  serve-static: ^1.13.2
get-port: ^3.2.0      update-check: ^1.5.2
glob: ^7.1.2          yargs: ^11.1.0

maintainers:
- oncletom

dist-tags:
latest: 0.9.1

published 23 hours ago by oncletom
----

[horizontal]
.Sélection de champs que je trouve intéressants.
`bin`::
  Indique la présence d'un ou plusieurs <<install.global,exécutables>>.
`dist`::
  Informations à propos du fichier téléchargé quand
  nous faisons `npm install <module>`.
`dependencies`::
  Les modules additionnels téléchargés lors de l'installation.
`dist-tags`::
  Les étiquettes définies par les auteurs et autrices, utiles quand nous souhaitons
  <<install.version,jongler entre différentes versions>> du module.

Nous pouvons aussi zoomer sur une métadonnée.
Par exemple, le champ `dependencies` pour ne lister que les dépendances directes :

----
$ npm view nodebook dependencies
{ finalhandler: '^1.1.1',
  'get-port': '^3.2.0',
  glob: '^7.1.2',
  'serve-static': '^1.13.2',
  'update-check': '^1.5.2',
  yargs: '^11.1.0' }
----

Il est même possible de zoomer sur un niveau plus fin de métadonnée,
avec une annotation similaire à celle d'un objet ECMAScript :

[subs="-specialchars"]
----
$ npm view nodebook dist.<i>unpackedSize</i>
14985184
$ npm view nodebook dist
{ integrity:
   'sha512-...',
  shasum: '5ea87e9b85782e23164705a49cb7bd2dc4063775',
  tarball:
    'https://registry.npmjs.org/nodebook/nodebook-0.9.1.tgz',
  fileCount: 486,
  <i>unpackedSize</i>: 14985184 }
----

[[npx]]
=== `npx` : exécuter un module sans l'installer

L'<<install.global,installation globale>> est idéale pour installer un module
npm sous forme d'exécutable système.
On peut cependant vite arriver à en installer beaucoup sans vraiment penser à
les enlever quand on n'en a plus besoin.

L'exécutable `npx` (pour `npm executable`) s'installe automatiquement avec npm.
Il agit comme un raccourci en allantrécupérer le module npm désiré
et l'exécute en lui passant les arguments souhaités.

----
$ npx cowsay Magique !
npx: installed 10 in 2.122s
 ___________
< Magique ! >
 -----------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
----

C'est l'équivalent de ces trois commandes, en quelque sorte :

----
$ npm install --global cowsay
$ cowsay Magique !
$ npm uninstall cowsay
----

[[home]]
=== `npm home` : visiter le site web d'un module

Vous vous demandez où trouver davantage de documentation à propos d'un
module npm ?
`npm home` ouvre un nouvel onglet de navigateur et dirige ce dernier
vers sur le site web du module de votre choix.

----
$ npm home lodash
$ npm home micro
----

[[audit]]
=== `npm audit` : vérifier la sécurité des dépendances

[[doctor]]
=== `npm doctor` : vérifier l'état du système

`npm doctor` est une commande utilitaire qui vérifie que npm trouve
tout ce qu'il faut pour bien fonctionner.

L'exécutable `npm` inspecte le système à la recherche de Git,
teste la connectivité vers le registre npm et s'assure qu'il a accès en écriture
à des répertoires essentiels à son bon fonctionnement.

[subs="+attributes"]
----
$ npm doctor
Check                               Value
npm ping                            OK
npm -v                              v{npmVX}
node -v                             {nodeCurrentVersion}.0.0
npm config get registry             https://registry.npmjs.org
which git                           /usr/local/bin/git
Perms check on cached files         ok
Perms check on global node_modules  ok
Perms check on local node_modules   ok
Verify cache contents               verified 4066 tarballs
----

[[config]]
=== `npm config` : changer les réglages de l'exécutable `npm`

[[publish]]
=== `npm publish` : publier un module npm

----
npm notice
npm notice 📦  asciidoctor-extension-interactive-runner@1.2.0
npm notice === Tarball Contents ===
npm notice 740B  package.json
npm notice 1.3MB demo.gif
npm notice 1.8kB index.js
npm notice 1.1kB LICENSE
npm notice 1.0kB README.md
npm notice 2.1kB src/docinfo.js
npm notice 730B  src/style.css
npm notice === Tarball Details ===
npm notice name:          asciidoctor-extension-interactive-runner
npm notice version:       1.2.0
npm notice package size:  1.2 MB
npm notice unpacked size: 1.3 MB
npm notice shasum:        c55c6f98f7817a0dc45e6bb4700d5aaa4accc002
npm notice integrity:     sha512-hVR01IMtWHhrd[...]S4OQ5IQvzm00w==
npm notice total files:   7
npm notice
+ asciidoctor-extension-interactive-runner@1.2.0
----

Parler de .npmignore et de .gitignore

[[link]]
=== `npm link` : utiliser une dépendance qui n'a pas encore été publiée

[[questions]]
== Questions et mystères autour de npm

L'exécutable `npm` et le registre du même nom ont accompagné Node quasiment
depuis le début.
Il paraît simple de prime abord et je pense que c'est normal de se sentir
surpris·e par ses résultats.

Passons en revue des critiques ou questionnements que j'entends régulièrement
afin d'y voir plus clair.

[[npm.update]]
=== Quand mettre à jour l'exécutable npm ?

L'exécutable `npm` est mis à jour régulièrement.
Un message s'affiche dans notre terminal lorsque nous l'utilisons et qu'il
détecte qu'une version plus récente est disponible.

[subs="+attributes"]
----
╭─────────────────────────────────────╮
│                                     │
│   Update available 6.0.0 → {npmvX}    │
│     Run npm i -g npm to update      │
│                                     │
╰─────────────────────────────────────╯
----

Le module qui contient l'exécutable `npm` suit le principe de
<<semver,versions sémantiques>>.
Ainsi, la mise à jour sera sans effort si le numéro majeur de la
nouvelle version reste le même.

J'ai tendance à regarder du côté de [URL]#https://github.com/npm/npm/releases#
pour lire tous les _Breaking Changes_ et comprendre en quoi la mise à jour
majeure m'affecte.

[[package-lock]]
=== Je ne vois pas l'intérêt du fichier `package-lock.json`

Le fichier `package-lock.json` est créé automatiquement par l'exécutable `npm`
dès que vous ajoutez votre première dépendance à un projet.

Jetons un œil à son contenu pour tenter d'en cerner les contours :

----
{
  "name": "nodebook.chapter-05",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "acorn": {
      "version": "5.6.1",
      "resolved":
        "https://registry.npmjs.org/acorn/-/acorn-5.6.1.tgz",
      "integrity": "sha512-...",
      "dev": true
    },
    "cowsay": {
      "version": "1.3.0",
      "resolved":
        "https://registry.npmjs.org/cowsay/-/cowsay-1.3.0.tgz",
      "integrity": "sha512-...",
      "requires": {
        "get-stdin": "^5.0.1",
        "optimist": "~0.6.1",
        "string-width": "~2.1.1",
        "strip-eof": "^1.0.0"
      }
    },
    ...
  }
}
----

Il ressemble beaucoup au fichier `package.json`.
On notera qu'il contient exclusivement des données liées aux dépendances
ainsi que *toutes les dépendances des dépendances*.

Si le fichier `package.json` contient une <<semver,version sémantique>>,
celui **contient la version exacte** de chaque dépendance ainsi que deux
autres types d'informations : l'URL de téléchargement et une signature
qui permet de vérifier si le fichier télécharger est le bon (intégrité).

La représentation complète de l'arbre de dépendances dans le fichier `package-lock.json`
traduit deux intentions :
rendre l'installation des dépendances possibles en se basant uniquement sur
ce fichier et accélérer le processus d'installation.

Avantages::
  - Le projet s'installe encore plus rapidement grâce à la commande `npm ci`.
  - Nous pouvons reproduire la même installation sur plusieurs ordinateurs.
  - La commande `npm install` installe plus rapidement en présence d'un fichier `package-lock.json`.
Inconvénients::
  - Nous devons vérifier manuellement s'il y a des patchs à coup de `npm outdated` et de `npm update`.
  - Ça fait un truc de plus à apprendre même si on n'a pas l'impression de l'utiliser.

[[bower]]
=== npm c'est pour le backend et bower pour le frontend

_bower_ ([URL]#https://bower.io#) est un gestionnaire de modules
spécialisé dans le développement frontend.

Je pense que _bower_ était utile à une époque où l'outillage frontend disponible
dans Node était encore confidentiel.
Je pense aussi que cette époque est révolue, au sens où l'outillage dédié à
Node et aux navigateurs web tend à se confondre.

En apprenant JavaScript, Node et npm, nous gagnons non seulement un outillage
disponible immédiatement mais aussi la capacité à créer le nôtre.
Pour en savoir plus sur comment développer pour le frontend comme on développe
pour Node, je vous invite à lire le <<../chapter-09/index.adoc#,chapitre 9>>.

Avantages::
  - On peut installer un projet sans qu'il possède un fichier `package.json`.
  - On n'a pas nécesairement besoin de s'outiller pour utiliser les modules bower.
Inconvénients::
  - Si on utilise déjà un fichier `package.json` pour d'autres besoins, autant l'utiliser pour les dépendances frontend, autant utiliser npm.
  - Le développement de bower stagne depuis 2015 et je pense que le projet sera arrêté tôt ou tard.

=== Est-ce que je dois versionner le répertoire `node_modules` ?

Le contenu du répertoire `node_modules` se recrée automatiquement
en utilisant l'exécutable `npm`, que ça soit avec la
<<install,commande `npm install`>> ou la <<update,commande `npm update`>>.
Mieux vaut versionner les fichiers `package.json` et
<<package-lock,`package-lock.json`>> pour être certain·e
de les recréer comme il faut.

Le répertoire `node_modules` n'a donc pas besoin d'être versionné.
Je vous encourage à *ajouter `node_modules` dans le fichier `.gitignore`*.
Ce fichier texte se situe en général à la racine de votre projet.

Avantages::
  - Je n'en vois pas.
Inconvénients::
  - Difficile à versionner avec Git en cas de conflit.
  - Ça va exploser si deux personnes utilisent des systèmes d'exploitation différents — certaines dépendances génèrent des fichiers en fonction du système.
  - Ça va exploser s'il manque un module quelque part — et ça sera un problème plus à régler que de _ne pas_ versionner ce répertoire.

[[yarn]]
=== Il paraît que Yarn, c'est mieux

L'application _yarn_ ([URL]#https://yarnpkg.com#) se veut être une alternative
à l'exécutable `npm`.
Le programme vise une installation rapide, hors-ligne et sécurisée.

npm rattrape régulièrement les fonctionnalités qui "donnent de l'avance" à _yarn_.
Le choix tient donc plutôt du goût ou de l'idéologie.
Essayez donc _yarn_ et gardez-le pour les bonnes raisons — les vôtres.

Avantages::
  - Le mode _workspace_ permet de lier plusieurs projets entre eux de manière déclarative.
Inconvénients::
  - Il faudra quand même savoir comment fonctionne npm pour les projets qui n'utilisent pas _yarn_.

[[all-your-base-are-belong-to-us]]
=== npm est lent, il installe la moitié d'Internet à chaque fois

L'exécutable `npm` passe le plus clair de son temps à faire des aller-retours
vers le registre npm en utilisant votre connexion Internet.
Il téléchargera un module seulement s'il ne l'a pas déjà téléchargé à une autre
reprise, sur un autre projet.

L'équipe de développement de l'exécutable `npm` travaille à améliorer
ses performances et sa qualité d'utilisation.
Cette équipe n'a pas d'influence sur les choix faits par les autrices et auteurs
de modules npm.

Le temps de téléchargement d'un module npm dépend de deux choses :
du *nombre de dépendances* à installer et de leur *poids respectif*.
Le poids d'un module correspond à la somme du poids de chaque script et
des ressources additionnelles (images, documentation, etc). +
Dans les deux cas, *plus il y'en a, plus ça prendra de temps à installer*.

Par exemple, le seul ajout de _webpack 4_ ([URL]#https://npmjs.com/webpack#)
augmente le coût de téléchargement de 14Mo lors de `npm install`.
Ce n'est pas rien et ce n'est certainement pas la faute à l'exécutable `npm`.

Le service en ligne _Package Phobia_ ([URL]#https://packagephobia.now.sh#)
garde un historique du poids des modules npm.
Celui de _webpack_ se trouve sur
[URL]#https://packagephobia.now.sh/result?p=webpack#.

.Coût d'installation du module npm _webpack_ (en vert foncé) et de ses dépendances (en vert clair).
image::images/module-content.png[]


[TIP]
.[RemarquePreTitre]#Pratique# Connaître le coût des dépendances de son projet
====
Le module npm _cost-of-modules_ ([URL]#https://npmjs.com/cost-of-modules#)
calcule la quantité et le poids des dépendances listées
dans un fichier `package.json`.

Pratique pour identifier quel module remplacer par un autre, plus léger et donc
plus rapide à installer.

----
$ npx cost-of-modules               # <1>
┌───────────┬─────────────┬───────┐
│ name      │ children    │ size  │
├───────────┼─────────────┼───────┤
│ lodash    │ 0           │ 1.34M │
├───────────┼─────────────┼───────┤
│ micro     │ 19          │ 0.67M │
├───────────┼─────────────┼───────┤
│ cowsay    │ 9           │ 0.22M │
├───────────┼─────────────┼───────┤
│ 3 modules │ 28 children │ 2.22M │
└───────────┴─────────────┴───────┘
----
<1> La <<npx,commande `npx`>> est un raccourci pour exécuter des modules npm sans les installer.
====


[[errors]]
=== Que signifient les erreurs affichées pendant `npm install` ?

L'exécutable `npm` est généreux en messages pendant l'installation
de modules.
C'est parfois difficile à lire, notamment pour comprendre la raison du message
et la solution à apporter.

Si `npm WARN` s'affiche, ce n'est pas une erreur mais un message
à caractère informatif. +
Si `npm ERR` débute la ligne, il y a un problème sur lequel nous
avons une action immédiate à mener.

[[error-deprecated]]
==== Module déprécié

Un module est déprécié quand il n'est plus maintenu par ses auteurs ou autrices,
s'il est développé sous un nouveau nom ou si nous sommes encouragé·e·s à
<<install.version,faire une mise à jour majeure>>.

Un module déprécié ne nous regarde pas sauf s'il est listé dans le champ
`dependencies` ou `devDependencies` d'un fichier `package.json`.

[subs="-specialchars"]
.Exemple d'encouragements à utiliser un autre module.
----
npm WARN deprecated babel-preset-es2017@6.24.1:
  Thanks for using Babel: <i>we recommend using babel-preset-env</i>
  now: please read babeljs.io/env to update!

npm WARN deprecated babel-preset-babili@0.0.10: babili has
  been <i>renamed to babel-minify</i>.
  Please update to babel-preset-minify
----

[subs="-specialchars"]
.Exemple de module qui n'est plus maintenu.
----
npm WARN deprecated nomnom@1.6.2: <i>Package no longer supported</i>.
  Contact support@npmjs.com for more info.
----

Un module qui n'est plus maintenu ne recevra probalement plus de mises à jour.
Il vaut mieux dans ce cas en trouver un autre qui fait plus ou moins la même chose.

[[error-skipping]]
==== Problème avec une dépendance optionnelle

Certains modules effectuent une opération de compilation : une partie de leur
code source est écrit dans un autre langage que l'ECMAScript et ils
font en sorte de créer un pont avec Node.

Il arrive que l'opération de compilation n'aboutisse pas pour diverses raisons
— il manque un logiciel, incompatibilité avec le système d'exploitation
ou avec l'architecture du CPU.

Le fait qu'il y ait marqué `SKIPPING` et `OPTIONAL` me laisse penser
que ce n'est pas grave si l'opération ne se passe pas comme prévu.

----
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY:
  Unsupported platform for fsevents@1.1.3:
  wanted {"os":"darwin","arch":"any"}
  (current: {"os":"win32","arch":"x64"})
----

[[error-404]]
==== Module introuvable

Le module que vous cherchez à installer n'existe pas.
Il s'agit peut-être d'une erreur de frappe ou alors le module a été retiré
de la circulation.

----
$ npm i aria-roless
npm ERR! code E404
npm ERR! 404 Not Found: aria-roless@latest
----

[[error-crlf]]
==== Caractère de fin de ligne sous Windows

Les anciennes versions de npm avaient du mal à concilier les caractères de fin
de ligne sous Windows (`\r\n`), caractère différent des autres systèmes Linux (`\n`).

----
npm error Expected linebreaks to be 'LF' but
  found 'CRLF' linebreak-style
----

<<npm.update,Mettez à jour npm>> vers une version plus récente pour
régler le problème.

[[error-pkg]]
==== Fichier `package.json` incomplet

Les messages suivants s'affichent quand les champs `description` et
`repository` manquent à l'appel de notre fichier `package.json`.

----
npm WARN tmp@1.0.0 No description
npm WARN tmp@1.0.0 No repository field.
----

Réferrez-vous à la section <<package.json,anatomie du fichier `package.json`>>
pour savoir comment remplir ces champs manquants.

[[error-peer-dependency]]
==== Dépendance complémentaire à installer

Certains modules nécessitent un ou plusieurs modules complémentaires pour
fonctionner.
Toutefois ces modules complémentaires sont à installer manuellement.
C'est la signification du message d'erreur suivant.

[subs="-specialchars"]
----
npm WARN <i>react-power-picture</i>@1.0.0 <i>requires</i> a peer of
  <i>react</i>@^15.0.0-0 || ^16.0.0-0 but none is installed.
  You must install peer dependencies yourself.
----

L'exemple précédent laisse à penser que nous avons installé le module npm
_react-power-picture_.
L'installation du module signale que le module npm complémentaire _react_
est nécessaire mais que nous ne l'avons pas installé.

Si c'est quelque chose qui vous parle, installez alors _react_
avec `npm install react`. +

Si vous pensez que c'est une erreur ou une incompréhension, désinstallez
le module et cherchez une alternative.
Ça se produit généralement quand on n'aperçoit pas qu'un module est dédié
à un certain framework — et qu'on ne veut pas utiliser ce framework.

== Conclusion

TBD.
