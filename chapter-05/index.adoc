:chapterNumber: 5
:chapterId: chapter-05
:sourceDir: ./examples
:sourceSample: cow.js
:nodeCurrentVersion: v10
:npmCurrentVersion: v6
:npmvX: 6.1.0
:sectnums:
:revdate: {docdate}
:imagesdir: {indir}
ifdef::env[]
:imagesdir: .
endif::[]

= Jouer avec npm

TBD.

====
.Sommaire
- Créer un projet
- Installer un module npm
- Aller et venir entre les versions d'un module npm
- Outiller un projet avec les scripts npm
- Publier un module sur le registre npm
- Questions et mystères autour de npm
====

[abstract]
--
TBD.
--

include::../resources/tip-versions.adoc[]
include::../resources/tip-examples.adoc[]

Le mot _npm_ correspond à trois concepts différents que nous aborderons
tout au long de ce chapitre :

- l'*exécutable* `npm` — un programme écrit en JavaScript ;
- le *registre* _npm_ — une plate-forme de distribution de modules ;
- un *module* _npm_ — en général installé depuis le registre et utilisable avec la fonction `require()`.

Je préciserai toujours si l'utilisation de _npm_ fait référence
à l'_exécutable_, au _registre_ ou à un _module_.

L'exécutable `npm` est installé par défaut avec l'exécutable `node`.
Nous pouvons vérifier la version installée en ouvrant un terminal
et en écrivant la commande suivante :

[subs="+attributes"]
----
$ npm --version
{npmvX}
----

Si un message s'affiche en indiquant que `npm` n'est pas un programme reconnu,
veuillez vous référer au <<../chapter-02/index.adoc,chapitre 2>> et
vérifier que Node {nodeCurrentVersion} est bien installé.


[[cli]]
== Créer un fichier `package.json`

La présence d'un fichier `package.json` est nécessaire pour utiliser npm
dans un projet.
La commande `npm init` génère un tel fichier en nous posant des questions.
Nous irons plus vite en utilisant l'option `--yes` :

----
$ npm init --yes
----

Le fichier `package.json` sera créé avec le contenu suivant :

----
{
  "name": "<nom du répertoire>",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
----

S'il existe déjà ce n'est pas grave, nous le réutiliserons pour la suite
de ce chapitre.

Nous allons d'ailleurs ignorer le contenu du fichier pour l'instant
afin de nous focaliser sur l'opération la plus importante et la plus
fréquemment utilisée : `npm install`.

[[modules]]
== Installer des modules npm



=== Depuis le registre npm


----
$ npm install cowsay
----

[source,json]
.package.json
----
include::package.json[lines="1,19..-1"]
----

[source%interactive,javascript]
.cow.js
----
include::{sourceDir}/cow.js[]
----

----
$ node cow.js
___________
< Bonjour ! >
-----------
       \   ^__^
        \  (oo)\_______
           (__)\       )\/\
               ||----w |
----

Le module est désormais installé dans le répertoire `chapter-05/node_modules/comma-separated-values` et est disponible pour tout script invoqué dans le répertoire `chapter-05`.

Lire du contenu CSV et en afficher son contenu devient aussi simple que le script suivant :

Il est toutefois recommandé d'installer les modules localement, afin de limiter leur portée uniquement au projet tout en maintenant une dépendance explicite et gérable via le fichier _package.json_.

Déroulons ensemble l'algorithme d'installation de `npm install` par le biais de cet exemple :

La commande précédente effectue plusieurs opérations :

1. requête du registre _npmjs.com_ à propos des deux modules _async_ et _yargs_ ;
2. si les modules existent, la version compatible la plus récente est retournée (équivalent à `npm view async version` et `npm view yargs version` — respectivement `2.1.4` et `6.6.0`) ;
3. téléchargement et décompression des paquets dans les répertoires `node_modules/async` et `node_modules/yargs` ;
4. introspection récursive des dépendances de ces modules et si besoin est, téléchargement et décompression dans leur répertoire _node_modules_ respectif (ici `node_modules/async/node_modules` et `node_modules/yargs/node_modules`) ;
5. inscription de _async_ et de _yargs_ dans la configuration _dependencies_ de notre fichier `package.json`.

La commande npm prend soin de télécharger et de persister les dépendances, à la fois dans le répertoire _node_modules_ et dans le fichier _package.json_.
Ce dernier contient désormais une section _dependencies_ :

[source,javascript]
.package.json
----
include::package.json[lines=1..2;19..-1]
----

[TIP]
.[RemarquePreTitre]#Aide# Plusieurs types de dépendances
====
Il existe plusieurs types de dépendances, chacune ayant sa propre utilité :

- *dependencies* : dépendances utiles à un fonctionnement en production ;
- *devDependencies* : dépendances utiles uniquement dans le cadre du développement, par exemple pour exécuter des tests ou s'assurer de la qualité du code ou encore empaqueter le projet ;
- *optionalDependencies* : dépendances dont l'installation ne sera pas nécessairement satisfaite, notamment pour des raisons de compatibilité. En général votre code prévoira que le chargement de ces modules via `require()` pourra échouer en prévoyant le traitement des exceptions avec un `try {} catch ()` ;
- *peerDependencies* : modules dont l'installation vous est recommandée ; pratique couramment employée dans le cas de _plugins_. +
Par exemple, si votre projet `A` installe `gulp-webserver` en `devDependencies` et que `gulp-webserver` déclare `gulp` en `peerDependencies`, npm vous recommandera d'installer également `gulp` en tant que `devDependencies` de votre projet `A`.
====
Les modules installés sont désormais manipulables via la fonction `require` au sein de notre code :

[source%interactive,javascript]
----
const async = require('async');
const { argv } = require('yargs');
----

Maintenant que nous savons installer et sauvegarder des dépendances par le biais du fichier `package.json`, sauvegardons l'état actuel du projet avec un gestionnaire de versions.

=== Désintaller un module

=== Spécifier une version

=== Depuis un fichier `package.json`

----
$ rm -rf node_modules
$ npm install
added 10 packages from 3 contributors in 2.276s
found 0 vulnerabilities
----




[[heuristics]]
=== Trouver son bonheur sur le registre npm


Le _registre npm_ ([URL]#https://npmjs.com#) fourmille de modules en tous genres.
Ils fournissent de simples fonctions, des librairies ou des _frameworks_
complets pour gérer vos accès réseau, vos bases de données, la qualité de vos projets et leur automatisation.

La *sélection d'un module est un choix subjectif* : la qualité, la pertinence
et la popularité sont corrélées sans pour autant être des critères impératifs. +
Un module peu populaire sera-t-il moins bon pour autant ? Un module populaire
est-il plus performant qu'une alternative ? Un module bien testé sera-t-il
plus aisé à utiliser ?

Bref, pour vous aider à choisir — et ce peu importe le contexte — voici une
liste subjective de critères et leur impact sur votre processus de décision :

- *documentation* : un fichier _README_ décrivant l'API ou une
*documentation technique illustrée d'exemples* sont des exemples d'objectif de
qualité aidant tant à l'utilisation qu'à la contribution du-dit module ;
- *badge d'intégration continue* : la présence de tests est indispensable pour
assurer une certaine qualité. Le badge d'intégration continue est un mécanisme
supplémentaire pour démontrer l'*existence de tests* et leur *automatisation*
lors de toute contribution de code ;
- *dépendances* : l'existence de modules reposant sur un autre démontre une
*marque de confiance* d'autres développeurs. Confiance suffisante dans la solidité
des fondations sur lesquelles ils s'appuient pour bâtir leur propre module ;
- *date de mise à jour* : une ou plusieurs versions majeures de Node sont-elles
sorties entre temps ? Si oui, des *risques d'incompatibilité* peuvent se
présenter. Certaines dépendances peuvent également être devenues obsolètes ou
avoir présenté des failles de sécurité ;
- *maintenance* : si personne ne met à jour le module alors que des contributions
se présentent, cela peut se révéler bloquant, dénoter une *obsolescence* d'idée
ou impliquer l'existence d'un _fork_ de ce module ;
- *état des contributions* : les mainteneurs répondent-ils aux contributeurs ?
Les contributions de code sont-elles acceptées dans des conditions légitimes ?
Ou tout simplement, y a-t-il beaucoup de déclaration de bugs en suspens ?
Telles sont les indicateurs de vitalité pour estimer la gravité et la
probabilité que la librairie nous explose au visage lorsqu'on ne s'y attendra pas.

.Page npm d'un module populaire et fiable
image::images/module-npm-ok.png[width="85%"]

.Page npm peu encourageante
image::images/module-npm-ko.png[width="85%"]

Enfin, n'oubliez pas qu'il s'agit de critères subjectifs.
Les mainteneurs du module ne sont peut-être pas de bons communicants ou n'ont
que peu d'expérience en termes de tests ou ils n'ont tout simplement pas eu le temps. +
N'hésitez pas à les encourager si vos expérimentations se révèlent concluantes.
Contribuez des tests et de la documentation à hauteur de votre temps.
Même s'il ne s'agit _que_ de cinq lignes de code, d'un exemple supplémentaire
ou d'une faute d'orthographe en moins.

C'est comme cela que l'écosystème s'améliore petit à petit et que vous apprenez
par la même occasion.

[TIP]
.[RemarquePreTitre]#Communauté# Des personnes de confiance
====
Des organisations et des individus contribuent activement à Node en mettant à
disposition une large majorité de leurs créations.

La liste suivante est non-exhaustive et référence des contributeurs de qualité :

- substack ([URL]#https://npmjs.com/~substack#) ;
- jshttp ([URL]#https://github.com/jshttp#) ;
- nodejitsu ([URL]#https://github.com/nodejitsu#) ;
- mafintosh ([URL]#https://npmjs.com/~mafintosh#) ;
- feross ([URL]#https://npmjs.com/~feross#) ;
- dougwilson ([URL]#https://npmjs.com/~dougwilson#) ;
- isaacs ([URL]#https://npmjs.com/~isaacs#) ;
- fgribreau ([URL]#https://npmjs.com/~fgribreau#) ;
- mikeal ([URL]#https://npmjs.com/~mikeal#) ;
- rwaldron ([URL]#https://npmjs.com/~rwaldron#).
====

== Autres


=== Depuis un répertoire local

=== Depuis GitHub, GitLab ou un dépôt Git

=== En tant que dépendance de développement

=== En tant qu'exécutable système (installation globale)

== Aller et venir entre les versions d'un module npm

=== Choisir la version à installer

[[semver]]
=== Versions sémantiques (_Semantic Versionning_)

Le versioning sémantique définit deux concepts importants :

- le principe de *numérotation* de version ;
- les *plages de compatibilité* de versions.

Un numéro de version doit respecter la forme `MAJEUR.MINEUR.CORRECTIF` (`MAJOR.MINOR.PATCH`).

Si on considère le numéro de version `1.0.0` :

- `1.0.1` est une version corrigeant un défaut ;
- `1.1.0` est une version ajoutant ou modifiant des fonctionnalités mais ne cassant pas la compatibilité avec le reste de la branche `1.x.x` ;
- `2.0.0` est une version cassant la compatibilité descendante.

Par convention, les versions `0.x.x` sont considérées comme des versions _instables_ en préparation d'une future branche stable (`1.x.x`).

La spécification _semver_ est disponible sous forme textuelle mais également en tant que module npm.

- [URL]#https://npmjs.com/semver#
- [URL]#http://semver.org/lang/fr/#

L'utilisation de certains caractères permet d'exprimer des *plages de compatibilité*, très utiles lors de l'installation ou de la mise à jour de modules _npm_ :

- `~1.0.0` : mises à jour mineures de la branche `1.0.0` (`1.0.1`, `1.0.2`, etc.) ;
- `1.0.x` : idem ;
- `^1.0.0` : mises à jour mineures et correctives de la branche `1.0.0` (`1.0.1`, `1.1.0`, `1.1.1`, etc.) ;
- `1.x.x` : idem ;
- `>1.0.0` : mises à jour majeures, mineures et correctives au-delà de la branche `1.0.0` (`1.0.1` mais pas `1.0.0`, `1.1.0`, `2.0.0`, `3.1.0`, etc.) ;
- `>1 <3` : mises à jour majeures, mineures et correctives entre la branche `1.0.0` et `3.0.0` (`2.0.0`, `2.0.1`, `2.1.0`, etc.) ;
- `>1` : mises à jour majeures, mineures et mineures au-delà de la branche `1.0.0` (`2.0.0`, `2.0.1`, `3.1.0`, etc.).

Cette syntaxe est notamment employée pour spécifier les plages de mises à jour  acceptées pour les paquets `npm`.
Cela permet entre autres de bénéficier de mises à jour de manière consentante (_opt-in_) à chaque installation ou mise à jour de vos applications.

[TIP]
.[RemarquePreTitre]#Outil# Calculateur de version
====
Un outil est à disposition pour tester la syntaxe des plages de versions en temps réel sur des données de véritables paquets.

- [URL]#https://semver.npmjs.com/#
====


[NOTE]
.[RemarquePreTitre]#Lien# Versioning romantique
=====
Certaines personnes pensent que l'aspect _sémantique_ n'est pas assez clair pour véhiculer l'_intention_ des auteurs quant à la publication d'une nouvelle version.
Ils en sont venus à proposer plus ou moins sérieusement les notions de *versioning sentimental* et de *versioning romantique*.

- [URL]#http://dafoster.net/articles/2015/03/14/semantic-versioning-vs-romantic-versioning/#
=====

== Outiller un projet avec les scripts npm

=== Démarrer l'application

=== Exécuter des tests


L'écriture de tests et la vérification de la qualité de votre code sont un excellent
moyen de vous assurer que de nouveaux bugs ne sont pas introduits dans votre application.

Écrire des modules et les empiler sans écrire de tests revient à construire un
château de carte : le moindre changement accentue le risque de propager des
erreurs dans toutes les applications en dépendant.

Nous verrons ultérieurement comment écrire des tests unitaires pour vos
applications et votre code exécuté dans un contexte Web.

À la manière du démarrage d'une application, la commande npm fournit un
contexte d'exécution dédié aux tests :

----
$ npm test
----

Cette commande effectue deux choses :

- elle règle la variable d'environnement `NODE_ENV` à `test` ;
- elle exécute l'instruction du script `test` déclarée dans le fichier `package.json` :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*"
  }
}
----

Dans cet exemple, exécuter la commande `npm test` revient à actionner l'exécutable
déclaré par le module _mocha_ avec comme argument l'ensemble des fichiers
JavaScript contenus dans le répertoire `tests/` de notre projet.

En cas de test fautif, l'exécutable de tests affichera des précisions quant à
leur origine et se terminera avec un code de sortie différent de 0.

Ce qui signifie en jargon Unixien que vous pouvez chaîner la commande avec
d'autres actions basées sur un état de réussite des tests :

----
$ npm test && git push
----

Cette précédente commande a deux scénarios possibles :

1. `npm test` échoue et `git push` ne sera pas exécuté ;
2. `npm test` réussit et `git push` sera exécuté.

En se basant sur ce principe de chaîne, vous pouvez faire évoluer votre commande
de test en quelque chose de plus poussé :

[source]
.package.json
----
{
  "name": "nodebook",
  ...
  "scripts": {
    "test": "npm run lint-code && npm run unit-tests",
    "lint-code": "eslint ",
    "unit-tests": "mocha tests/**/*.js"
  },
  "devDependencies": {
    "mocha": "*",
    "eslint": "^3.0.0"
  }
}
----

La commande `npm test` est alors composée de deux autres commandes personnalisées.
Vous maintenez ainsi une lisibilité au sein de votre fichier `package.json`
tout en bénéficiant d'une indépendance d'exécution de vos commandes.


== Publier un module npm

=== Le champ `main` du fichier `package.json`

=== Choisir une licence d'utilisation

=== Renseigner les informations importantes

Cf. #heuristics


== Quelques commandes pour aller plus loin

[[audit]]
=== `npm audit` : vérifier la sécurité des dépendances

[[prune]]
=== `npm prune` : supprimer les dépendances inutilisées

[[doctor]]
=== `npm doctor` : vérifier l'état du système

[[config]]
=== `npm config` : changer les réglages de l'exécutable `npm`

[[link]]
=== `npm link` : utiliser une dépendance qui n'a pas encore été publiée

[[outdated]]
=== `npm outdated` : lister les dépendances à mettre à jour


Maintenir ses dépendances à jour est important pour deux raisons :

- *colmater des bugs* qui pourraient se répercuter sur votre application ;
- se *prémunir de faille de sécurité* mettant en danger vos données et votre
système informatique.

En dernier recours, vérifier la fraîcheur de ses dépendances permet de prendre
connaissance de nouvelles versions majeures ou mineures dont vous pourriez bénéficier.

Quoi qu'il en soit, une commande npm nous aidera une fois de plus à obtenir les
informations voulues :

----
$ npm outdated
----

La lecture de sa sortie peut être déroutante au premier abord, notamment dans
le cas d'un module qui n'a pas été mis à jour via `npm update` depuis un moment :

.Résultats obsolètes issus de `npm outdated`
image::images/npm-outdated.png[width="85%"]

Le tableau ne liste que les dépendances considérées comme obsolètes en l'état
actuel d'installation de votre projet.
Il se peut donc que le résultat varie d'une machine à l'autre, en fonction des
versions installées localement. +
Les résultats sont divisés en cinq colonnes :

- *Package* : nom du paquet concerné — en jaune une dépendance qui sera
satisfaite en cas de `npm update`, en rouge une dépendance qui nécessite une mise à jour manuelle ;
- *Current* : version installée localement — _MISSING_ sera affiché si la
dépendance n'est pas encore installée, _git_ indique que la dépendance est installée via git ;
- *Wanted* : version installée après exécution de `npm update` ;
- *Latest* : version la plus récente publiée dans le registre npm ;
- *Location* : emplacement de la dépendance — dépendance directe ou dépendance
incluse dans une autre dépendance, etc.


La première action à mener est de procéder à l'exécution de la commande
`npm update`, puis de relancer la commande `npm outdated` :

.Résultats `npm outdated` après mise à jour
image::images/npm-outdated-wanted.png[width="85%"]

Le résultat est probant : de nombreuses dépendances précédemment listées en rouge
 ont disparu.
Il ne reste que trois dépendances sur lesquelles nous pouvons avoir une action
directe en modifiant la version référencée dans le fichier `package.json`.


[[update]]
=== `npm update` : mettre à jour les dépendances en toute sécurité

== Questions et mystères autour de npm

=== Je ne vois pas l'intérêt du fichier `package-lock.json`

=== npm c'est pour le backend, bower (ou autre) pour le frontend

=== Il paraît que Yarn, c'est mieux

=== npm est lent, il installe la moitié d'Internet à chaque fois

=== Quels sont ces messages d'erreurs pendant l'installation ?


== Conclusion
